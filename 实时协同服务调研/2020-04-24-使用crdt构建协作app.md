构建一个协作应用， 比如 Google docs，虚拟可视化工具 Realtime Board 或者是设计工具 Figma，让多个用户在线协作，是一项带有很多问题的任务。


使用包含单个用户应用程序的相同方法创建协作应用程序是行不通的，我将在这篇文章中说明这一点。(在我的硕士论文中，我研究了这个主题，并创建了一个协作的图形编辑工具)。

幸运的是，已经有研究致力于解决这些问题，其中一个解决方案就是使用无冲突的复制数据类型（CRDT),它是可以在协作应用程序中使用的数据类型的集合。


在本文中我将会介绍 CRDT 解决的一系列问题，以及它如何被应用到编辑文档（在CRDT术语中称为序列
），集合，寄存器，计数器，图形，可以在许多不同的用例中使用。

我将首先解释CRDTs解决的问题，然后我们将更深入地讨论并解释一些常见的CRDTs。

术语副本（replica）将描述单个用户或服务器拥有的数据的副本。

不同的副本将会合并，合并之后，会有两个副本拥有相同的状态。
CRDT 使用被称为最终一致性的 一致性模型，稍后会对此做详细介绍。

在 维基百科 中定义最终一致性：
> Eventual consistency is a consistency model used in distributed computing to achieve high availability that informally guarantees that, if no new updates are made to a given data item, eventually all accesses to that item will return the last updated value.

最终一致性是分布式计算中用于实现搞可用的一致性模型，如果没有对给定的数据项进行新的更新，最终对该项的所有访问都将返回最后更新的值。

强最终一致性，强调一些保证一致性的数学原理，我将在后面解释。

这里有两种 CRDT 的类型，一种是基于状态的，即状态在副本之间发送并合并，另一种是基于操作的，即单个操作被发送到副本。


最简陋的 set 实现

在简单集实现中，我们有两个不同的副本，它们正在编辑可以表示为一个集的某种类型的数据。

蓝色的副本开始添加一个元素a，然后移除它。之后，它收到了一个添加元素a 的指令。最终，蓝色的副本状态由元素 a 组成。

黄色的副本开始接受一个添加指令，因此它添加了。下一次再添加（但没有发生变化）并且最终移除元素（收到了移除指令），这使得黄色的副本最终没有数据。

问题在于两个副本都收到了相同的指令，但他们却产生了两种不同的状态。所以这个实现是行不通的。稍后我将展示如何解决。


Naive counter implementation.

鉴于每次更改都只传递一次，因此基于操作的计数器是可以工作的，因为加法是可交换和关联的。 

基于状态的计数器不是宓等的，因此它们不会收敛。比如，如果你合并多次，值将增加，因此这将不起作用。

使用 max 函数将 1 和 2 合并将会得到2，尽管 3 才是最终正确答案。

通过使用矢量时钟，我们可以得到一个有效的计数器。


Naive sequence implementation

关于序列的问题已经在上图展示了，两份副本都是开始的数据都是 “abc”。 蓝色的副本插入一个字符 'e' 在 index 2 处。然后它接受了一个删除操作在 index1，最终为 “aec”。

黄色的副本开始删除一个操作，接下去插入了 “e” 在 index 2 ，最终结果为 “ace”。

在我们来看 CRDT 如何工作之前，我们先解释下一些数学原理。

```
交换律 a*b = b*a
结合律 (a*b)*c = a*(b*c)
幂等   (a*a) = a

* = 二元运算符 比如  max, union, or
```

交换和关联属性确保可以按顺序进行操作/更改。 幂等函数可确保状态与自身的合并是等效的。 清单2.1中的三个属性（缔合，交换和幂等）形成联接半模，请参见图2.1和图2.2。 联接半色调是部分有序的集合，对于每个子集都有一个联接，即最小上限（LUB）。对于任意两个给定的元素，都存在一个LUB。所有的元素都是根据二元关系排列的。在CRDT中，merge函数使用join-semilattice，这意味着对于任何给定的元素集合，都存在一个LUB，它将两个元素移动到相同的状态。max函数和union函数遵循这三个属性


Counter
计数器是最简单的CRDT，它将帮助您理解更复杂的CRDTs。但是，基于操作的计数器是可交换的和关联的，因此通过向另一个副本发送一个值将合并。

如前所述，基于状态的计数器不遵循CRDT后面的属性，除非它是使用向量时钟后面的属性实现的，其中每个副本在向量中都有一个指定的位置，这样它就可以增加计数器。然后，合并函数将使用两个向量的成对最大值，如前面的join-semilattice中所述。
