# 基于 Electron 的视频会议构建

### what is yuv and how difference from RGB ?

YUV 是一种颜色编码方式，与我们熟知的 RGB类似，但它们所代表的含义不同。
YUV 中的 “Y” 表示明亮度（Luminance或Luma），也就是灰度值；而“U”和“V” 表示的则是色度（Chrominance或Chroma），作用是描述影像色彩及饱和度，用于指定像素的颜色。

YUV 的编码方式主要用于电视系统以及模拟视频领域，它将亮度信息（Y）与色彩信息（UV）分离，没有UV信息一样可以显示完整的图像，只不过是黑白的，这样的设计很好地解决了彩色电视机与黑白电视的兼容问题。并且，YUV不像RGB那样要求三个独立的视频信号同时传输，所以用YUV方式传送占用极少的频宽。

#### 完整的YUV分量

![完整的YUV分量](https://user-gold-cdn.xitu.io/2019/12/1/16ebd3741ec846b1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

#### Y分量

![Y分量](https://user-gold-cdn.xitu.io/2019/12/1/16ebd374162da980?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

#### U分量

![U分量](https://user-gold-cdn.xitu.io/2019/12/1/16ebd37415d702e6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

#### V分量

![V分量](https://user-gold-cdn.xitu.io/2019/12/1/16ebd374230e875f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

### YUV render on canvas(webgl)

- yuv-buffer
- yuv-canvas

## 性能优化

1. 降低帧率
2. 降低分辨率
3. web worker

## 渲染进程间数据同步

Electron 中渲染进程间数据是不同步的。

虽然在我们的页面，是通过加载同一份 JavaScript 代码运行。但是 渲染进程 A 中执行时保存的状态并不能在渲染进程 B 中同步。

Electron 提供一个 全局变量用以共享进程间的数据。

即 global 对象。但它不具备事件机制，没有通信功能。即使在 global 上设置了新的数据，其他使用到该数据的进程无法感知到。

我们需要一种消息机制来告知进程有数据变更。即 IPC。
通过 IPC 调用，类似发布订阅模式。

所以，对于会议期间的用户列表在渲染进程间更新的模式方式是：

1. 渲染进程A 收到 Soda 新用户加入，写入数据，并通知主进程
2. 主进程收到通知后，转发给另外的渲染进程B
3. 渲染进程B 收到后，读取数据并写入

在真正的产品中，渲染进程写入到 indexedDB，待 DB 更新后告知其他渲染进程从 indexedDB 获取新的数据。

这里可能会有人觉得这样每次渲染进程都是从数据库读取完整的数据，而不是增量更新，会不会有执行时的性能问题？

而其实 indexedDB 的数据读写是异步的，(而且支持在 web worker 中使用)并不阻塞线程。

如果要进行增量更新的话，模式就会成为命令模式，即 （type, data) 的组合值，这样虽然做到了精细化，性能最优，但却增加了编码的复杂度。（需要根据不同的类型匹配对应的处理）。

在项目前期我们选择了对性能影响不那么大且快速的方案。
