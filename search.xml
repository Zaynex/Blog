<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[重新认识cookie]]></title>
      <url>https://zaynex.github.io/2016/10/07/%E9%87%8D%E6%96%B0%E8%AE%A4%E8%AF%86cookie/</url>
      <content type="html"><![CDATA[<h3 id="cookie是什么"><a href="#cookie是什么" class="headerlink" title="cookie是什么"></a>cookie是什么</h3><p>cookie 就是浏览器储存在用户电脑上的一小段文本文件。cookie 是纯文本格式，不包含任何可执行的代码。<br><a href="http://www.cnblogs.com/aspnet_csharp/archive/2012/10/18/2729488.html" target="_blank" rel="external">具体存储位置参考地址</a><br>一个 Web 页面或服务器告知浏览器按照一定规范来储存这些信息，并在随后的请求中将这些信息发送至服务器，Web 服务器就可以使用这些信息来识别不同的用户。大多数需要登录的网站在用户验证成功之后都会设置一个 cookie，只要这个 cookie 存在并可以，用户就可以自由浏览这个网站的任意页面。</p>
<h3 id="创建cookie"><a href="#创建cookie" class="headerlink" title="创建cookie"></a>创建cookie</h3><p>Web 服务器通过发送一个称为 Set-Cookie 的 HTTP 消息头来创建一个 cookie，Set-Cookie 消息头是一个字符串，其格式如下（中括号中的部分是可选的）:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Set-Cookie: name=value[; expires=date][; domain=domain][; path=path][; secure]</div></pre></td></tr></table></figure></p>
<p>当存在一个 cookie，并允许设置可选项，该 cookie 的值会在随后的每次请求中被发送至服务器，cookie 的值被存储在名为 Cookie 的 HTTP 消息头中，并且只包含了 cookie 的值，忽略全部设置选项。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Cookie: name=value</div></pre></td></tr></table></figure></p>
<p>通过 Set-Cookie 指定的可选项只会在浏览器端使用，而不会被发送至服务器端。发送至服务器的 cookie 的值与通过 Set-Cookie 指定的值完全一样，不会有进一步的解析或转码操作。如果请求中包含多个 cookie，它们将会被分号和空格分开，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Cookie: value1; value2; name1=value1</div></pre></td></tr></table></figure></p>
<h3 id="cookie编码"><a href="#cookie编码" class="headerlink" title="cookie编码"></a>cookie编码</h3><p>对于 cookie 的值进行编码一直都存在一些困惑。普遍认为 cookie 的值必须经过 URL 编码，但其实这是一个谬论，尽管通常都这么做。原始规范中明确指出只有三个字符必须进行编码：分号、逗号和空格，规范中还提到可以进行 URL 编码，但并不是必须，在 RFC 中没有提及任何编码。然而，几乎所有的实现都对 cookie 的值进行了一系列的 URL 编码。对于 name=value 格式，通常会对 name 和 value 分别进行编码，而不对等号 = 进行编码操作。</p>
<h3 id="过期时间选项"><a href="#过期时间选项" class="headerlink" title="过期时间选项"></a>过期时间选项</h3><p>紧跟 cookie 值后面的每个选项都以分号和空格分开，每个选择都指定了 cookie 在什么情况下应该被发送至服务器。第一个选项是过期时间（expires），指定了 cookie 何时不会再被发送至服务器，随后浏览器将删除该 cookie。该选项的值是一个 Wdy, DD-Mon-YYYY HH:MM:SS GMT 日期格式的值，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Set-Cookie: name=Nicholas; expires=Sat, 02 May 2009 23:38:25 GMT</div></pre></td></tr></table></figure></p>
<p>没有设置 expires 选项时，cookie 的生命周期仅限于当前会话中，关闭浏览器意味着这次会话的结束，所以会话 cookie 仅存在于浏览器打开状态之下。这就是为什么当你登录一个 Web 应用时经常会看到一个复选框，询问你是否记住登录信息：如果你勾选了复选框，那么一个 expires 选项会被附加到登录 cookie 中。如果 expires 设置了一个过去的时间点，那么这个 cookie 会被立即删掉。</p>
<h3 id="domain选项"><a href="#domain选项" class="headerlink" title="domain选项"></a>domain选项</h3><p>下一个选项是 domain，指定了 cookie 将要被发送至哪个或哪些域中。默认情况下，domain 会被设置为创建该 cookie 的页面所在的域名，所以当给相同域名发送请求时该 cookie 会被发送至服务器。例如，本博中 cookie 的默认值将是 bubkoo.com。domain 选项可用来扩充 cookie 可发送域的数量，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Set-Cookie: name=Nicholas; domain=nczonline.net</div></pre></td></tr></table></figure></p>
<p>像 Yahoo! 这种大型网站，都会有许多 name.yahoo.com 形式的站点（例如：my.yahoo.com, finance.yahoo.com 等等）。将一个 cookie 的 domain 选项设置为 yahoo.com，就可以将该 cookie 的值发送至所有这些站点。浏览器会把 domain 的值与请求的域名做一个尾部比较（即从字符串的尾部开始比较），并将匹配的 cookie 发送至服务器。</p>
<h3 id="path选项"><a href="#path选项" class="headerlink" title="path选项"></a>path选项</h3><p>另一个控制 Cookie 消息头发送时机的选项是 path 选项，和 domain 选项类似，path 选项指定了请求的资源 URL 中必须存在指定的路径时，才会发送Cookie 消息头。这个比较通常是将 path 选项的值与请求的 URL 从头开始逐字符比较完成的。如果字符匹配，则发送 Cookie 消息头，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Set-Cookie:name=Nicholas;path=/blog</div></pre></td></tr></table></figure></p>
<p>在这个例子中，path 选项值会与 /blog，/blogrool 等等相匹配；任何以 /blog 开头的选项都是合法的。需要注意的是，只有在 domain 选项核实完毕之后才会对 path 属性进行比较。path 属性的默认值是发送 Set-Cookie 消息头所对应的 URL 中的 path 部分。</p>
<h3 id="secure选项"><a href="#secure选项" class="headerlink" title="secure选项"></a>secure选项</h3><p>最后一个选项是 secure。不像其它选项，该选项只是一个标记而没有值。只有当一个请求通过 SSL 或 HTTPS 创建时，包含 secure 选项的 cookie 才能被发送至服务器。这种 cookie 的内容具有很高的价值，如果以纯文本形式传递很有可能被篡改，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Set-Cookie: name=Nicholas; secure</div></pre></td></tr></table></figure></p>
<p>事实上，机密且敏感的信息绝不应该在 cookie 中存储或传输，因为 cookie 的整个机制原本都是不安全的。默认情况下，在 HTTPS 链接上传输的 cookie 都会被自动添加上 secure 选项。</p>
<h3 id="Cookie的维护和生命周期"><a href="#Cookie的维护和生命周期" class="headerlink" title="Cookie的维护和生命周期"></a>Cookie的维护和生命周期</h3><p>在一个 cookie 中可以指定任意数量的选项，并且这些选项可以是任意顺序，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Set-Cookie:name=Nicholas; domain=nczonline.net; path=/blog</div></pre></td></tr></table></figure></p>
<p>这个 cookie 有四个标识符：cookie 的 name，domain，path，secure 标记。要想改变这个 cookie 的值，需要发送另一个具有相同 cookie name，domain，path 的 Set-Cookie 消息头。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Set-Cookie: name=Nicholas; domain=nczonline.net; path=/</div></pre></td></tr></table></figure></p>
<p>这将覆盖原来 cookie 的值。但是，修改 cookie 选项的任意一项都将创建一个完全不同的新 cookie，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Set-Cookie: name=Nicholas; domain=nczonline.net; path=/</div></pre></td></tr></table></figure></p>
<p>这个消息头返回之后，会同时存在两个名为 “name” 的不同的 cookie。如果你访问 www.nczonline.net/blog 下的一个页面，以下的消息头将被包含进来：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Cookie: name=Greg; name=Nicholas</div></pre></td></tr></table></figure></p>
<p>在这个消息头中存在了两个名为 “name” 的 cookie，<code>path</code> 值越详细则 cookie 越靠前。 按照 <code>domain-path-secure</code> 的顺序，设置越详细的 cookie 在字符串中越靠前。假设我在 <code>ww.nczonline.net/blog</code> 下用默认选项创建了另一个 cookie：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Set-Cookie: name=Mike</div></pre></td></tr></table></figure></p>
<p>那么返回的消息头现在则变为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Cookie: name=Mike; name=Greg; name=Nicholas</div></pre></td></tr></table></figure></p>
<p>以 “Mike” 作为值的 cookie 使用了域名（www.nczonline.net）作为其 domain 值并且以全路径（/blog）作为其 path 值，则它较其它两个 cookie 更加详细。</p>
<h3 id="使用失效日期"><a href="#使用失效日期" class="headerlink" title="使用失效日期"></a>使用失效日期</h3><p>实际上，只有你手工的改变 cookie 的失效日期，否则其失效日期不会改变。这意味着在同一个会话中，一个会话 cookie 可以变成一个持久化 cookie（一个可以在多个会话中存在的），反之则不可。为了要将一个持久化 cookie 变为一个会话 cookie，你必须删除这个持久化 cookie，这只要设置它的失效日期为过去某个时间之后再创建一个同名的会话 cookie 就可以实现。</p>
<p>需要记得的是失效日期是以浏览器运行的电脑上的系统时间为基准进行核实的。没有任何办法来来验证这个系统时间是否和服务器的时间同步，所以当服务器时间和浏览器所处系统时间存在差异时这样的设置会出现错误。</p>
<h3 id="cookie自动删除"><a href="#cookie自动删除" class="headerlink" title="cookie自动删除"></a>cookie自动删除</h3><ul>
<li>会话 cooke (Session cookie) 在会话结束时（浏览器关闭）会被删除</li>
<li>持久化 cookie（Persistent cookie）在到达失效日期时会被删除</li>
<li>如果浏览器中的 cookie 数量达到限制，那么 cookie 会被删除以为新建的 cookie 创建空间。<br>对于自动删除来说，Cookie 管理显得十分重要，因为这些删除都是无意识的。</li>
</ul>
<h3 id="cookie限制条件"><a href="#cookie限制条件" class="headerlink" title="cookie限制条件"></a>cookie限制条件</h3><p>cookie 存在许多限制条件，来阻止 cookie 滥用并保护浏览器和服务器免受一些负面影响。有两种 cookie 限制条件：cookie 的属性和 cookie 的总大小。原始规范中限定每个域名下不超过 20 个 cookie，早期的浏览器都遵循该规范，并且在 IE7 中有更近一步的提升。在微软的一次更新中，他们在 IE7 中增加 cookie 的限制数量到 50 个，与此同时 Opera 限定 cookie 数量为 30 个，Safari 和 Chrome 对与每个域名下的 cookie 个数没有限制。</p>
<p>发向服务器的所有 cookie 的最大数量（空间）仍旧维持原始规范中所指出的：<code>4KB</code>。所有超出该限制的 cookie 都会被截掉并且不会发送至服务器。</p>
<h3 id="subcookies"><a href="#subcookies" class="headerlink" title="subcookies"></a>subcookies</h3><p>鉴于 cookie 的数量存在限制，开发者提出 subcookies 的观点来增加 cookie 的存储量。Subcookies 是存储在一个 cookie 值中的一些 name-value 对，通常与以下格式类似：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">name=a=b&amp;c=d&amp;e=f&amp;g=h</div></pre></td></tr></table></figure></p>
<p>这种方式允许在单个 cookie 中保存多个 name-value 对，而不会超出浏览器 cookie 数量的限制。通过这种方式创建 cookie 的负面影响是，需要自定义解析方式来提取这些值，相比较而言 cookie 的格式会更为简单。服务器端框架已开始支持 subcookies 的存储。</p>
<h3 id="JavaScript中的cookie"><a href="#JavaScript中的cookie" class="headerlink" title="JavaScript中的cookie"></a>JavaScript中的cookie</h3><p>在 JavaScript 中通过 <code>document.cookie</code> 属性，你可以创建、维护和删除 cookie。创建 cookie 时该属性等同于 Set-Cookie 消息头，而在读取 cookie 时则等同于 Cookie 消息头。在创建一个 cookie 时，你需要使用和 Set-Cookie 期望格式相同的字符串：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">document.cookie=&quot;name=Nicholas;domain=nczonline.net;path=/&quot;;</div></pre></td></tr></table></figure></p>
<p>设置 <code>document.cookie</code> 属性的值并不会删除存储在页面中的所有 cookie。它只简单的创建或修改字符串中指定的 cookie。下次发送一个请求到服务器时，通过 <code>document.cookie</code> 设置的 cookie 会和其它通过 Set-Cookie 消息头设置的 cookie 一并发送至服务器。这些 cookie 并没有什么明确的不同之处。</p>
<p>要使用 JavaScript 提取 cookie 的值，只需要从 document.cookie 中读取即可。返回的字符串与 Cookie 消息头中的字符串格式相同，所以多个 cookie 会被分号和字符串分割。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">name1=Greg; name2=Nicholas</div></pre></td></tr></table></figure></p>
<p>你需要手工解析这个 cookie 字符串来提取真实的 cookie 数据。<br>采用<code>decodeURIComponent()</code>来解析。</p>
<p>通过访问 document.cookie 返回的 cookie 遵循发向服务器的 cookie 一样的访问规则。要通过 JavaScript 访问 cookie，该页面和 cookie 必须在相同的域中，有相同的 path，有相同的安全级别。</p>
<p>注意：一旦 cookie 通过 JavaScript 设置后便不能提取它的选项，所以你将不能知道 domain，path，expires 日期或 secure 标记。</p>
<h3 id="HTTP-Only-cookies"><a href="#HTTP-Only-cookies" class="headerlink" title="HTTP-Only cookies"></a>HTTP-Only cookies</h3><p>微软的 IE6 SP1 在 cookie 中引入了一个新的选项：HTTP-only，HTTP-Only 背后的意思是告之浏览器该 cookie 绝不能通过 JavaScript 的 document.cookie 属性访问。设计该特征意在提供一个安全措施来帮助阻止通过 JavaScript 发起的跨站脚本攻击 (XSS) 窃取 cookie 的行为（我会在另一篇博客中讨论安全问题，本篇如此已足够）。今天 Firefox2.0.0.5+、Opera9.5+、Chrome 都支持 HTTP-Only cookie。3.2 版本的 Safari 仍不支持。</p>
<p>要创建一个 HTTP-Only cookie，只要向你的 cookie 中添加一个 HTTP-Only 标记即可：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Set-Cookie: name=Nicholas; HttpOnly</div></pre></td></tr></table></figure></p>
<p>一旦设定这个标记，通过 documen.coookie 则不能再访问该 cookie。IE 同时更近一步并且不允许通过 XMLHttpRequest 的 getAllResponseHeaders() 或 getResponseHeader() 方法访问 cookie，然而其它浏览器则允许此行为。Firefox 在 3.0.6 中修复了该漏洞，然而仍旧有许多浏览器漏洞存在，<a href="https://www.owasp.org/index.php/HTTPOnly#Browsers_Supporting_HTTPOnly" target="_blank" rel="external">complete browser support list</a> 列出了这些。</p>
<p>原文：<a href="https://www.nczonline.net/blog/2009/05/05/http-cookies-explained/" target="_blank" rel="external">HTTP cookies explained</a><br>中文出处：<a href="http://bubkoo.com/2014/04/21/http-cookies-explained/" target="_blank" rel="external">HTTP cookies 详解</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[自定义事件]]></title>
      <url>https://zaynex.github.io/2016/10/06/%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前面试的时候被问到了自定义事件，当时没好好看，临时补救下。<br><a id="more"></a></p>
<hr>
<h2 id="什么是自定义事件"><a href="#什么是自定义事件" class="headerlink" title="什么是自定义事件"></a>什么是自定义事件</h2><p>事件是一种叫做<code>观察者</code>的设计模式，这是一种创建松散耦合代码的技术。对象可以发布事件，其他对象可以观察该对象，根据原对象不同状况作出相应的事件响应。事件是与DOM交互最常见的方式（比如鼠标悬停，按键等），但它们也可以位于非DOM中，这就需要借助自定义事件来实现。自定义事件背后的理念就是创建一个管理事件的对象，让其他对象监听那些事件。</p>
<h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>观察者模式主要由主体和观察者组成。主题负责发布事件，同时观察者通过订阅这些事件来观察主体。<br>该模式的关键概念是主体并不知道观察者的任何事情，但观察者知道主体并能注册事件的回调函数。</p>
<p>在涉及DOM时，DOM元素便是主体，你的事件处理代码便是观察者。</p>
<p>再举个例子：<br>比如我来公司面试的时候，完事之后每个面试官都会对我说：“请留下你的联系方式， 有消息我们会通知你”。 在这里“我”是订阅者， 面试官是发布者。所以我不用每天或者每小时都去询问面试结果，通讯的主动权掌握在了面试官手上。而我只需要提供一个联系方式。</p>
<h2 id="还是看代码吧"><a href="#还是看代码吧" class="headerlink" title="还是看代码吧"></a>还是看代码吧</h2><p>我们来创建一个自定义事件的通用类型（来自《高程三》）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">function EventTarget()&#123;</div><div class="line">	//用于存储事件处理程序</div><div class="line">	this.handlers = &#123;&#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">EventTarget.prototype = &#123;</div><div class="line">	constructor: EventTarget,</div><div class="line"></div><div class="line">	//注册给定类型事件处理程序</div><div class="line">	addHandler: function(type, handler)&#123;</div><div class="line">		//如果类型不存在，则创建一个数组，将该类型的事件存进去（等待发射）</div><div class="line">		if(typeof this.handlers[type] == &quot;undefined&quot;)&#123;</div><div class="line">			this.handlers[type] = []; </div><div class="line">		&#125;</div><div class="line">		this.handlers[type].push(handler);</div><div class="line">	&#125;,</div><div class="line"></div><div class="line">	//触发一个事件</div><div class="line">	fire: function(event) &#123;</div><div class="line">		if(!event.target) &#123;</div><div class="line">			event.target = this;</div><div class="line">		&#125;</div><div class="line">		if(this.handlers[event.type] instanceof Array)&#123;</div><div class="line">			var handlers = this.handlers[event.type];</div><div class="line">			for(var i =0, len = handlers.length; i &lt; len; i++) &#123;</div><div class="line">				//发射事件（执行事件处理程序）</div><div class="line">				handlers[i](event);//因为是自定义类型事件，传入参数后你就可以自己决定额外的信息</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;,</div><div class="line"></div><div class="line">	//注销某个事件类型的事件处理程序</div><div class="line">	removeHandler: function(type, handler)&#123;</div><div class="line">		if(this.handlers[type] instanceof Array) &#123;</div><div class="line">			var handlers = this.handlers[type];</div><div class="line">			for(var i = 0,len=handlers.length; i &lt; len; i++) &#123;</div><div class="line">				if(handlers[i] === handler) &#123;</div><div class="line">					break;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			handlers.splice(i, 1);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line">function handleMessage(event)&#123;</div><div class="line">	alert(&quot;message received:&quot; + event.message);</div><div class="line">&#125;</div><div class="line"></div><div class="line">function handleMessage1(event)&#123;</div><div class="line">	alert(&quot;message1 received&quot; + event.message);</div><div class="line">&#125;</div><div class="line">//创建新对象</div><div class="line">var target = new EventTarget();</div><div class="line">//添加事件处理程序</div><div class="line">target.addHandler(&quot;message&quot;, handleMessage);</div><div class="line">target.addHandler(&quot;message&quot;, handleMessage1);</div><div class="line"></div><div class="line">//同一类型的事件被触发</div><div class="line">target.fire(&#123;type:&quot;message&quot;, message: &quot;helloworld!&quot;&#125;);</div><div class="line">//message received:handleMessage</div><div class="line">//message1 received:handleMessage1</div></pre></td></tr></table></figure>
<p>由于这种功能是封装在自定义类型中，其他对象也可以继承EventTarget并获得这个行为。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">function Person(name, age)&#123;</div><div class="line">	EventTarget.call(this);</div><div class="line">	this.name = name;</div><div class="line">	this.age = age;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function inheritPrototype (subType, SuperType) &#123;   // (子类型，超类型)</div><div class="line">    var prototype = Object.create(SuperType.prototype);</div><div class="line">    prototype.constructor = subType;</div><div class="line">    subType.prototype = prototype;</div><div class="line">&#125;</div><div class="line">//Person采用寄生组合方式继承 EventTarget</div><div class="line">inheritPrototype(Person, EventTarget);</div><div class="line"></div><div class="line">Person.prototype.say = function(message)&#123;</div><div class="line">	//调用该方法并且是不公开调用的</div><div class="line">	this.fire(&#123;type:&quot;message&quot;, message: message&#125;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">function handlemess(event)&#123;</div><div class="line">	alert(event.target.name + &quot; says: &quot; + event.message);</div><div class="line">&#125;</div><div class="line">//创建新的对象</div><div class="line">var person = new Person(&quot;Zaynex&quot;, 23);</div><div class="line">person.addHandler(&quot;message&quot;, handlemess);</div><div class="line">person.say(&quot;hi here&quot;);</div><div class="line">//Zaynex says: hi here</div></pre></td></tr></table></figure></p>
<p>当代码存在多个部分在特定时刻相互交互的情况下自定义事件就非常有用了。使用自定义事件，有助于解耦相关对象，保持功能的隔绝。</p>
<p>接下来就是我们的JS的拖拽代码了，也比较简单。然后利用自定义事件监听事件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&quot;myDiv&quot; class=&quot;draggable&quot; style=&quot;position:absolute&quot;&gt;&lt;/div&gt;</div><div class="line">&lt;div id=&quot;status&quot;&gt;&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">var DragDrop = function()&#123;</div><div class="line">	var dragging = null;</div><div class="line">		diffX = 0;</div><div class="line">		diffY = 0;</div><div class="line">	function handlerEvent(event) &#123;</div><div class="line">               //这里的EventUtil是封装了事件对象的几个函数</div><div class="line">		event = EventUtil.getEvent(event);</div><div class="line">		var target = EventUtil.getTarget(event);</div><div class="line"></div><div class="line">		switch(event.type)&#123;</div><div class="line">			case &quot;mousedown&quot;:</div><div class="line">				if(target.className.indexOf(&quot;draggable&quot;) &gt; -1) &#123;</div><div class="line">					dragging = target;</div><div class="line">					diffX = event.clientX - target.offsetLeft;</div><div class="line">					diffY = event.clientY - target.offsetTop;</div><div class="line">				&#125;</div><div class="line">				break;</div><div class="line">			case &quot;mousemove&quot;:</div><div class="line">				if(dragging !== null) &#123;</div><div class="line">					dragging.style.left = (event.clientX-diffX) + &quot;px&quot;;</div><div class="line">					dragging.style.top = (event.clientY-diffY) + &quot;px&quot;;</div><div class="line">				&#125;</div><div class="line">				break;</div><div class="line">			case &quot;mouseup&quot;:</div><div class="line">				dragging = null;</div><div class="line">				break;</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line">	return &#123;</div><div class="line">		enable: function()&#123;</div><div class="line">			EventUtil.addHandler(document, &quot;mousedown&quot;, handlerEvent);</div><div class="line">			EventUtil.addHandler(document, &quot;mouseup&quot;, handlerEvent);</div><div class="line">			EventUtil.addHandler(document, &quot;mousemove&quot;, handlerEvent);</div><div class="line">		&#125;,</div><div class="line">		disable: function()&#123;</div><div class="line">			EventUtil.removeHandler(document, &quot;mousedown&quot;, handlerEvent);</div><div class="line">			EventUtil.removeHandler(document, &quot;mouseup&quot;, handlerEvent);</div><div class="line">			EventUtil.removeHandler(document, &quot;mousemove&quot;, handlerEvent);</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line">&#125;();</div><div class="line"></div><div class="line">DragDrop.enable();</div></pre></td></tr></table></figure>
<p>我们通过添加自定义事件来获得拖拽事件交互的交互状况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">var DragDrop = function()&#123;</div><div class="line">	var dragdrop = new EventTarget(),</div><div class="line">		dragging = null,</div><div class="line">		diffX = 0,</div><div class="line">		diffY = 0;</div><div class="line"></div><div class="line"></div><div class="line">	function handlerEvent(event) &#123;</div><div class="line">		event = EventUtil.getEvent(event);</div><div class="line">		var target = EventUtil.getTarget(event);</div><div class="line"></div><div class="line">		switch(event.type)&#123;</div><div class="line">			case &quot;mousedown&quot;:</div><div class="line">				if(target.className.indexOf(&quot;draggable&quot;) &gt; -1) &#123;</div><div class="line">					dragging = target;</div><div class="line">					diffX = event.clientX - target.offsetLeft;</div><div class="line">					diffY = event.clientY - target.offsetTop;</div><div class="line">					//触发事件</div><div class="line">					dragdrop.fire(&#123;type:&quot;dragstart&quot;, target:dragging, x:event.clientX, y:event.clientY&#125;);</div><div class="line">				&#125;</div><div class="line">				break;</div><div class="line">			case &quot;mousemove&quot;:</div><div class="line">				if(dragging !== null) &#123;</div><div class="line">					dragging.style.left = (event.clientX-diffX) + &quot;px&quot;;</div><div class="line">					dragging.style.top = (event.clientY-diffY) + &quot;px&quot;;</div><div class="line">					//触发事件</div><div class="line">					dragdrop.fire(&#123;type:&quot;drag&quot;, target:dragging, x:event.clientX, y:event.clientY&#125;);</div><div class="line">				&#125;</div><div class="line">				break;</div><div class="line">			case &quot;mouseup&quot;:</div><div class="line">				//触发事件</div><div class="line">				dragdrop.fire(&#123;type:&quot;dragend&quot;, target:dragging, x:event.clientX, y:event.clientY&#125;);</div><div class="line">				dragging = null;</div><div class="line">				break;</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line">	dragdrop.enable = function()&#123;</div><div class="line">		EventUtil.addHandler(document, &quot;mousedown&quot;, handlerEvent);</div><div class="line">		EventUtil.addHandler(document, &quot;mouseup&quot;, handlerEvent);</div><div class="line">		EventUtil.addHandler(document, &quot;mousemove&quot;, handlerEvent);</div><div class="line">	&#125;,</div><div class="line">	dragdrop.disable = function()&#123;</div><div class="line">		EventUtil.removeHandler(document, &quot;mousedown&quot;, handlerEvent);</div><div class="line">		EventUtil.removeHandler(document, &quot;mouseup&quot;, handlerEvent);</div><div class="line">		EventUtil.removeHandler(document, &quot;mousemove&quot;, handlerEvent);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	return dragdrop;</div><div class="line">&#125;();</div><div class="line">DragDrop.enable();</div><div class="line"></div><div class="line">DragDrop.addHandler(&quot;dragstart&quot;, function(event)&#123;</div><div class="line">	var status = document.getElementById(&quot;status&quot;);</div><div class="line">	status.innerHTML = &quot;start dragging&quot; + event.target.id;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">DragDrop.addHandler(&quot;drag&quot;, function(event)&#123;</div><div class="line">	var status = document.getElementById(&quot;status&quot;);</div><div class="line">	status.innerHTML += &quot;&lt;br /&gt; Dragged &quot; + event.target.id + &quot; to (&quot; + event.x + &quot;,&quot; + event.y + &quot;)&quot;;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">DragDrop.addHandler(&quot;dragend&quot;, function(event)&#123;</div><div class="line">	var status = document.getElementById(&quot;status&quot;);</div><div class="line">	status.innerHTML += &quot;&lt;br /&gt; Draged &quot; + event.target.id + &quot; at (&quot; + event.x + &quot;,&quot; + event.y + &quot;)&quot;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在每个运动状态都fire(发射)一个不同类型的事件。<br>根据不同的事件类型触发不同的事件。</p>
<p>接下来看看JavaScript Patterns中对观察者模式的介绍。</p>
<p>自定义事件又称 订阅/发布模式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">var publisher = &#123;</div><div class="line">	subscribers: &#123;</div><div class="line">		any:[] //事件类型：订阅者(subscribers)</div><div class="line">	&#125;,</div><div class="line">	</div><div class="line">	//添加事件（订阅事件）</div><div class="line">	subscribe: function(fn, type) &#123;</div><div class="line">		type = type || &apos;any&apos;;</div><div class="line">		if(typeof this.subscribers[type] === &apos;undefined&apos;)&#123;</div><div class="line">			this.subscribers[type] = [];</div><div class="line">		&#125;</div><div class="line">		this.subscribers[type].push(fn);</div><div class="line">	&#125;,</div><div class="line">	//取消事件（退订）</div><div class="line">	//这里用到了一个帮助方法visitSubscribers，很容易联想到应该是提供一个遍历查找的函数，不过真正的逻辑还是交给这个帮助函数处理</div><div class="line">	unsubscribe: function(fn, type) &#123;</div><div class="line">		this.visitSubscribers(&apos;unsubscribe&apos;, fn, type);</div><div class="line">	&#125;,</div><div class="line">	</div><div class="line">	//触发事件类似于fire (发布)</div><div class="line">	//也用到了一个帮助函数</div><div class="line">	publish: function(publication, type)&#123;</div><div class="line">		this.visitSubscribers(&quot;publish&quot;, publication, type);</div><div class="line">	&#125;,</div><div class="line"></div><div class="line">	visitSubscribers: function(action, arg, type) &#123;</div><div class="line">		var pubtype = type || &apos;any&apos;,</div><div class="line">			subscribers = this.subscribers[pubtype],</div><div class="line">			i,max = subscribers.length;</div><div class="line"></div><div class="line">		for(i = 0; i &lt; max; i++) &#123;</div><div class="line">			//如果是发布事件，则遍历触发事件</div><div class="line">			if(action === &apos;publish&apos;) &#123;</div><div class="line">				subscribers[i](arg);</div><div class="line">			&#125; else &#123;</div><div class="line">			//否则，那就是退订事件了，删除对应的事件句柄</div><div class="line">				if(subscribers[i] === arg) &#123;</div><div class="line">					subscribers.splice(i, 1);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>接下来我们再造一个发布者函数，它接受一个对象作为参数，通过上述通用发布者的方法复制到该对象中，将其转换为发布者。<br>在《高程三》中是通过继承来实现的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">function makePublisher(o) &#123;</div><div class="line">	var i;</div><div class="line">	//把publisher所有的实例方法都赋给这个makePublisher传入的对象</div><div class="line">	for(i in publisher) &#123;</div><div class="line">		if(publisher.hasOwnProperty(i) &amp;&amp; typeof publisher[i] === &apos;function&apos;) &#123;</div><div class="line">			o[i] = publisher[i];</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	o.subscribers = &#123;any:[]&#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//我们来实现paper对象，它能做的就是发布日报和月刊。</div><div class="line">var paper = &#123;</div><div class="line">	daily: function()&#123;</div><div class="line">		this.publish(&quot;big news Today&quot;);</div><div class="line">	&#125;,</div><div class="line">	monthly: function()&#123;</div><div class="line">		this.publish(&quot;interesting analysis&quot;, &quot;monthly&quot;);</div><div class="line">	&#125;,</div><div class="line">&#125;;</div><div class="line"></div><div class="line">//利用makePublisher函数构造一个发布者</div><div class="line">//从此它就有了订阅发布退订的方法了</div><div class="line">makePublisher(paper);</div><div class="line"></div><div class="line">//已经有了发布者，还缺一个订阅者，给它添加两个方法</div><div class="line">var joe = &#123;</div><div class="line">	drinkCoffee: function(paper)&#123;</div><div class="line">		console.log(&quot;Just read &quot; + paper );</div><div class="line">	&#125;,</div><div class="line">	sundayPreNap: function(monthly) &#123;</div><div class="line">		console.log(&apos;About to fall asleep reading this &apos; + monthly);</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">//paper注册joe，添加相应的订阅方式（添加事件处理程序）</div><div class="line">paper.subscribe(joe.drinkCoffee);//第二个参数没有设置事件类型，默认为&quot;any&quot;</div><div class="line">//paper.subscribe(joe.drinkCoffee, &quot;any&quot;);</div><div class="line">paper.subscribe(joe.sundayPreNap, &quot;monthly&quot;);//第二个参数设置了&quot;monthly&quot;,事件类型则为&quot;monthly&quot;</div><div class="line"></div><div class="line">paper.daily();//Just read big news Today</div><div class="line">paper.monthly();//About to fall asleep reading this interesting analysis</div></pre></td></tr></table></figure>
<p>除此之外，也可以让joe成为一个发布者。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">makePublisher(joe);</div><div class="line"></div><div class="line">//现在joe在twitter上发布了一条消息</div><div class="line">joe.twitter = function(msg)&#123;</div><div class="line">	this.publish(msg);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">//paper(我们假设是公安部门)关注joe的动态，我们给paper一个readTwitter函数监控joe</div><div class="line">paper = function(twitter)&#123;</div><div class="line">	alert(.readTwitter&quot;Call big meeting! Someone &quot; + twitter);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">//joe注册了paper.readTwitter事件</div><div class="line">joe.subscribe(paper.readTwitter);</div><div class="line"></div><div class="line">//joe发了twitter</div><div class="line">joe.twitter(&quot;hated the paper today&quot;);</div><div class="line"></div><div class="line">//Call big meeting! Someone hated the paper  today</div></pre></td></tr></table></figure>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>以上便是自定义事件(观察者模式),隐约感觉到了自定义事件的强大之处，希望以后再开发学习的过程中能用上这种优秀的模式吧。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[line-height真的垂直居中的吗？]]></title>
      <url>https://zaynex.github.io/2016/10/06/line-height%E7%9C%9F%E7%9A%84%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E7%9A%84%E5%90%97%EF%BC%9F/</url>
      <content type="html"><![CDATA[<p>内容区域 content area<br>内联盒子 span a em  如果里面只有文字  匿名内联盒子<br>行框盒子 如果有换行，就是两行<br>包含盒子 </p><p></p>标签<br><a id="more"></a><br>高度是由 line-height 决定的。<br>那默认line-height是多少呢？<br>line-height定义为两个基线的距离，一行文字如何知道行高呢？<p></p>
<p>行高只是幕后黑手，高度的表现不是行高，而是内容区域和行间距。</p>
<p>内容区域高度（context-area） + 行间距(vertical spacing) = 行高(line-height)</p>
<p>内容区域高度只与字号和字体有关，</p>
<p>在simsun字体下，内容区域高度等于文字的大小值。</p>
<p>font-size:240px;<br>line-height: 360px;<br>行间距： 360px - 240px;</p>
<p>多行文本高度就是单行本文高度的累加<br>若有inlin-block图片，则行高怎么分布？</p>
<p>line-height:normal 跟用户的浏览器和字体有关<br>在微软雅黑字体下，chrome浏览器 line-heigth:normal为 1.32左右<br>在宋体下，chrome浏览器下，   1.14</p>
<p>line-height:1.5<br>根据文字的font-size大小计算</p>
<p>line-height:150%;<br>相对于设置了该 inline-height属性的元素的font-size大小计算。</p>
<p>实现图片和多行文字垂直居中</p>
<p>vertical-align:middle; 基线向上</p>
<p>盒子<br>line-height:300px;<br>text-center:center;</p>
<p>图片<br>vertical-align:middle</p>
<p>多行文本垂直居中</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[每日学习小结]]></title>
      <url>https://zaynex.github.io/2016/09/29/%E5%86%8D%E6%9D%A5%E5%87%A0%E6%9C%AC%E4%B9%A6/</url>
      <content type="html"><![CDATA[<p>—–2016-10-5<br>老实说，今天学的有点轻浮。<br>不过页面总算是差不多完成了。明天完工。就开始整理总结吧啊。先把用到的知识点过一遍。再总结百度电话面试里面的内容。<br>算法不能落下啊！<br>今天的收获</p>
<ul>
<li>对line-height这个奇葩有了新的认识。要点，居中 行内块级元素 </li>
<li>晨跑</li>
<li>一遍文章<br>—–2016-10-4<br>按需求来学习吧。不要动太多的歪脑筋了。<br>JS为主。<br>今天把cookie和ajax搞了大半。明天争取都完成了。<br>关于算法</li>
<li>freecodecamp</li>
<li>牛客网上还有JS的算法题</li>
<li>java以后再去学吧，再说要学也是先学node。</li>
</ul>
<p>—–2016-10-3<br>转眼都10月份了。<br>今天没什么学习状态。感觉自己要学得太多，同时也没有好好去学。<br>基础还不够，看来还得重新好好规划下。</p>
<ul>
<li>完成前端的微专业项目（看累了就看会闲书或者是敲源码）</li>
<li>晚上研究算法</li>
<li>一定要做总结啊！<br>当你不知道是否正确的时候，不要犹豫，做就是了。</li>
</ul>
<p>—-2016-09-29<br>今天用node建了一个博客，比之前看视频什么的快多了。以后确实也要减少看视频，尽量看书或者是文档。因为其实效果还真的不如文档好。然后复习了下算法第一小节。很少看到那些大牛学一门新东西的时候是通过视频来的，那都是入门干的事情了。<br>明天的任务</p>
<ul>
<li>算法第二小节</li>
<li>完善博客并整理文章</li>
<li>projavascript看起来<br>要达成的目的：<br>持续学习数据结构与算法<br>深入学习javascript<br>博客就当作是自己的项目吧</li>
</ul>
<p>—–2016-09-27</p>
<ol>
<li>gulp</li>
<li>jade<br><a href="https://segmentfault.com/a/1190000000357534#articleHeader22" target="_blank" rel="external">https://segmentfault.com/a/1190000000357534#articleHeader22</a><br><a href="http://www.html2jade.org/" target="_blank" rel="external">http://www.html2jade.org/</a></li>
<li>express<br><a href="http://www.expressjs.com.cn/guide/routing.html" target="_blank" rel="external">http://www.expressjs.com.cn/guide/routing.html</a></li>
<li>git<br><a href="http://www.backlogtool.com/git-guide/cn/intro/intro2_4.html" target="_blank" rel="external">http://www.backlogtool.com/git-guide/cn/intro/intro2_4.html</a></li>
</ol>
<p>今天没有看算法也是因为被工具给卡死了，老的是视频太坑，还不如自己看官方文档。<br>这样吧，明天看到下午的时候适当注意下时间，晚上再接着看算法。千万要坚持，两个月了算法还没什么动静。<br>把freecodecamp的算法题目都做一遍，找找感觉。而且都是简单的，重要的是自己去摸索。</p>
<p>—-2016-09-26<br>百度电面<br>—-2016-09-25<br>转眼都3天了。<br>23号跟魂丢了似的，完全没状态，静不下心看书。<br>24号还是有点乱。感觉自己要静下心来去深入学习node。<br>最后再定一下路线：</p>
<ul>
<li>慕课网（先把第一期过一遍，知道express是个什么鬼）<br>静不下心看书没关系，等你代码也看不懂的时候就会看书了！</li>
<li>node.js实战</li>
<li>node.js学习指南</li>
<li>ES6<br>感觉自己node真正入门了，再去买《深入浅出Node》吧。<br>然后学习undersroce.js</li>
</ul>
<p>—- 2016-09-22<br>今天跟着视频学的东西应该也不算少。只是自己还没有好好得整理。<br>下午的时候有些犯困，还是要记得睡午觉，不要担心没时间，不然下午会犯困。提高效率更重要。<br>关于算法，还是挺蛋疼的。搞了半天环境，运行起来不干脆。最后还是决定看算法竞赛经典入门了。本来C语言就不咋样，正好这本是结合C入门开始讲的。这样会快一些。要不然太慢了。明天去图书馆把算法竞赛经典入门给借来，再把算法导论给借来。<br>明天把接下来遗留下来未补充的知识点好好补充下。另外，再忍忍，把精通javascript看一下。<br>如果实在感觉无趣的话，可以看会单页Web应用。接下来就是利用express和mongoDB来开发后台了。<br>再看视频前，可以把先node.js实战大概过一遍。不过开发整站的前提是先把node.js基础的一些东西给搞定了。笔记还是要有的。<br>网上有很多数据结构视频都是C的，所以啊，C是注定逃不掉了。反正迟早要学，为什么不趁早？越是理解底层对以后帮助越大。切记。</p>
<p>—- 2016-09-21 23:35:34<br>谈谈今天的收获吧。<br>今天算是把开题报告给水过去了。<br>不过看书撸代码还是不太好，自己没有仔细得经过思考，其实一段代码里能体现的知识也是有很多的。如果自己感觉还是看不太懂的话，就应该停下来好好体会逻辑。</p>
<p> node.js 的书都比较旧了，但是不变的思想，所以还是要注重思考，体会 node.js 的核心。<br> 今天算是跟着慕课网学了小爬虫，也算长姿势了。当然，还把算法给买了，既然自己还有时间好好看书，那为什么不抓紧时间利用好这段时间呢？当然，今天也去健身了，好样的，不过感觉自己菜了好多。狂瘦8斤啊！</p>
<p> 明日计划</p>
<p> 跟着慕课网把第二期看完，再看七天入门node.js。如果是下午时间还有余的话，再看会 projavascript 把设计模式和 MVC 这几章撸完。加油！</p>
<p>晚上：晚上的时间就都留给算法和整理白天所学吧！<br>从第一章看起！</p>
<p>—- 2016-09-20 23:38:34<br>既然还有那么多书要看，就不要太着急了。要去就去大公司实习，去不了就留下来多看几本书，也不亏。</p>
<p>平时应该在抓紧的项目<br>node.js相关</p>
<ul>
<li>node.js实战，看完之后再看node.js学习指南</li>
<li>node.js的慕课网视频 </li>
<li>node.js的聊天室深入改造</li>
</ul>
<p>javascript</p>
<ul>
<li>javascript DOM高级程序设计</li>
<li>精通javascript开发</li>
<li>web单页应用</li>
</ul>
<p>先把精通js这本的设计模式相关给看了，再去看javascript</p>
<p>计算机基础</p>
<ul>
<li>算法第四版</li>
<li>c语言</li>
</ul>
<p>linux操作系统</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[javascript精要摘录]]></title>
      <url>https://zaynex.github.io/2016/09/29/%E7%B2%BE%E9%80%9Ajavascript%E6%91%98%E5%BD%95/</url>
      <content type="html"><![CDATA[<p><code>new</code>做了什么?<br><a id="more"></a><br>1.创建一个空对象并且this变量引用了该对象，同时继承了该函数的原型。<br>2.属性和方法被加入到this引用的对象中。<br>3.新创建的对象由this引用，并且最后都隐式返回this。</p>
<p>var Person = function(name){<br>    //使用对象字面量创建一个新对象<br>    //var this = {};</p>
<pre><code>this.name = name;
this.say = function(){
    return &quot;I am &quot; + this.name;
}
//return this;
</code></pre><p>}</p>
<p>而 this这新对象实际上并不为空，因为它已经错 Person的原型中继承了许多成员。</p>
<p>//var this = Object.create(Person.prototype);</p>
<p>用new操作符创建对象时，构造函数总返回一个对象，默认情况下返回this所引用的对象。<br>如果在构造函数中并不向this添加任何属性，将返回“空”对象（空指的是除了从构造函数的原型中所继承的成员之外）</p>
<h3 id="构造函数返回值"><a href="#构造函数返回值" class="headerlink" title="构造函数返回值"></a>构造函数返回值</h3><p>构造函数隐形返回this。但我们可以根据需要返回任意对象。</p>
<p>var Objectmaker = function(){<br>    //这里的name属性会被忽略<br>    //因为构造函数决定返回另一个对象<br>    this.name = “This is it “;</p>
<pre><code>var that = {};
that.name = &quot;And that&apos;s that&quot;;
return that;
</code></pre><p>};</p>
<p>var o =new Objectmaker();<br>console.log(o.name);//And that’s that</p>
<p>function Waffle(){<br>    this.tastes = “yummy”;<br>}<br>var good_morning = new Waffle();<br>console.log(good_morning.tastes);</p>
<p>var good_morning = Waffle();<br>console.log(window.tastes);</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[git入门]]></title>
      <url>https://zaynex.github.io/2016/09/28/git%E5%85%A5%E9%97%A8-0/</url>
      <content type="html"><![CDATA[<p>以前觉得git很麻烦，认真看了之后发现常用的也就那些，而且很实用。<br><a id="more"></a></p>
<h3 id="从本地建立仓库提交到仓库"><a href="#从本地建立仓库提交到仓库" class="headerlink" title="从本地建立仓库提交到仓库"></a>从本地建立仓库提交到仓库</h3><ul>
<li>git init<br>本地建立仓库。会有<code>.git</code>文件夹，windows下一般不可见。也是防止用户修改</li>
<li><p>git add<br>添加文件到暂存区</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git add demo.txt;//单个文件</div><div class="line">git add . // .表示所有文件</div></pre></td></tr></table></figure>
</li>
<li><p>git commit<br>把文件提交到仓库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git commit -m &quot;备注&quot;</div></pre></td></tr></table></figure>
</li>
<li><p>git status<br>查看文件提交状况，如果你修改了文件，会有相应的详情显示</p>
</li>
<li><p>git diff<br>查看本次提交的修改之处</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git diff demo.txt</div></pre></td></tr></table></figure>
</li>
</ul>
<p>修改后如何重新提交呢？<br>还是原来的步骤</p>
<ul>
<li>git add demo.txt</li>
<li>git commit -m “加备注，修改了啥，好让人知道”</li>
</ul>
<p>###　版本回退</p>
<ul>
<li><p>git log<br>查看版本提交的记录日志，会显示每次提交的版本号（唯一）</p>
</li>
<li><p>git reset –hard HEAD^<br>回到上一个提交的版本，如果是<code>HEAD^^</code>,回到上上个版本。</p>
</li>
</ul>
<p>额，但是你又想回到刚才最新的版本怎么办？</p>
<p>没关系</p>
<ul>
<li><p>git reflog<br>列出了所有你操作过的版本号<br>利用 commit -m 后面的文字提示回到你想要的版本。前面有一组数字+字母的组合，就是唯一的版本号标识。</p>
</li>
<li><p>git reset</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git reset --hard 33jdjf0</div></pre></td></tr></table></figure>
</li>
</ul>
<p>我就随便打一下，后面的版本号就是你查看<code>reflog</code>时的版本号</p>
<h3 id="工作区和暂存区的区别"><a href="#工作区和暂存区的区别" class="headerlink" title="工作区和暂存区的区别"></a>工作区和暂存区的区别</h3><p>工作区：你在电脑上看到的所有目录文件（.git隐藏目录除外）<br>理解缓存区，我们需要先借助版本库，版本库就是<code>.git</code>目录。里面有一个缓存区的东东。Git为我们自动创建了一个<code>master</code>分支，以及指向master的一个指针<code>HEAD</code>。</p>
<p>我们在使用<code>git add</code>的时候是把文件加到缓存区去了。<br>接下来<code>git commit</code>才是把暂存区的内容提交到当前分支上。</p>
<h3 id="删除撤销"><a href="#删除撤销" class="headerlink" title="删除撤销"></a>删除撤销</h3><p>一种办法当然是手动修改，然后add 再 commit。<br>但是你想改回原样就可以回到上一个版本，用<code>git reset --hard HRAD</code>方法，介绍过了。<br>另外一种就是<code>git checkout  -- demo.txt</code><br>它的意思就是把demo.txt在缓存区里的内容全都撤销。这里要注意：</p>
<ol>
<li>如果<code>demo.txt</code>修改后，还没有放到缓存区。 使用这种方式撤销就可以回到和版本库一模一样的状态。</li>
<li>如果已经<code>add</code>到缓存区，（后来又做了修改，但还没提交缓存区，就是没<code>add</code>），那么撤销改修就回到添加缓存区后的状态了。</li>
</ol>
<ul>
<li>git checkout<br>如果后面没有<code>--</code>那么就会创建一个分支，要小心。</li>
</ul>
<h4 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h4><p>一般情况下，删除文件可以直接在文件目录中把文件给删了，也可以在命令行中 <code>rm demo.txt</code>删掉文件。<br>删完了之后再<code>commit</code>一下。</p>
<p>但是如果没有<code>commit</code>，手贱误删了，怎么恢复呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout -- demo.txt</div></pre></td></tr></table></figure></p>
<p>恢复该文件。</p>
<h3 id="上传到远程仓库吧"><a href="#上传到远程仓库吧" class="headerlink" title="上传到远程仓库吧!"></a>上传到远程仓库吧!</h3><p>在github上新建一个repo。<br>复制它的https地址<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git remote add origin https://github.com/zaynex/demo.git</div><div class="line">git push -u origin master</div></pre></td></tr></table></figure></p>
<p>把本地库的内容推送到远程，使用 git push命令，实际上是把当前分支master推送到远程。</p>
<p>由于远程库是空的，我们第一次推送master分支时，加上了 –u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。推送成功后，可以立刻在github页面中看到远程库的内容已经和本地一模一样了。</p>
<p>从现在起，只要本地作了提交，就可以通过如下命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git push origin master</div></pre></td></tr></table></figure></p>
<h3 id="从远程clone一个项目？"><a href="#从远程clone一个项目？" class="headerlink" title="从远程clone一个项目？"></a>从远程clone一个项目？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git clone https://github.com/zaynex/demo</div></pre></td></tr></table></figure>
<h3 id="创建合并分支"><a href="#创建合并分支" class="headerlink" title="创建合并分支"></a>创建合并分支</h3><p>前面有说过，<br><code>git checkout</code>可以创建分支。<br>我们就来创建一个分支。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout -b dev</div></pre></td></tr></table></figure>
<p>这句指令的意识其实是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git branch dev //新建一个分支</div><div class="line">git checkout dev // 切换到该分支</div></pre></td></tr></table></figure>
<p>使用<code>git branch</code>就可以看到有两个分支<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">master</div><div class="line">*dev</div></pre></td></tr></table></figure></p>
<p><code>*</code>表示你当前在用的分支</p>
<p>切换到分支的好处就是，你可以在分支上随意修改，完善后再提交到稳定的master分支。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git checkout master</div><div class="line">git merge dev</div></pre></td></tr></table></figure>
<p><code>git merge</code>命令用于合并指定分支到当前分支上，合并后，再查看<code>demo.txt</code>内容，可以看到，和dev分支最新提交的是完全一样的。</p>
<p>注意到上面的<code>Fast-forward</code>信息，Git告诉我们，这次合并是“快进模式”，也就是直接把<code>master</code>指向<code>dev</code>的当前提交，所以合并速度非常快。</p>
<p>合并完成后，我们可以接着删除<code>dev</code>分支了，操作如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git branch -d dev</div></pre></td></tr></table></figure></p>
<p>总结如下：<br>查看分支：git branch</p>
<p>创建分支：git branch name</p>
<p>切换分支：git checkout name</p>
<p>创建+切换分支：git checkout –b name</p>
<p>合并某分支到当前分支：git merge name</p>
<p>删除分支：git branch –d name</p>
<h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout -b fenzhi1//新建一个分支</div></pre></td></tr></table></figure>
<p>我在这个分支上修改了<code>demo.txt</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git add demo.txt</div><div class="line">git commit -m &quot;啊，我添加了123456&quot;</div></pre></td></tr></table></figure>
<p>注意，刚才的操作都是在分支上改的。</p>
<p>现在，我们切换到master分支。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout master</div></pre></td></tr></table></figure></p>
<p>然后我们再修改 <code>demo.txt</code>。<br>这就好像有两个人操作了这个文件。</p>
<p>然后再</p>
<ul>
<li>git add</li>
<li>git commit -m “在master分支上修改了”</li>
<li>git merge fenzhi1</li>
</ul>
<p>这个时候，会说这里有个冲突。提交失败。</p>
<ul>
<li><p>git status<br>我们查看下状态，发现确实文件被修改了两次。</p>
</li>
<li><p>cat demo.txt<br>查看冲突内容<br>Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，其中&lt;&lt;<head是指主分支修改的内容，>&gt;&gt;&gt;&gt;fenzhi1 是指fenzhi1上修改的内容，我们可以修改下如下后保存：</head是指主分支修改的内容，></p>
</li>
</ul>
<p>在文件中根据相应的提示修改最终版本的代码。<br>完成后再</p>
<ul>
<li>git add</li>
<li>git commit</li>
</ul>
<p>你可以</p>
<ul>
<li>git log<br>查看状态</li>
</ul>
<h3 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h3><p>通常合并分支时，git一般使用<code>Fast forward</code>模式，在这种模式下，删除分支后，会丢掉分支信息，现在我们来使用带参数 <code>–no-ff</code>来禁用<code>Fast forward</code>模式。</p>
<ol>
<li>创建一个dev分支。</li>
<li>修改demo.txt内容。</li>
<li>添加到暂存区。</li>
<li>切换回主分支(master)。</li>
<li>合并dev分支，使用命令 git merge –no-ff  -m “注释” dev</li>
<li>查看历史记录</li>
</ol>
<ul>
<li>git checkout -b dev</li>
<li>git add demo.txt</li>
<li>git commit -m “add merge”</li>
<li>git checkout master</li>
<li>git merge –no-ff -m “merge with no-ff” dev //合并分支，并且设置禁止模式</li>
<li>git branch -d dev //删除分支</li>
<li>git branch //新分支已经被删除了，查看下状态</li>
<li>git log –graph –pretty=oneline – abbrev-commit // 找到历史分支，我们可以找到被删除的历史分支</li>
</ul>
<h3 id="bug分支"><a href="#bug分支" class="headerlink" title="bug分支"></a>bug分支</h3><p>一般而言，我们会创建分支，在分支上干活，干好了再提交到稳定的master分支。<br>但现在的状况是，我们还在开发分支，但是发现master分支上有bug要修复。现在我们就来搞定它！</p>
<p>我们要临时再建一个分支，就当作的是 404bug分支吧。</p>
<p>此时我们在分支状态下，所以需要先把分支隐藏掉。</p>
<ul>
<li><p>git stash</p>
</li>
<li><p>git status<br>查看状态，发现分支是干净的</p>
</li>
<li><p>git checkout -b issue-404<br>我们新建了bug分支。</p>
</li>
<li><p>git add demo.txt<br>把修改好后的代码提交到上去</p>
</li>
<li><p>git commit -m “404bug修复”</p>
</li>
<li><p>git checkout master<br>切换到master分支</p>
</li>
<li><p>git merge –no-ff -m ‘merge bug fix 404’ issue-404<br>合并修复bug分支到master分支</p>
</li>
<li><p>git branch -d issue-404<br>删除bug分支</p>
</li>
</ul>
<p>ok,master上的bug修复了！<br>我们再回到dev分支</p>
<ul>
<li><p>git checkout dev<br>再完成原先未完成的活</p>
</li>
<li><p>git status<br>我们发现分支目前是干净的，咱们之前搞的代码都去哪了？</p>
</li>
<li><p>git stash list<br>工作区还在，只是Git把stash内容存在某个地方了，但是需要恢复一下，可以使用如下2个方法。<br>方法一：</p>
</li>
<li>git stash apply<br>这种方法的坏处就是stash里面的内容还在，要用<code>git stash drop</code>删除下<br>方法二：</li>
<li>git stash pop<br>回复的同时也把stash的内容也删除了。</li>
</ul>
<h3 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h3><p>当你从远程库克隆时候，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且远程库的默认名称是origin。</p>
<ol>
<li>要查看远程库的信息 使用 git remote</li>
<li>要查看远程库的详细信息 使用 git remote –v</li>
</ol>
<h4 id="推送分支"><a href="#推送分支" class="headerlink" title="推送分支"></a>推送分支</h4><p>推送分支就是把该分支上所有本地提交到远程库中，推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：</p>
<ul>
<li>git push origin master<br>可以把本地的内容更新到远程库中。<br>但是如果要推送到其他分支，比如dev分支，我们还是用命令</li>
<li>git push origin dev</li>
</ul>
<p>那么一般情况下，那些分支要推送呢？</p>
<ol>
<li>master分支是主分支，因此要时刻与远程同步。</li>
<li>一些修复bug分支不需要推送到远程去，可以先合并到主分支上，然后把主分支master推送到远程去。</li>
</ol>
<h4 id="抓取分支"><a href="#抓取分支" class="headerlink" title="抓取分支"></a>抓取分支</h4><p>现在我们可以模拟另外一个同事，可以在另一台电脑上（注意要把SSHkey添加到github上）或者同一台电脑上另外一个目录克隆，新建一个目录名字叫testgit2。</p>
<p>现在testgit2下clone 远程库到本地</p>
<ul>
<li>git clone <a href="https://github.com/zaynex/testgit" target="_blank" rel="external">https://github.com/zaynex/testgit</a></li>
</ul>
<p>现在小伙伴需要在dev分支上做开发，就必须把远程的 origin的dev分支到本地来，于是可以使用命令创建本地dev分支。</p>
<ul>
<li><p>git checkout -b dev origin/dev<br>创建远程origin的dev分支到本地<br>修改dev分支的内容</p>
</li>
<li><p>git add demo.txt</p>
</li>
<li>git commit -m “dev分支内容修改”</li>
<li>git push origin dev<br>把现在的dev分支推送到远程库</li>
</ul>
<p>而我也在自己的dev分支上修改了。</p>
<ul>
<li>git add demo.txt</li>
<li>git commit -m “我在自己的dev分支上做了修改”</li>
<li>git push origin dev</li>
</ul>
<p>这里会报错，是因为你的小伙伴也在dev分支上修改了内容。</p>
<ul>
<li>git pull<br>先用git pull把最新的提交从origin/dev抓下来，然后在本地合并，解决冲突，再推送。<br>在本地修改好了文件之后再推送。<br>但是<code>git pull</code>失败了。原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接。</li>
</ul>
<p>这下<code>git pull</code>成功了。但是合并有冲突，需要手动解决，解决的方法和分支管理中的解决冲突完全一样。</p>
<ul>
<li>git add</li>
<li>git commit </li>
<li>git push origin dev<br>记得是提交到分支上</li>
</ul>
<p>因此：多人协作工作模式一般是这样的：</p>
<ol>
<li>首先，可以试图用git push origin branch-name推送自己的修改.</li>
<li>如果推送失败，则因为远程分支比你的本地更新早，需要先用git pull试图合并。</li>
<li>如果合并有冲突，则需要解决冲突，并在本地提交。再用git push origin branch-name推送。</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>适合自己的才是最好的资料。hhh！</p>
<p>mkdir：         XX (创建一个空目录 XX指目录名)</p>
<p>pwd：          显示当前目录的路径。</p>
<p>git init          把当前的目录变成可以管理的git仓库，生成隐藏.git文件。</p>
<p>git add XX       把xx文件添加到暂存区去。</p>
<p>git commit –m “XX”  提交文件 –m 后面的是注释。</p>
<p>git status        查看仓库状态</p>
<p>git diff  XX      查看XX文件修改了那些内容</p>
<p>git log          查看历史记录</p>
<p>git reset  –hard HEAD^ 或者 git reset  –hard HEAD~ 回退到上一个版本</p>
<pre><code>(如果想回退到100个版本，使用git reset –hard HEAD~100 )
</code></pre><p>cat XX         查看XX文件内容</p>
<p>git reflog       查看历史记录的版本号id</p>
<p>git checkout — XX  把XX文件在工作区的修改全部撤销。</p>
<p>git rm XX          删除XX文件</p>
<p>git remote add origin <a href="https://github.com/tugenhua0707/testgit" target="_blank" rel="external">https://github.com/tugenhua0707/testgit</a> 关联一个远程库</p>
<p>git push –u(第一次要用-u 以后不需要) origin master 把当前master分支推送到远程库</p>
<p>git clone <a href="https://github.com/tugenhua0707/testgit" target="_blank" rel="external">https://github.com/tugenhua0707/testgit</a>  从远程库中克隆</p>
<p>git checkout –b dev  创建dev分支 并切换到dev分支上</p>
<p>git branch  查看当前所有的分支</p>
<p>git checkout master 切换回master分支</p>
<p>git merge dev    在当前的分支上合并dev分支</p>
<p>git branch –d dev 删除dev分支</p>
<p>git branch name  创建分支</p>
<p>git stash 把当前的工作隐藏起来 等以后恢复现场后继续工作</p>
<p>git stash list 查看所有被隐藏的文件列表</p>
<p>git stash apply 恢复被隐藏的文件，但是内容不删除</p>
<p>git stash drop 删除文件</p>
<p>git stash pop 恢复文件的同时 也删除文件</p>
<p>git remote 查看远程库的信息</p>
<p>git remote –v 查看远程库的详细信息</p>
<p>git push origin master  Git会把master分支推送到远程库对应的远程分支上</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://blog.jobbole.com/78960/" target="_blank" rel="external">http://blog.jobbole.com/78960/</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[百度电面]]></title>
      <url>https://zaynex.github.io/2016/09/26/%E7%99%BE%E5%BA%A6%E7%94%B5%E9%9D%A2/</url>
      <content type="html"><![CDATA[<ul>
<li>unll与undefined</li>
<li>基本类型引用类型</li>
<li>call和apply</li>
<li>面向对象</li>
<li>git使用解决冲突</li>
<li>图片异步加载</li>
<li>继承是如何实现</li>
<li>设计模式</li>
<li>函数节流</li>
<li>jQuery的extend</li>
<li>http首部</li>
<li>cookie</li>
<li>跨域</li>
<li>浏览器输入地址到页面呈现发生了什么</li>
<li>npm包的要求字段</li>
<li>gulp</li>
<li>开源的框架和库用过哪些</li>
</ul>
<p>头疼，到时候再去补吧，反正知道自己是很菜就是了。<br>学得不够久，后端也刚入门。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[module.exports和exports的区别]]></title>
      <url>https://zaynex.github.io/2016/09/22/module-exports%E5%92%8Cexports%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      <content type="html"><![CDATA[<p>原文：<a href="http://www.hacksparrow.com/node-js-exports-vs-module-exports.html" target="_blank" rel="external">http://www.hacksparrow.com/node-js-exports-vs-module-exports.html</a></p>
<p>你肯定非常熟悉<code>nodejs</code>模块中的<code>exports</code>对象，你可以用它创建你的模块。例如：（假设这是rocker.js文件）<br><a id="more"></a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">exports.name = function() &#123;</div><div class="line">    console.log(&apos;My name is Lemmy Kilmister&apos;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>在另一个文件中你这样引用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var rocker = require(&apos;./rocker.js&apos;);</div><div class="line">rocker.name(); // &apos;My name is Lemmy Kilmister&apos;</div></pre></td></tr></table></figure>
<p>那到底Module.exports是什么呢？它是否合法呢？</p>
<p>其实，<code>Module.exports</code>才是真正的接口，<code>exports</code>只不过是它的一个辅助工具。最终返回给调用的是<code>Module.exports</code>而不是<code>exports</code>。</p>
<p>所有的<code>exports</code>收集到的属性和方法，都赋值给了<code>Module.exports</code>。当然，这有个前提，就是<code>Module.exports</code>本身不具备任何属性和方法。如果，<code>Module.exports</code>已经具备一些属性和方法，那么<code>exports</code>收集来的信息将被忽略。</p>
<p>修改rocker.js如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">module.exports = &apos;ROCK IT!&apos;;</div><div class="line">exports.name = function() &#123;</div><div class="line">    console.log(&apos;My name is Lemmy Kilmister&apos;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>再次引用执行rocker.js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var rocker = require(&apos;./rocker.js&apos;);</div><div class="line">rocker.name(); // TypeError: Object ROCK IT! has no method &apos;name&apos;</div></pre></td></tr></table></figure>
<p>发现报错：对象“ROCK IT!”没有name方法</p>
<p><code>rocker</code>模块忽略了<code>exports</code>收集的name方法，返回了一个字符串“ROCK IT!”。由此可知，你的模块并不一定非得返回“实例化对象”。你的模块可以是任何合法的javascript对象–<code>boolean, number, date, JSON, string, function, array</code>等等。</p>
<p>你的模块可以是任何你设置给它的东西。如果你没有显式的给<code>Module.exports</code>设置任何属性和方法，那么你的模块就是<code>exports</code>设置给Module.exports的属性。</p>
<p>下面例子中，你的模块是一个类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">module.exports = function(name, age) &#123;</div><div class="line">    this.name = name;</div><div class="line">    this.age = age;</div><div class="line">    this.about = function() &#123;</div><div class="line">        console.log(this.name +&apos; is &apos;+ this.age +&apos; years old&apos;);</div><div class="line">    &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>可以这样应用它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var Rocker = require(&apos;./rocker.js&apos;);</div><div class="line">var r = new Rocker(&apos;Ozzy&apos;, 62);</div><div class="line">r.about(); // Ozzy is 62 years old</div></pre></td></tr></table></figure>
<p>下面例子中，你的模块是一个数组：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">module.exports = [&apos;Lemmy Kilmister&apos;, &apos;Ozzy Osbourne&apos;, &apos;Ronnie James Dio&apos;, &apos;Steven Tyler&apos;, &apos;Mick Jagger&apos;];</div></pre></td></tr></table></figure>
<p>可以这样应用它：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var rocker = require(&apos;./rocker.js&apos;);</div><div class="line">console.log(&apos;Rockin in heaven: &apos; + rocker[2]); //Rockin in heaven: Ronnie James Dio</div></pre></td></tr></table></figure>
<p>现在你明白了，如果你想你的模块是一个特定的类型就用Module.exports。如果你想的模块是一个典型的“实例化对象”就用exports。</p>
<p>给Module.exports添加属性类似于给exports添加属性。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">module.exports.name = function() &#123;</div><div class="line">    console.log(&apos;My name is Lemmy Kilmister&apos;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>同样，<code>exports</code>是这样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">exports.name = function() &#123;</div><div class="line">    console.log(&apos;My name is Lemmy Kilmister&apos;);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>请注意，这两种结果并不相同。前面已经提到<code>module.exports</code>是真正的接口，<code>exports</code>只不过是它的一个全局引用。如果把<code>exports</code>设定为别的， 就打破了两者的引用关系，可是真正导出的是<code>module.exports</code>，那样<code>exports</code>就不能用了。<br>推荐使用<code>exports</code>导出，除非你打算从原来的“实例化对象”改变成一个类型。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Node.js笔记(Stream和buffer)]]></title>
      <url>https://zaynex.github.io/2016/09/22/Node-js%E7%AC%94%E8%AE%B0-Stream%E5%92%8Cbuffer/</url>
      <content type="html"><![CDATA[<h3 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h3><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var fs= require(&quot;fs&quot;);</div><div class="line">var source = fs.readFileSync(&apos;logo.png&apos;);</div><div class="line"></div><div class="line">fs.writeFileSync(&apos;new_logo.png&apos;,source);</div><div class="line">//stream是基于事件工作的</div></pre></td></tr></table></figure>
<p>上边的程序拷贝一些小文件没啥问题，但这种一次性把所有文件内容都读取到内存中后再一次性写入磁盘的方式不适合拷贝大文件，内存会爆仓。对于大文件，我们只能读一点写一点，直到完成拷贝。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var fs = require(&apos;fs&apos;);</div><div class="line">fs.createReadStream(&apos;logo.png&apos;).pipe(fs.createWriteStream(&apos;new_logo.png&apos;));</div><div class="line">// 封装函数</div><div class="line">var fs = require(&apos;fs&apos;);</div><div class="line"></div><div class="line">function copy(src, dst) &#123;</div><div class="line">    fs.createReadStream(src).pipe(fs.createWriteStream(dst));</div><div class="line">&#125;</div><div class="line"></div><div class="line">function main(argv) &#123;</div><div class="line">    copy(argv[0], argv[1]);</div><div class="line">&#125;</div><div class="line"></div><div class="line">main(process.argv.slice(2));</div></pre></td></tr></table></figure>
<p><code>process</code>是一个全局变量，可通过<code>process.argv</code>获得命令行参数。由于<code>argv[0]</code>固定等于<code>NodeJS</code>执行程序的绝对路径，<code>argv[1]</code>固定等于主模块的绝对路径，因此第一个命令行参数从<code>argv[2]</code>这个位置开始。</p>
<h3 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h3><p><code>Buffer</code>用来保存原始数据。流用来暂存和移动数据。流里面传递，是以<code>Buffer</code>来传递的。如果只用<code>Buffer</code>的话，当请求太多的时候，有可能一下子就把内存用完了。所以要利用流边读边写。</p>
<p>JS语言自身只有字符串数据类型，没有二进制数据类型，因此NodeJS提供了一个与<code>String</code>对等的全局构造函数<code>Buffer</code>来提供对二进制数据的操作。除了可以读取文件得到<code>Buffer</code>的实例外，还能够直接构造，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var bin = new Buffer([ 0x68, 0x65, 0x6c, 0x6c, 0x6f ]);</div></pre></td></tr></table></figure>
<p>Buffer与字符串类似，除了可以用.length属性得到字节长度外，还可以用[index]方式读取指定位置的字节，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bin[0]; // =&gt; 0x68;</div></pre></td></tr></table></figure>
<p>Buffer与字符串能够互相转化，例如可以使用指定编码将二进制数据转化为字符串：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var str = bin.toString(&apos;utf-8&apos;); // =&gt; &quot;hello&quot;</div></pre></td></tr></table></figure>
<p>或者反过来，将字符串转换为指定编码下的二进制数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var bin = new Buffer(&apos;hello&apos;, &apos;utf-8&apos;); // =&gt; &lt;Buffer 68 65 6c 6c 6f&gt;s</div></pre></td></tr></table></figure>
<p><code>Buffer</code>与字符串有一个重要区别。字符串是只读的，并且对字符串的任何修改得到的都是一个新字符串，原字符串保持不变。至于<code>Buffer</code>，更像是可以做指针操作的C语言数组。例如，可以用[index]方式直接修改某个位置的字节。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bin[0] = 0x48;</div></pre></td></tr></table></figure>
<p>而.slice方法也不是返回一个新的Buffer，而更像是返回了指向原Buffer中间的某个位置的指针，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[ 0x68, 0x65, 0x6c, 0x6c, 0x6f ]</div><div class="line">    ^           ^</div><div class="line">    |           |</div><div class="line">   bin     bin.slice(2)</div></pre></td></tr></table></figure>
<p>因此对.slice方法返回的Buffer的修改会作用于原Buffer，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var bin = new Buffer([ 0x68, 0x65, 0x6c, 0x6c, 0x6f ]);</div><div class="line">var sub = bin.slice(2);</div><div class="line">sub[0] = 0x65;</div><div class="line">console.log(bin); // =&gt; &lt;Buffer 68 65 65 6c 6f&gt;</div><div class="line">console.log(sub);// =&gt; &lt;Buffer 65 6c 6f&gt;</div></pre></td></tr></table></figure>
<p>也因此，如果想要拷贝一份<code>Buffer</code>，得首先创建一个新的<code>Buffer</code>，并通过<code>.copy</code>方法把原<code>Buffer</code>中的数据复制过去。这个类似于申请一块新的内存，并把已有内存中的数据复制过去。以下是一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var bin = new Buffer([ 0x68, 0x65, 0x6c, 0x6c, 0x6f ]);</div><div class="line">var dup = new Buffer(bin.length);</div><div class="line"></div><div class="line">bin.copy(dup);</div><div class="line">dup[0] = 0x48;</div><div class="line">console.log(bin); // =&gt; &lt;Buffer 68 65 6c 6c 6f&gt;</div><div class="line">console.log(dup); // =&gt; &lt;Buffer 48 65 65 6c 6f&gt;</div></pre></td></tr></table></figure>
<p>总之，Buffer将JS的数据处理能力从字符串扩展到了任意二进制数据。</p>
<h3 id="stream"><a href="#stream" class="headerlink" title="stream"></a>stream</h3><p><code>stream</code>是对buffer对象的高级封装，其操作的底层还是<code>buffer</code>对象，<code>stream</code>可以设置为可读、可写，或者即可读也可写，在nodejs中继承了<code>EventEmitter</code>接口，可以监听读入、写入的过程。具体实现有文件流，<code>httpresponse</code>等~~</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">var fs = require(&quot;fs&quot;);</div><div class="line"></div><div class="line">var readStream = fs.createReadStream(&apos;1.mp4&apos;);</div><div class="line">var writeStream = fs.createWriteStream(&apos;1-stram.mp4&apos;);</div><div class="line"></div><div class="line">readStream.on(&apos;data&apos;, function(chunk)&#123;</div><div class="line">	writeStream.write(chunk);</div><div class="line">	if(writeStream.write(chunk) === false)&#123;</div><div class="line">		//如果还在缓存区，那么就让读取速度降下来</div><div class="line">		console.log(&apos;still cached&apos;);</div><div class="line">		readStream.pause();//暂停模式</div><div class="line">	&#125;</div><div class="line">&#125;);</div><div class="line">readStream.on(&apos;end&apos;, function()&#123;</div><div class="line">	writeStream.end();</div><div class="line">&#125;);</div><div class="line"></div><div class="line">//当数据写入到目标时</div><div class="line">writeStream.on(&apos;drain&apos;, function()&#123;</div><div class="line">	console.log(&apos;data drains&apos;);</div><div class="line">	readStream.resume();//继续读取数据</div><div class="line">&#125;);</div><div class="line"></div><div class="line">//这种措施可以防止爆仓</div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[用Promise重写爬虫]]></title>
      <url>https://zaynex.github.io/2016/09/22/%E7%94%A8Promise%E9%87%8D%E5%86%99%E7%88%AC%E8%99%AB/</url>
      <content type="html"><![CDATA[<h3 id="Promise内容摘要"><a href="#Promise内容摘要" class="headerlink" title="Promise内容摘要"></a>Promise内容摘要</h3><p> Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。<br>所谓 Promise ，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise是一个对象，从它可以获取异步操作的消息。</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称Fulfilled）和Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。</li>
<li>一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从 Pending 变为 Resolved 和从 Pending 变为 Rejected 。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对 Promise 对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>无法取消 Promise ，一旦新建它就会立即执行，无法中途取消。</li>
<li>如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部。</li>
</ul>
<h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var promise = new Promise(function(resolve, reject) &#123;</div><div class="line">  // ... some code</div><div class="line"></div><div class="line">  if (/* 异步操作成功 */)&#123;</div><div class="line">    resolve(value);</div><div class="line">  &#125; else &#123;</div><div class="line">    reject(error);</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。<br>resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从Pending变为Resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从Pending变为Rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p>
<p>Promise实例生成以后，可以用then方法分别指定Resolved状态和Reject状态的回调函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">promise.then(function(value) &#123;</div><div class="line">  // success</div><div class="line">&#125;, function(error) &#123;</div><div class="line">  // failure</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为Resolved时调用，第二个回调函数是Promise对象的状态变为Reject时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。</p>
<h4 id="简单的demo"><a href="#简单的demo" class="headerlink" title="简单的demo"></a>简单的demo</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div></pre></td><td class="code"><pre><div class="line">&lt;!doctype html&gt;</div><div class="line">&lt;html lang=&quot;en&quot;&gt;</div><div class="line">&lt;head&gt;</div><div class="line">	&lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class="line">	&lt;title&gt;Promise animation&lt;/title&gt;</div><div class="line">	&lt;style&gt;</div><div class="line">		*&#123;</div><div class="line">			margin: 0;</div><div class="line">			padding: 0;</div><div class="line">		&#125;</div><div class="line">		.ball&#123;</div><div class="line">			width: 40px;</div><div class="line">			height: 40px;</div><div class="line">			border-radius: 20px;</div><div class="line">		&#125;</div><div class="line">		.ball1 &#123;</div><div class="line">			background: red;</div><div class="line">		&#125;</div><div class="line">		.ball2&#123;</div><div class="line">			background: yellow;</div><div class="line">		&#125;</div><div class="line">		.ball3&#123;</div><div class="line">			background-color: green;</div><div class="line">		&#125;</div><div class="line">	&lt;/style&gt;</div><div class="line">	&lt;script src=&quot;../node_modules/bluebird/js/browser/bluebird.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">	&lt;div class=&quot;ball ball1&quot; style=&quot;margin-left:0&quot;&gt;&lt;/div&gt;</div><div class="line">	&lt;div class=&quot;ball ball2&quot;style=&quot;margin-left:0&quot;&gt;&lt;/div&gt;</div><div class="line">	&lt;div class=&quot;ball ball3&quot;style=&quot;margin-left:0&quot;&gt;&lt;/div&gt;</div><div class="line"></div><div class="line">	&lt;script&gt;</div><div class="line">		var ball1 = document.querySelector(&apos;.ball1&apos;);</div><div class="line">		var ball2 = document.querySelector(&apos;.ball2&apos;);</div><div class="line">		var ball3 = document.querySelector(&apos;.ball3&apos;);</div><div class="line"></div><div class="line">		function animate(ball, distance, cb) &#123;	</div><div class="line">			setTimeout(function()&#123;</div><div class="line">				var marginLeft = parseInt(ball.style.marginLeft, 10);</div><div class="line"></div><div class="line">				if(marginLeft === distance) &#123;</div><div class="line">					cb &amp;&amp; cb();</div><div class="line">				&#125;else &#123;</div><div class="line">					if(marginLeft &lt; distance) &#123;</div><div class="line">						marginLeft++;</div><div class="line">			</div><div class="line">					&#125;</div><div class="line">					else &#123;</div><div class="line">						marginLeft--;</div><div class="line">					&#125;</div><div class="line">					ball.style.marginLeft = marginLeft + &quot;px&quot;;</div><div class="line">					animate(ball, distance, cb);</div><div class="line">				&#125;</div><div class="line">			&#125;, 13)</div><div class="line">		&#125;</div><div class="line">/*</div><div class="line">		animate(ball1, 100, function()&#123;</div><div class="line">			animate(ball2, 200, function()&#123;</div><div class="line">				animate(ball3, 300, function()&#123;</div><div class="line">					animate(ball3, 150, function()&#123;</div><div class="line">						animate(ball2, 150, function()&#123;</div><div class="line">							animate(ball1, 150, function()&#123;</div><div class="line">								//</div><div class="line">							&#125;)</div><div class="line">						&#125;)</div><div class="line">					&#125;)</div><div class="line">				&#125;)</div><div class="line">			&#125;)</div><div class="line">		&#125;)</div><div class="line">*/		</div><div class="line"></div><div class="line">var Promise = window.Promise;</div><div class="line">function PromiseAnimate(ball, distance) &#123;</div><div class="line">	return new Promise(function(reslove, reject)&#123;</div><div class="line">		function _animate() &#123;	</div><div class="line">			setTimeout(function()&#123;</div><div class="line">				var marginLeft = parseInt(ball.style.marginLeft, 10);</div><div class="line"></div><div class="line">				if(marginLeft === distance) &#123;</div><div class="line">					reslove &amp;&amp; reslove();</div><div class="line">				&#125;else &#123;</div><div class="line">					if(marginLeft &lt; distance) &#123;</div><div class="line">						marginLeft++;</div><div class="line">			</div><div class="line">					&#125;</div><div class="line">					else &#123;</div><div class="line">						marginLeft--;</div><div class="line">					&#125;</div><div class="line">					ball.style.marginLeft = marginLeft + &quot;px&quot;;</div><div class="line">					_animate();</div><div class="line">				&#125;</div><div class="line">			&#125;, 13)</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		_animate();</div><div class="line">	&#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">PromiseAnimate(ball1, 100)</div><div class="line">	.then(function()&#123;</div><div class="line">		return PromiseAnimate(ball2, 200)</div><div class="line">	&#125;).then(function()&#123;</div><div class="line">		return PromiseAnimate(ball3, 300)</div><div class="line">	&#125;).then(function()&#123;</div><div class="line">		return PromiseAnimate(ball3, 150)</div><div class="line">	&#125;).then(function()&#123;</div><div class="line">		return PromiseAnimate(ball2, 150)</div><div class="line">	&#125;).then(function()&#123;</div><div class="line">		return PromiseAnimate(ball1, 150)</div><div class="line">	&#125;)</div><div class="line"></div><div class="line">//链式结构</div><div class="line">	&lt;/script&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<h4 id="Promise改写爬虫"><a href="#Promise改写爬虫" class="headerlink" title="Promise改写爬虫"></a>Promise改写爬虫</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">"http"</span>);</div><div class="line"><span class="keyword">var</span> <span class="built_in">Promise</span> = <span class="built_in">require</span>(<span class="string">'bluebird'</span>);</div><div class="line"><span class="comment">//var Promise = require("bluebird");</span></div><div class="line"><span class="keyword">var</span> cheerio = <span class="built_in">require</span>(<span class="string">'cheerio'</span>);</div><div class="line">baseUrl = <span class="string">'http://www.imooc.com/learn/'</span>;</div><div class="line"><span class="keyword">var</span> videosId = [<span class="number">348</span>, <span class="number">259</span>, <span class="number">1987</span>, <span class="number">134</span>, <span class="number">75</span>];<span class="comment">//获取不同的课程</span></div><div class="line"><span class="keyword">var</span> courseData;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">filterChapters</span>(<span class="params">html</span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> $ = cheerio.load(html);</div><div class="line">	<span class="keyword">var</span> chapters = $(<span class="string">'.mod-chapters'</span>);</div><div class="line">	<span class="comment">/*</span></div><div class="line">	</div><div class="line">	courseData =&#123;</div><div class="line">		title: title,</div><div class="line">		number: number, </div><div class="line">		videos: [&#123;</div><div class="line">			chapterTitle:'',</div><div class="line">			videos:[</div><div class="line">				title:'',</div><div class="line">				id:''</div><div class="line">			]</div><div class="line">		&#125;]</div><div class="line">	&#125;</div><div class="line">	*/</div><div class="line">	<span class="keyword">var</span> title = $(<span class="string">'#page_header .path span'</span>).text();</div><div class="line">	<span class="keyword">var</span> number = <span class="built_in">parseInt</span>($($(<span class="string">'.info_num i'</span>)[<span class="number">0</span>]).text().trim(), <span class="number">10</span>);</div><div class="line">	<span class="keyword">var</span> courseData = &#123;</div><div class="line">		title: title,</div><div class="line">		number: number,</div><div class="line">		videos: []</div><div class="line">	&#125;;</div><div class="line">	courseData.title=title;</div><div class="line">	courseData.number=number;</div><div class="line"></div><div class="line">	chapters.each(<span class="function"><span class="keyword">function</span>(<span class="params">index, el</span>) </span>&#123;</div><div class="line">		<span class="keyword">var</span> chapter = $(<span class="keyword">this</span>);</div><div class="line">		<span class="keyword">var</span> chapterTitle = chapter.find(<span class="string">'strong'</span>).text();</div><div class="line">		<span class="keyword">var</span> videos = chapter.find(<span class="string">'.video'</span>).children(<span class="string">'li'</span>);<span class="comment">//获取到视频源</span></div><div class="line">		<span class="comment">//创建一个chapterData对象，</span></div><div class="line">		<span class="keyword">var</span> chapterData = &#123;</div><div class="line">			chapterTitle: chapterTitle,</div><div class="line">			videos:[]</div><div class="line">		&#125;;</div><div class="line"></div><div class="line">		videos.each(<span class="function"><span class="keyword">function</span>(<span class="params">index, el</span>) </span>&#123;</div><div class="line">			<span class="keyword">var</span> video = $(<span class="keyword">this</span>).find(<span class="string">'.J-media-item'</span>);</div><div class="line">			<span class="keyword">var</span> videoTitle = video.text();<span class="comment">//结果是由所有匹配元素包含的文本内容组合起来的文本（包括子节点的文本内容）这个方法对HTML和XML文档都有效。</span></div><div class="line">			<span class="keyword">var</span> id = video.attr(<span class="string">'href'</span>).split(<span class="string">'video/'</span>)[<span class="number">1</span>];<span class="comment">//设置或返回被选元素的属性值。split() 方法用于把一个字符串分割成字符串数组。</span></div><div class="line">			<span class="comment">//我们要取的是video后面的元素，在数组中的索引为1，["video/", "number"];取number数值</span></div><div class="line"></div><div class="line">			chapterData.videos.push(&#123;</div><div class="line">				title:videoTitle,</div><div class="line">				id:id</div><div class="line">			&#125;);</div><div class="line">		&#125;);</div><div class="line"></div><div class="line">	<span class="comment">/*[&#123;</span></div><div class="line">		chapterTitle:'',</div><div class="line">		videos:[</div><div class="line">			title:'',</div><div class="line">			id:''</div><div class="line">		]</div><div class="line">	&#125;]*/</div><div class="line">		courseData.videos.push(chapterData);</div><div class="line">	&#125;);</div><div class="line">	<span class="keyword">return</span> courseData;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">printCourseInfo</span>(<span class="params">courseData</span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">"printCourseInfo"</span>);</div><div class="line">	courseData.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">courseData</span>)</span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(courseData.number + <span class="string">"人学习"</span> + courseData.title + <span class="string">"\n"</span>);</div><div class="line">	&#125;);</div><div class="line">	courseData.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">courseData</span>)</span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(<span class="string">"###"</span> + courseData.title + <span class="string">"\n"</span>);		</div><div class="line">		courseData.videos.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</div><div class="line">			<span class="keyword">var</span> chapterTitle = item.chapterTitle;</div><div class="line">			<span class="built_in">console</span>.log(chapterTitle + <span class="string">"\n"</span>);</div><div class="line">			item.videos.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">video</span>) </span>&#123;</div><div class="line">				<span class="built_in">console</span>.log(<span class="string">' 【'</span>+video.id+<span class="string">'】 '</span>+video.title+<span class="string">'\n'</span>);</div><div class="line">			&#125;)</div><div class="line">		&#125;)</div><div class="line">	&#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPageAsync</span>(<span class="params">baseUrl</span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(<span class="string">"正在爬取"</span>);</div><div class="line">		http.get(baseUrl, <span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</div><div class="line">			<span class="keyword">var</span> html = <span class="string">""</span>;</div><div class="line">			res.on(<span class="string">'data'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</div><div class="line">				html += data;</div><div class="line">			&#125;);</div><div class="line">			res.on(<span class="string">'end'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">				resolve(html);</div><div class="line">				<span class="comment">//var courseData = filterChapters(html);</span></div><div class="line">				<span class="comment">//printCourseInfo(courseData);</span></div><div class="line">			&#125;);</div><div class="line">		&#125;).on(<span class="string">'error'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">			reject(e);</div><div class="line">			<span class="built_in">console</span>.log(<span class="string">'获取课程数据出错！'</span>);</div><div class="line">		&#125;);</div><div class="line">	&#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">var</span> fetchCourseArray = [];</div><div class="line"></div><div class="line">videosId.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">id</span>)</span>&#123;</div><div class="line">	fetchCourseArray.push(getPageAsync(baseUrl + id)); </div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">//并发爬虫过程</span></div><div class="line"><span class="built_in">Promise</span>.all(fetchCourseArray)</div><div class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">pages</span>)</span>&#123;</div><div class="line">	<span class="comment">//对多个页面进行处理</span></div><div class="line">	<span class="keyword">var</span> courseData = [];</div><div class="line">	pages.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">html</span>)</span>&#123;</div><div class="line">		<span class="keyword">var</span> courses = filterChapters(html);<span class="comment">//解析地址</span></div><div class="line">		courseData.push(courses);</div><div class="line">	&#125;);</div><div class="line">	courseData.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> a.number &lt; b.number;</div><div class="line">	&#125;);</div><div class="line">	printCourseInfo(courseData);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="Promise-参考资料"><a href="#Promise-参考资料" class="headerlink" title="Promise 参考资料"></a>Promise 参考资料</h4><p><a href="http://es6.ruanyifeng.com/?search=promise&amp;x=0&amp;y=0#docs/promise" target="_blank" rel="external">http://es6.ruanyifeng.com/?search=promise&amp;x=0&amp;y=0#docs/promise</a><br>简单整理下，用到了哪个方法再仔细去看下。感谢阮大大的开源！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[node.js新手开胃菜——利用cheerio做个小爬虫]]></title>
      <url>https://zaynex.github.io/2016/09/21/%E5%9F%BA%E4%BA%8Echeerio%E7%9A%84node-js%E7%88%AC%E8%99%AB/</url>
      <content type="html"><![CDATA[<p>这是慕课网上的一个有趣的demo，以前觉得爬虫很神奇，不过接触了之后就感觉更神奇了！<br>cheerio，你就把它当做可以跑在node.js上的jQuery吧。<br><a id="more"></a><br><a href="https://cnodejs.org/topic/5203a71844e76d216a727d2e" target="_blank" rel="external">中文版api介绍</a><br><a href="https://www.npmjs.com/package/cheerio" target="_blank" rel="external">英文版api介绍</a></p>
<p>任务要求</p>
<ul>
<li>抓取慕课网某个课程页面的课程章节</li>
<li>抓取慕课网上的课程章节内各个视频和介绍</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">var http = require(&quot;http&quot;);</div><div class="line">var url = &apos;http://www.imooc.com/learn/348&apos;;</div><div class="line">var cheerio = require(&quot;cheerio&quot;);</div><div class="line"></div><div class="line">http.get(url, function(res)&#123;</div><div class="line">	var html = &quot;&quot;;</div><div class="line">	res.on(&apos;data&apos;,function(data)&#123;</div><div class="line">		html += data;</div><div class="line">	&#125;);</div><div class="line">	res.on(&apos;end&apos;,function()&#123;</div><div class="line">		//filterChapters过滤出我们想要的数据</div><div class="line">		var courseData = filterChapters(html);</div><div class="line"></div><div class="line">		//print..打印出过滤后的数据</div><div class="line">		printCourseInfo(courseData);</div><div class="line">	&#125;);</div><div class="line">&#125;).on(&apos;error&apos;,function()&#123;</div><div class="line">	console.log(&apos;获取课程数据出错！&apos;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>下面是filterChapters封装代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">function filterChapters(html) &#123;</div><div class="line">	var $ = cheerio.load(html);</div><div class="line">	var chapters = $(&apos;.mod-chapters&apos;);</div><div class="line">	var courseData = [];</div><div class="line">	var chapter = &apos;&apos;;</div><div class="line">	var chapterTitle=&apos;&apos;;</div><div class="line">	var videos = &apos;&apos;;</div><div class="line">	var chapterData = &apos;&apos;;</div><div class="line">	var video = &apos;&apos;;</div><div class="line">	var videoTitle = &apos;&apos;;</div><div class="line">	var id = &apos;&apos;;</div><div class="line">	chapters.each(function(index, el) &#123;</div><div class="line">		chapter = $(this);</div><div class="line">		chapterTitle = chapter.find(&apos;strong&apos;).text();</div><div class="line">		videos = chapter.find(&apos;.video&apos;).children(&apos;li&apos;);//获取到视频源</div><div class="line">		//创建一个chapterData对象，</div><div class="line">		chapterData = &#123;</div><div class="line">			chapterTitle: chapterTitle,</div><div class="line">			videos:[]</div><div class="line">		&#125;;</div><div class="line"></div><div class="line">		videos.each(function(index, el) &#123;</div><div class="line">			video = $(this).find(&apos;.J-media-item&apos;);</div><div class="line">			videoTitle = video.text();//结果是由所有匹配元素包含的文本内容组合起来的文本（包括子节点的文本内容）这个方法对HTML和XML文档都有效。</div><div class="line">			id = video.attr(&apos;href&apos;).split(&apos;video/&apos;)[1];//设置或返回被选元素的属性值。split() 方法用于把一个字符串分割成字符串数组。</div><div class="line">			//我们要取的是video后面的元素，在数组中的索引为1，[&quot;video/&quot;, &quot;number&quot;];取number数值</div><div class="line"></div><div class="line">			chapterData.videos.push(&#123;</div><div class="line">				title:videoTitle,</div><div class="line">				id:id</div><div class="line">			&#125;);</div><div class="line">		&#125;);</div><div class="line"></div><div class="line">	/*[&#123;</div><div class="line">		chapterTitle:&apos;&apos;,</div><div class="line">		videos:[</div><div class="line">			title:&apos;&apos;,</div><div class="line">			id:&apos;&apos;</div><div class="line">		]</div><div class="line">	&#125;]*/</div><div class="line">		courseData.push(chapterData);</div><div class="line">	&#125;);</div><div class="line">	return courseData;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>打印出信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">function printCourseInfo(courseData)&#123;</div><div class="line">	var context = &apos;&apos;;</div><div class="line">	var chapterTitle = &apos;&apos;;</div><div class="line">	courseData.forEach(function(item)&#123;</div><div class="line">		chapterTitle = item.chapterTitle;</div><div class="line">		// console.log(chapterTitle+&apos;\n&apos;);</div><div class="line">		//先输出章节内容，章节内容输出完了，video</div><div class="line">		context += chapterTitle + &apos;\n&apos;;</div><div class="line">		item.videos.forEach(function(video)&#123;</div><div class="line">			// console.log(&apos; [&apos; + video.id + &apos;] &apos; +video.title+&apos;\n&apos;);</div><div class="line">			context += &apos; 【&apos;+video.id+&apos;】 &apos;+video.title+&apos;\n&apos;;</div><div class="line">		&#125;)</div><div class="line">	&#125;)</div><div class="line">	console.log(context);</div><div class="line">	//这里先把context保存再最后输出，提高效率</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这里的收获是对jQuery有更深刻的了解，对foreach循环也加深了理解。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[在浏览器输入网址后回车发生了什么]]></title>
      <url>https://zaynex.github.io/2016/09/21/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5%E7%BD%91%E5%9D%80%E5%90%8E%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/</url>
      <content type="html"><![CDATA[<p>1.查看DNS缓存</p>
<ul>
<li>先搜索浏览器自身的DNS缓存<br>查看浏览器的缓存记录<br><code>chrome://net-internals/#dns</code></li>
<li><p>搜索操作系统自身的NDS缓存（如果浏览器没有缓存或缓存失效）</p>
</li>
<li><p>读取本地的HOST文件</p>
</li>
</ul>
<p>2.域名解析<br>浏览器发起DNS的一个系统调用，域名解析请求</p>
<ul>
<li>宽带运营商服务器查看本身缓存</li>
<li>运营商服务器发起一个迭代DNS解析的请求<br>先去找根域寻找，根域提供顶级域的IP地址(.com)。<br>COM域名服务器提供 imooc.com 的域的DNS服务器。<br>imooc.com 域的服务器给它提供资源。</li>
</ul>
<ol>
<li>TCP/IP三次握手</li>
</ol>
<p>4.浏览器发送HTTP请求</p>
<p>这个ab -n1000 -c10 <a href="http://localhost:2015/命令，在window系统下，需要先用cd命令定位到你的apache安装目录的bin文件夹" target="_blank" rel="external">http://localhost:2015/命令，在window系统下，需要先用cd命令定位到你的apache安装目录的bin文件夹</a></p>
<p>-n ：总共的请求执行数，缺省是1；<br>-c： 并发数，缺省是1；<br>-t：测试所进行的总时间，秒为单位，缺省50000s<br>-p：POST时的数据文件<br>-w: 以HTML表的格式输出结果</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[《JavaScript高级程序设计三》离线应用和客户端存储]]></title>
      <url>https://zaynex.github.io/2016/09/17/%E3%80%8AJavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%89%E3%80%8B%E5%88%9D%E6%B6%89IndexedDB/</url>
      <content type="html"><![CDATA[<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>cookie虽然在持久保存客户端数据提供了方便，分担了服务器存储的负担，但还是有很多局限性的。每个特定的域名下最多生成cookie是有限制的。<br><a id="more"></a></p>
<ul>
<li>浏览器能存cookie数比较少。如IE8，Firefox,opera每个域可以保存的50个cookie,Safari/WebKit没有限制。一个cookie最多可以存放4096B左右的数据，出于兼容性考虑，一般不超过4095B。</li>
</ul>
<p>优点：极高的扩展性和可用性</p>
<ul>
<li>通过良好的编程，控制保存在cookie中的session对象的大小</li>
<li>通过加密和安全传输技术（SSL），减少cookie被破解的可能性</li>
<li>只在cookie中存放不敏感数据，即使被盗也不会有重大损失</li>
<li>控制cookie的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的cookie</li>
</ul>
<p>缺点：</p>
<ul>
<li>Cookie数量和长度的限制。每个domain最多只能有20条cookie，每个cookie长度不能超过4KB，否则会被截掉</li>
<li>安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目的了</li>
<li>有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。</li>
</ul>
<h2 id="WebStorage存储机制"><a href="#WebStorage存储机制" class="headerlink" title="WebStorage存储机制"></a>WebStorage存储机制</h2><p>目的：解决Cookie带来的局限，即当数据被控制在客户端上时，无须持续将数据发回服务器。<br><code>sessionStotrage</code>，是<code>Storage</code>的实例。由于它绑定在某个服务器会话，所以当文件在本地运行时是不可用的，存储在sessionStorage中的数据只能由最初给对象存储数据的页面访问到，所以对多页面应用有限制。</p>
<p>存储特定于某个会话的数据。</p>
<p><code>sessionStorage</code>对象主要针对会话的小数据的存储。如果需要跨会话存储数据，需要用globalStorage。</p>
<p><code>globalStorage</code>指定那些域可以访问数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//使用方法存储</div><div class="line">sessionStorage.setItem(&quot;name&quot;, &quot;Zaynex&quot;);</div><div class="line">//使用属性存储</div><div class="line">sessionStorage.book = &quot;Front End Development&quot;;</div></pre></td></tr></table></figure>
<p>IE实现异步写入数据，所以在设置数据和将数据写入磁盘之间可能有些延迟。当大量数据时，IE浏览器会比其他同步写入的浏览器能更快的恢复执行，因为它会跳过实际的磁盘写入过程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">//设置新数据前使用begin方法</div><div class="line">sessionStorage.begin(); </div><div class="line">sessionStorage.name = &quot;Zaynex&quot;;</div><div class="line">sessionStorage.book = &quot;Front End Development&quot;;</div><div class="line">//设置完成后调用commit方法写入磁盘</div><div class="line">sessionStorage.commit();</div><div class="line"></div><div class="line">//使用方法获取数据</div><div class="line">sessionStorage.getItem(&quot;name&quot;);</div><div class="line">//使用属性获取数据</div><div class="line">var book = sessionStorage.book;</div><div class="line"></div><div class="line"></div><div class="line">//保存数据</div><div class="line">globalStorage[&quot;worx.com&quot;].name = &quot;Zaynex&quot;;</div><div class="line">//获取数据</div><div class="line">var name = globalStorage[&quot;worx.com&quot;].name;</div><div class="line"></div><div class="line">该存储空间对于worx.com及其子域都是可访问的。</div><div class="line"></div><div class="line">globalStorage[&quot;www.worx.com&quot;].name = &quot;Zaynex&quot;;</div><div class="line">var name = globalStorage[&apos;www.worx.com&apos;].name;</div></pre></td></tr></table></figure>
<p>该存储空间只能由来自<code>www.worx.com</code>的页面访问，其他子域不行。</p>
<p>存储在<code>globalSotrage</code>会一直保存在磁盘上（未删除情况下），<strong>非常适合在客户端存储文档或者长期保存用户偏好的设置</strong>。</p>
<p>localStorage在HTML5中作为持久保存客户端数据的方案取代了globalStorage。<br>要访问同一个localStorage对象，页面必须来自同一个域名，使用同种协议以及端口号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//存储数据</div><div class="line">localStorage.setItem(&quot;name&quot;, &quot;zaynex&quot;);</div><div class="line">localStorage.book = &quot;Front End Development&quot;;</div><div class="line">//获取数据</div><div class="line">var name = localStorage.getItem(&quot;name&quot;);</div><div class="line">var book = localStorage.book;</div></pre></td></tr></table></figure>
<h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h3><p>对于Web Storage，一般来说，存储空间大小的限制都是以每个源（协议域名和端口号）为单位的。</p>
<p>对于localStorage和sessionStorage，大多数桌面浏览器会设置每个来源5MB的限制。Chrome和Safari对每个来源的限制是2.5MB。手机端浏览器都是2.5MB。</p>
<h2 id="IndexedDB"><a href="#IndexedDB" class="headerlink" title="IndexedDB"></a>IndexedDB</h2><p>索引数据库 (IndexedDB) API（作为 HTML5 的一部分）对创建具有丰富本地存储数据的数据密集型的离线 HTML5 Web 应用程序很有用。同时它还有助于本地缓存数据，使传统在线 Web 应用程序（比如移动 Web 应用程序）能够更快地运行和响应。</p>
<p>特点：使用对象保存数据，而非表。</p>
<p>兼容性写法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var indexedDB = window.indexedDB || window.webkitIndexedDB || window.mozIndexedDB || window.msIndexedDB;</div></pre></td></tr></table></figure></p>
<h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//打开数据库，如果传入的数据库名存在则打开，否则创建该名称的数据库</div><div class="line">openRequest = IndexedDB.open(dbName);</div><div class="line">//打开数据库会返回IDBRequest对象，可以添加如下事件</div><div class="line">openRequest.onerror = function(event) &#123;</div><div class="line">	alert(&quot;Something bad to you：&quot; + event.target.errorCode);</div><div class="line">&#125;;</div><div class="line">openRequest.onsuccess = function(event) &#123;</div><div class="line">	database = event.target.result;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">//当新数据库创建或者数据库版本号被修改时触发</div><div class="line">openRequest.onupgradeneeded = function (evt) &#123;</div><div class="line">        //...</div><div class="line">   &#125;;</div></pre></td></tr></table></figure>
<p>error.target指向openRequest对象。</p>
<h3 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var deleteDB = indexedDB.deleteDatabase(dbName);</div><div class="line">deleteDB.onsuccess = function (event) &#123;</div><div class="line">  // database deleted successfully</div><div class="line">&#125;;</div><div class="line">deleteDB.onerror = function (e) &#123;</div><div class="line">  console.log(&quot;Database error: &quot; + e.target.errorCode);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="创建对象存储以及索引"><a href="#创建对象存储以及索引" class="headerlink" title="创建对象存储以及索引"></a>创建对象存储以及索引</h3><p>对象存储是一个数据记录集合。要在现有数据库中创建一个新对象存储，则需要对现有数据库进行版本控制。为此，请打开要进行版本控制的数据库。除了数据库名称之外，open 方法还接受版本号作为第二个参数。如果希望创建数据库的一个新版本（也就是说，要创建或修改一个对象存储），只需打开具有现有数据库版本更高的数据库。这会调用 onupgradeneeded 事件处理函数。</p>
<p>除了使用键来检索对象存储中的记录，还可使用代索引的字段来检索记录。对象存储可具有一个或多个索引。索引是一种特殊的对象存储，它引用包含数据的对象存储，在更改所引用的对象存储时（也就是添加、修改或删除记录时）自动更新。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var objectStore = thisDb.createObjectStore(tableName, &#123;keyPath: &quot;id&quot;, autoIncrement:true&#125;),//设置为主键</div><div class="line">	objectStore.createIndex(&quot;name&quot;, &quot;name&quot;, &#123;unique: false&#125;),</div><div class="line">	objectStore.createIndex(&quot;phone&quot;, &quot;phone&quot;, &#123;unique: false&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="使用事务"><a href="#使用事务" class="headerlink" title="使用事务"></a>使用事务</h3><p>所有的操作都是通过事务来完成的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var transaction = db.transaction([tableName], &quot;readWrite&quot;);//事务读写</div><div class="line">transaction.oncomplete = function(event) &#123;</div><div class="line">	console.log(&quot;All done!&quot;);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">transaction.onerror = function(event) &#123;</div><div class="line">	console.dir(event);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="事务模式"><a href="#事务模式" class="headerlink" title="事务模式"></a>事务模式</h4><ul>
<li>readonly: 提供对某个对象存储的只读访问，在查询对象存储时使用。</li>
<li>readwrite: 提供对某个对象存储的读取和写入访问权。</li>
<li>versionchange: 提供读取和写入访问权来修改对象存储定义，或者创建一个新的对象存储。</li>
</ul>
<p>默认的事务模式为 readonly。您可在任何给定时刻打开多个并发的 readonly 事务，但只能打开一个 readwrite 事务。出于此原因，只有在数据更新时才考虑使用 readwrite 事务。单独的（表示不能打开任何其他并发事务）versionchange 事务操作一个数据库或对象存储。可以在 onupgradeneeded 事件处理函数中使用 versionchange 事务创建、修改或删除一个对象存储，或者将一个索引添加到对象存储。</p>
<p>通过<code>objectStore()</code>方法并传入存储空间的名称，就可以访问特定的存储空间。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var objectStore = transaction.objectStore(tableName);//得到表里的objectSotre对象</div></pre></td></tr></table></figure></p>
<h3 id="使用游标查询"><a href="#使用游标查询" class="headerlink" title="使用游标查询"></a>使用游标查询</h3><p><code>openCursor()</code>方法用于创建一个游标，它接受两个可选的参数，其中包括范围和方向。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">var request = objectStore.openCursor();</div><div class="line">request.onsuccess = function(event)&#123;//游标遍历</div><div class="line">	var cursor = event.target.result;</div><div class="line">	if(cursor) &#123;</div><div class="line">		console.log(cursor.key);</div><div class="line">		console.dir(cursor.value);</div><div class="line">		render(&#123;key:cursor.key,name:cursor.value[&quot;name&quot;], phone:cursor.value[&apos;phone&apos;], address:cursor.value[&apos;address&apos;]&#125;);</div><div class="line"></div><div class="line">		lastCurosr = cursor.key;</div><div class="line">		cursor.continue();//取得下一位游标</div><div class="line">	&#125;else &#123;</div><div class="line">		console.log(&quot;Done the cursor&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">request.onerror = function(event) &#123;</div><div class="line">	console.dir(event);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h4 id="游标索引键范围"><a href="#游标索引键范围" class="headerlink" title="游标索引键范围"></a>游标索引键范围</h4><ul>
<li>IDBKeyRange.bound： 返回指定范围内的所有记录。这个范围有一个下边界和上边界。它还有两个可选的参数:<code>lowerOpen</code>和<code>upperOpen</code>,这两个参数表明下边界或上边界上的记录是否应包含在范围内。</li>
<li>IDBKeyRange.lowerBound: 超过指定的边界值范围的所有记录。此范围有一个可选的参数<code>lowerOpen</code>，表明下边界上的记录是否应包含在范围中。</li>
<li>IDBKeyRange.upperBound: 返回指定的边界值之前的所有记录。它也有一个可选的<code>upperOpen</code>参数。</li>
<li>IDBKeyRange.only: 仅返回与指定值匹配的记录。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">var curName = document.getElementById(&quot;seartxt&quot;).value,</div><div class="line">	transaction =db.transaction([tablename],&quot;readwrite&quot;),</div><div class="line">	objectStore = transaction.objectStore(tablename),</div><div class="line">	boundKeyRange = IDBKeyRange.only(curName);</div><div class="line"></div><div class="line">objectStore.index(&quot;name&quot;).openCursor(boundKeyRange).onsuccess = function(event)&#123;</div><div class="line">    var cursor = event.target.result;</div><div class="line">    if(!cursor)&#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    var rowData = cursor.value;</div><div class="line">    console.log(rowData);</div><div class="line">    document.getElementById(&quot;result&quot;).innerHTML=&quot;&lt;caption&gt;&lt;h3&gt;学生花名册&lt;/h3&gt;&lt;/caption&gt;&lt;tr&gt;&lt;th&gt;学号&lt;/th&gt;&lt;th&gt;姓名&lt;/th&gt;&lt;th&gt;生日&lt;/th&gt;&lt;th&gt;地址&lt;/th&gt;&lt;th&gt;删除&lt;/th&gt;&lt;/tr&gt;&quot;</div><div class="line">    render(&#123;key:cursor.key,name:cursor.value[&quot;name&quot;],date:cursor.value[&quot;date&quot;],address:cursor.value[&quot;address&quot;]&#125;);</div><div class="line">    cursor.continue();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="完整的DEMO"><a href="#完整的DEMO" class="headerlink" title="完整的DEMO"></a>完整的DEMO</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> db;</div><div class="line"><span class="keyword">var</span> arrayKeys = [],</div><div class="line">	openRequest,</div><div class="line">	lastCurosr,</div><div class="line">	indexedDB = <span class="built_in">window</span>.indexedDB || <span class="built_in">window</span>.webkitIndexedDB || <span class="built_in">window</span>.mozIndexedDB || <span class="built_in">window</span>.msIndexedDB;</div><div class="line">	dbName = <span class="string">"person"</span>,</div><div class="line">	tableName = <span class="string">"testTable"</span>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	openRequest = IndexedDB.open(dbName);</div><div class="line"></div><div class="line">	<span class="comment">//handle setup</span></div><div class="line">	<span class="comment">//当新数据库创建或者数据库版本号被修改时触发</span></div><div class="line">	openRequest.onupgradeneeded = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(<span class="string">"running onupgradeneeded"</span>);</div><div class="line">		<span class="keyword">var</span> thisDb = e.target.result;</div><div class="line">		<span class="built_in">console</span>.log(thisDb.version);</div><div class="line">		<span class="keyword">if</span>(!thisDb.objectStoreNames.contains(tableName)) &#123;</div><div class="line">			<span class="built_in">console</span>.log(<span class="string">"I need to create the objectstore"</span>);</div><div class="line">			<span class="keyword">var</span> objectStore = thisDb.createObjectStore(tableName, &#123;keyPath: <span class="string">"id"</span>, autoIncrement:<span class="literal">true</span>&#125;);<span class="comment">//设置为主键</span></div><div class="line">			objectStore.createIndex(<span class="string">"name"</span>, <span class="string">"name"</span>, &#123;unique: <span class="literal">false</span>&#125;);</div><div class="line">			objectStore.createIndex(<span class="string">"phone"</span>, <span class="string">"phone"</span>, &#123;unique: <span class="literal">false</span>&#125;); </div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	openRequest.onsuccess = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">		db = e.target.result;</div><div class="line">		<span class="built_in">console</span>.log(de.version);</div><div class="line">		db.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">			alert(<span class="string">"database Error"</span> + event.target.errorCode);</div><div class="line">			<span class="built_in">console</span>.log(event.target);</div><div class="line">		&#125;;</div><div class="line"></div><div class="line">		<span class="keyword">if</span>(db.objectStoreNames.contains(tableName)) &#123;</div><div class="line">			<span class="built_in">console</span>.log(<span class="string">"contains table:"</span> + tableName);</div><div class="line">			<span class="keyword">var</span> transaction = db.transaction([tableName], <span class="string">"readWrite"</span>);<span class="comment">//事务读写</span></div><div class="line">			transaction.oncomplete = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">				<span class="built_in">console</span>.log(<span class="string">"All done!"</span>);</div><div class="line">			&#125;;</div><div class="line"></div><div class="line">			transaction.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">				<span class="built_in">console</span>.dir(event);</div><div class="line">			&#125;;</div><div class="line"></div><div class="line">			<span class="keyword">var</span> objectStore = transaction.objectStore(tableName);<span class="comment">//得到表里的objectSotre对象</span></div><div class="line"></div><div class="line">			objectStore.openCursor().onsuccess = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;<span class="comment">//游标遍历</span></div><div class="line">				<span class="keyword">var</span> cursor = event.target.result;</div><div class="line">				<span class="keyword">if</span>(cursor) &#123;</div><div class="line">					<span class="built_in">console</span>.log(cursor.key);</div><div class="line">					<span class="built_in">console</span>.dir(cursor.value);</div><div class="line">					render(&#123;key:cursor.key,name:cursor.value[<span class="string">"name"</span>], phone:cursor.value[<span class="string">'phone'</span>], address:cursor.value[<span class="string">'address'</span>]&#125;);</div><div class="line"></div><div class="line">					lastCurosr = cursor.key;</div><div class="line">					cursor.continue();</div><div class="line">				&#125;<span class="keyword">else</span> &#123;</div><div class="line">					<span class="built_in">console</span>.log(<span class="string">"Done the cursor"</span>);</div><div class="line">				&#125;</div><div class="line">			&#125;;</div><div class="line"></div><div class="line">			objectStore.openCursor().onerror = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">				<span class="built_in">console</span>.dir(event);</div><div class="line">			&#125;;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	openRequest.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(<span class="string">"Error"</span> + event);</div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line">	            <span class="comment">//添加方法</span></div><div class="line">            <span class="built_in">document</span>.querySelector(<span class="string">"#add"</span>).addEventListener(<span class="string">"click"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">            <span class="comment">//初始化一个学生对象</span></div><div class="line">                <span class="keyword">var</span> name = <span class="built_in">document</span>.querySelector(<span class="string">"#name"</span>).value;</div><div class="line">                <span class="keyword">var</span> date = <span class="built_in">document</span>.querySelector(<span class="string">"#date"</span>).value;</div><div class="line">                <span class="keyword">var</span> address = <span class="built_in">document</span>.querySelector(<span class="string">"#address"</span>).value;</div><div class="line">                <span class="keyword">var</span> student=&#123;<span class="string">"name"</span>:name,<span class="string">"date"</span>:date,<span class="string">"address"</span>:address&#125;;</div><div class="line">                <span class="comment">//获取一个事物</span></div><div class="line">                <span class="keyword">var</span> transaction = db.transaction([tablename],<span class="string">"readwrite"</span>);</div><div class="line">                <span class="comment">//事物回调函数的处理</span></div><div class="line">                transaction.oncomplete = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">                    <span class="built_in">console</span>.log(<span class="string">"transactiono complete"</span>);</div><div class="line">                &#125;</div><div class="line">                transaction.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">                    <span class="built_in">console</span>.dir(event);</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//通过事物得到一个objectStore对象</span></div><div class="line">                <span class="keyword">var</span> objectStore = transaction.objectStore(tablename);</div><div class="line">                objectStore.add(student);</div><div class="line">                <span class="comment">//将新添加的数据，加入到html里面展示</span></div><div class="line">                objectStore.openCursor().onsuccess = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">                    cursor = event.target.result;</div><div class="line">                    <span class="keyword">var</span> key;</div><div class="line">                    <span class="keyword">if</span>(lastCursor==<span class="literal">null</span>)&#123;</div><div class="line">                        key=cursor.key;</div><div class="line">                        lastCursor=key;</div><div class="line">                    &#125;<span class="keyword">else</span>&#123;</div><div class="line">                        key=++lastCursor;</div><div class="line">                    &#125;</div><div class="line">                    render(&#123;key:key,name:name,date:date,address:address&#125;);</div><div class="line">                    <span class="built_in">console</span>.log(<span class="string">"成功添加一条新纪录！key值："</span>+key);</div><div class="line">                    <span class="built_in">console</span>.dir(student);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">            <span class="comment">//查询数据库</span></div><div class="line">            <span class="built_in">document</span>.querySelector(<span class="string">"#seacher"</span>).addEventListener(<span class="string">"click"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">                <span class="keyword">var</span> curName = <span class="built_in">document</span>.getElementById(<span class="string">"seartxt"</span>).value;</div><div class="line">                <span class="keyword">var</span> transaction =db.transaction([tablename],<span class="string">"readwrite"</span>);</div><div class="line">                transaction.oncomplete = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">                    <span class="built_in">console</span>.log(<span class="string">"transaction complete"</span>);  </div><div class="line">                &#125;;</div><div class="line">                transaction.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">                    <span class="built_in">console</span>.dir(event);</div><div class="line">                &#125;;</div><div class="line">                <span class="comment">//得到objectStore对象</span></div><div class="line">                <span class="keyword">var</span> objectStore = transaction.objectStore(tablename);</div><div class="line">                <span class="keyword">var</span> boundKeyRange = IDBKeyRange.only(curName); <span class="comment">//生成一个索引范围的Range对象</span></div><div class="line">                objectStore.index(<span class="string">"name"</span>).openCursor(boundKeyRange).onsuccess = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">                    <span class="keyword">var</span> cursor = event.target.result;</div><div class="line">                    <span class="keyword">if</span>(!cursor)&#123;</div><div class="line">                        <span class="keyword">return</span>;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">var</span> rowData = cursor.value;</div><div class="line">                    <span class="built_in">console</span>.log(rowData);</div><div class="line">                    <span class="built_in">document</span>.getElementById(<span class="string">"result"</span>).innerHTML=<span class="string">"&lt;caption&gt;&lt;h3&gt;学生花名册&lt;/h3&gt;&lt;/caption&gt;&lt;tr&gt;&lt;th&gt;学号&lt;/th&gt;&lt;th&gt;姓名&lt;/th&gt;&lt;th&gt;生日&lt;/th&gt;&lt;th&gt;地址&lt;/th&gt;&lt;th&gt;删除&lt;/th&gt;&lt;/tr&gt;"</span></div><div class="line">                    render(&#123;key:cursor.key,name:cursor.value[<span class="string">"name"</span>],date:cursor.value[<span class="string">"date"</span>],address:cursor.value[<span class="string">"address"</span>]&#125;);</div><div class="line">                    cursor.continue();</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">            <span class="comment">//删除数据库</span></div><div class="line">            <span class="built_in">document</span>.querySelector(<span class="string">"#deleteDatabase"</span>).addEventListener(<span class="string">"click"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">                <span class="keyword">if</span>(confirm(<span class="string">"您确定要删除数据库吗？\n操作不可逆"</span>))&#123;</div><div class="line">                    <span class="keyword">var</span> dbname=prompt(<span class="string">"请输入数据库名称，以确认删除"</span>,<span class="string">""</span>);</div><div class="line">                    <span class="keyword">if</span>(dbname==dbName)&#123;</div><div class="line">                        <span class="keyword">var</span> deleteDB=indexedDB.deleteDatabase(dbName);</div><div class="line">                        <span class="keyword">var</span> result = <span class="built_in">document</span>.querySelector(<span class="string">"#result"</span>);</div><div class="line">                        <span class="keyword">while</span>(result.firstChild.nextSibling)&#123;</div><div class="line">                        result.removeChild(result.firstChild.nextSibling);</div><div class="line">                        &#125;                      </div><div class="line">                        <span class="built_in">window</span>.location.reload(<span class="literal">true</span>);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">        &#125; 	</div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">function</span> <span class="title">deletestu</span>(<span class="params">key</span>)</span>&#123;</div><div class="line">            <span class="keyword">var</span> transaction = db.transaction([tablename],<span class="string">"readwrite"</span>);</div><div class="line">                transaction.oncomplete = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">                    <span class="built_in">console</span>.log(<span class="string">"transaction complete!"</span>);</div><div class="line">                &#125;;</div><div class="line">                 </div><div class="line">                transaction.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">                    <span class="built_in">console</span>.dir(event);</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//得到objectStore对象</span></div><div class="line">                <span class="keyword">var</span> objectStore = transaction.objectStore(tablename);</div><div class="line">                <span class="comment">//接收传过来的key值</span></div><div class="line">                <span class="keyword">var</span> removeKey = <span class="built_in">parseInt</span>(key);</div><div class="line">                <span class="comment">//通过key值获取对象,在控制台打印</span></div><div class="line">                <span class="keyword">var</span> getRequest=objectStore.get(removeKey);</div><div class="line">                getRequest.onsuccess=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">                    <span class="keyword">var</span> result = getRequest.result;</div><div class="line">                    <span class="built_in">console</span>.dir(result);</div><div class="line">                &#125;;</div><div class="line">                <span class="keyword">var</span> request = objectStore.delete(removeKey);</div><div class="line">                request.onsuccess = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">                    <span class="built_in">console</span>.log(<span class="string">"success delete record!"</span>);   </div><div class="line">                &#125;;</div><div class="line">                request.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">                    <span class="built_in">console</span>.log(<span class="string">"Error delete record:"</span>,e);   </div><div class="line">                &#125;</div><div class="line">                <span class="built_in">document</span>.getElementById(removeKey).style.display=<span class="string">"none"</span>;</div><div class="line">                 </div><div class="line">        &#125;</div><div class="line">        <span class="comment">//将从游标得到的database数据添加到html的方法</span></div><div class="line">        <span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">student</span>)</span>&#123;</div><div class="line">            <span class="comment">//接收传输的值</span></div><div class="line">            <span class="keyword">var</span> stu=student;</div><div class="line">            <span class="comment">//将结束到的josn数据变成一行表格</span></div><div class="line">            <span class="keyword">var</span> html =<span class="string">"&lt;tr id='"</span>+stu.key+<span class="string">"'&gt;&lt;td&gt;"</span>+stu.key+<span class="string">"&lt;/td&gt;&lt;td&gt;"</span>+stu.name+<span class="string">"&lt;/td&gt;&lt;td&gt;"</span>+stu.date+<span class="string">"&lt;/td&gt;&lt;td&gt;"</span>+stu.address+<span class="string">"&lt;/td&gt;&lt;td&gt;&lt;input type='button' onClick='deletestu("</span>+stu.key+<span class="string">")' value='删除' /&gt;"</span>;</div><div class="line">            <span class="comment">//将得到的表格数据，追加到结果表中去</span></div><div class="line">            <span class="built_in">document</span>.getElementById(<span class="string">"result"</span>).innerHTML +=html;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>```<br>&lt;!doctype html&gt;</p>
<html lang="en"><br><head><br>    <meta charset="UTF-8"><br>    <title>Document</title><br>      <style type="text/css"><br>    *{margin:0;padding:0;}<br>    #tools{<br>        color:#fff;<br>        position:fixed;<br>        width:100%;<br>        bottom:0px;<br>        left:0px;<br>        background-color:#069;<br>        height:30px;<br>        line-height:30px;<br>    }<br>    #tools:hover{<br>        height:150px;}<br>    #tools div{<br>        width:30%;<br>        float:left;<br>        text-align:center;<br>        }<br>    #tools div {<br>        display:block;<br>    }<br>    #tools div input[type=button],input[type=reset]{<br>        width:70px;<br>        background-color:#fff;<br>        color:#069;<br>        border:0;<br>        font-weight:bolder;<br>        margin-left:5px;<br>    }<br>    table{<br>        border:2px solid #ccc;<br>        margin:20px auto;<br>    }<br>    td,th{<br>        width:200px;<br>        border:1px solid #069;<br>    }<br>    </style><br></head><br> <body><br>        <table id="result" cellpadding="0" cellspacing="0"><br>            <caption><h3>学生花名册</h3></caption><br>                <tr><th>学号</th><th>姓名</th><th>生日</th><th>地址</th><th>删除</th></tr><br>        </table><br>        <div id="tools"><br>            <div id="adddiv"><br>                <h3>添加学生</h3><br>                <label for="name">姓名</label><input type="text" name="name" id="name"><br><br>                <label for="date">生日</label><input type="date" name="date" id="date"><br><br>                <label for="address">地址</label><input type="text" name="address" id="address"><br><br>                <input type="button" name="add" value="添加" id="add"><input type="reset" value="重置表单"><br>            </div><br>            <div id="seacherdiv"><br>                <h3>搜索学生姓名</h3><br>                <input type="text" id="seartxt"><input type="button" id="seacher" name="seacher" value="搜索"><br>            </div><br>            <div id="deletediv"><br>                <h3>删除数据库</h3><br>                <input type="button" name="deleteDatabase" id="deleteDatabase" value="删除数据库"><br>            </div><br>        </div><br>        <script src="imooc.js"></script><br>    </body><br></html>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[我还好，只是选择了更艰难的路]]></title>
      <url>https://zaynex.github.io/2016/09/16/%E6%88%91%E8%BF%98%E5%A5%BD%EF%BC%8C%E5%8F%AA%E6%98%AF%E9%80%89%E6%8B%A9%E4%BA%86%E6%9B%B4%E8%89%B0%E9%9A%BE%E7%9A%84%E7%9A%84%E8%B7%AF/</url>
      <content type="html"><![CDATA[<p>一个多月没有发过文章了，其实也有在自己的博客里也有潦草的记下几笔，但有时候只想说给自己听。这一次，我想跟我的朋友们，跟自己的过去好好谈谈。</p>
<p>在很多人眼里，我似乎一直是个忙碌的人，老师觉得我上进，朋友肯定我的努力。但有时候，我只是在追赶外界的热度，我的好奇心很强，我的野心也很大，有野心是好事，但有时候利用不好就成了急功近利。我就好像《百鸟朝凤》里的蓝月，恐怕不能像天鸣这样静下心来专心搞好手头上的事，但又感觉自己和天鸣很像，剧情里焦师傅当初要收天鸣为徒就是因为天鸣当时看到自己的父亲跌倒时流出的那滴泪。</p>
<p>想到小升初那会，拿着爸妈给我军训的钱逃去网吧上网后来被妈妈逮到，奶奶领我去她那住。那天她送我去学校。正好学校大道上几位校领导在那里攀谈。奶奶拉着我走了过去，跟他们说明了情况，几位领导听了以后对我很是不满意。当时我也不知道是处于什么原因留下了眼泪，他们见状，便跟我奶奶说：“会哭的小孩看样子还有用。”再后来的事情，我也不记得了，我不记得我是怎样走进教室和军训的。但唯有那一幕，却留在我记忆深处。</p>
<p>我曾经有过很多机会可以提高自己，只是没有给自己明确的定位。</p>
<p>当年大一，给一位搞电子设计的学长写了一封邮件，希望他能给我机会让我加入电子协会。他说看好我，不要让他失望。我也曾经在几个周末捣鼓单片机，玩玩跑马灯。可过了段时间，我发现我对那些电路并不感兴趣，自己的物理很少是及格的，尤其是电路这块。再后来，我便让那位学长失望了。</p>
<p>后来，又有幸认识了一位导师，不过他的主攻方向是网络路由这块。我也曾在图书馆CCNA相关的视频，记得寒假的时候还在家里看TCP/IP协议（圣经级别书籍），看起了考研专用的《计算机网络》书籍。再后来，我们之间在学术上的情谊就这样不了了之了。</p>
<p>虽然有时候还联系，不过都是些校务上的琐事，偶尔也会探讨下生活。</p>
<p>那时候身边也有同学去做前端，我也凑个热闹学了点前端，把慕课网上的前端课程看了大半。然而，因为自己已经不是大一，所以也没机会加入相应的社团，我曾经也做出努力过，参加了网页设计大赛，可自己只会静态页面，也让带我们的老师失望了。那时候也傻逼的花过几个通宵改点代码。</p>
<p>那时候也因为看了《人人都是产品经理》，出于对这份工作的好奇，早在大二结束的假期，就有机会找到了一份相关实习，也认识了很不错的朋友，现在他们都过得很好。</p>
<p>得益于上一次实习，我又在网易找到了一份运营工作。那时候正是春招，都想着逮着机会提前晋级，而且课少，平时也是无所事事。身边的同学有时候电话或微信像我询问网易实习的生活，也都很羡慕，因为我在男生最喜欢的部门工作————网易游戏。</p>
<p>那时候授课老师问我去哪里实习，虽然内心很自豪但还是很平静的回复了他。我记得我当时跟老师的对话是：可能我做技术类的东西进不了网易，但是做非技术类的就有比较大的机会。<br>我反复思考当时与老师对话时的这句，当时的我，是否只是为了追求大公司的光环来证明自己？现在，我很明确当时就是这样，我太希望有些东西来证明自己，我确实着急了。</p>
<p>实习那段时间我感到很压抑，我不喜欢游戏（虽然以前极度痴迷，但因为某些原因，突然反感了），更可恶的是有时候明明没有什么事上司却跟你说时间要待够，实在可笑。<br>就这个岗位的锻炼还是很大的，我曾经问过其他部门的同学，哪怕你是浙大的高材生，也干着没脑子点点鼠标的活，有些工作就像是等价交换，我给你光环，你给我打杂，什么时候是个头呢？如果一份工作不能发挥你的才智和创意，这会很痛苦。</p>
<p>我佩服想跳槽并勇敢跳槽的人，这些人不满足于当下的环境，他们更希望释放自己的才华，做自己喜欢的事情，更重要的是，能成功跳槽的人有肯定有两把刷子，有些人在岗位上待久了，很有可能有心无力，连跳槽的能力都退化了。</p>
<p>有时候下班比较晚，还看几个小时前端相关的书籍，真庆幸我留住了她。</p>
<p>是的，我想自己做点东西，但是自己又在做非技术岗，将来也只可能还是转产品/运营岗。平时上班的时间已经严重长了，实在是太累。我能明显的感受到这份工作给我带来的收获和机遇，但并不是我真正所期待的。我记得准备离职的时候跟旁边办公的同事聊了，她跟我说她现在也不喜欢自己做的事情，但是很无奈。</p>
<p>愈发觉得自己需要作出选择，我不希望以后也说出同样的话。</p>
<p>2016年7月5日，我正式从网易辞职，签离职协议的那天，还是暴雨。</p>
<p>然而，就我那半吊子，还没资格踏进开发行业。不是因为你会前端就有人要你了，每年培训班出来的人就跟包饺子一样，分分钟就一波了。</p>
<p>离职那段时间过得很自由，也思考了很多，我也经常沿着运河跑步，自己买菜烧饭，但是由于要看的技术书籍比较多，看其他书籍的时间就越来越少了。心态好的时候看起来一切都好。这段放肆的时间，也暴露了自己的本性，或者说，是人性。</p>
<p>我也曾非常担忧，担心自己不能及时找到一份合适的工作，因为这段时间正好暑假，大小公司早在暑假前就已经定好了实习生。<br>我也曾质疑自己，是否有真正有能力做好前端，既然是软件开发，计算机基础很重要，我也没有学好计算机。<br>我也曾后悔，如果当时没有做这个决定，或许我每天还能吃上酸奶牛仔排这样的工作餐，而不是自己拮据的买菜，自己烧饭，有时候就是一个大包菜炒了一顿吃一天。<br>有时候也很抑郁，看到几个常联系的朋友都拿着名企的offer，羡慕之余更多的还是对自己无能的悲哀。</p>
<p>然而，我又深深体会到我需要这段经历，来打击我的锐气，消磨我的意志，这是我最难熬的时刻，在校招之际辞职，反而想要从事一份更有技术难度但自己基础却不扎实的行业。</p>
<p>有时候看到群里很多程序员想转岗，而我这个做运营的，却想要从事技术。或许这两种不同的心态吧。</p>
<p>我选择做前端意图比较简单，得益于新的技术诞生，前端这个岗位变得更加丰富多彩，而且所有浏览器只有标准的一门编程语言，甚至连后台服务器也能用前端的语言去编程，这是革命性的创新。<br>另外，我太想自己去实现一些东西了。能把自己的创意付诸实践才真正有价值。</p>
<p>很多人都对程序员存在误解，觉得他们只是照着别人的设计要求去编程，就是个机器。存在偏见的人肯定没有上GitHub(全球最大同性交友网站)上看过，你并不知道那些极客们是如何把自己的创意一点一点实现的，你根本无法体会到有时候只是你脑子里的一个念头突然成了现实的那般惊喜。</p>
<p>编程可以让你的自由时间都得以好好利用。</p>
<p>我要吃的苦头才刚开始，就大学来说，我做的决定算晚的，可对于漫漫人生而言，做任何决定都不迟，除非你真的学不动了，动不了了。</p>
<p>在《异类》这本书里介绍了10000小时定律，那些年纪轻轻的天才们早在少年便经过大量的练习和深度学习，决定性因素并不是他们的智力，只要拥有普通人的智力，智力就不会成为关键因素。<br>还有一个最重要的因素就是时机。<br>如果仔细得查阅比尔盖茨的过去就会发现，他十几岁就接触计算机并开始实践编程，在当时可能一个学校就一台计算机。等到计算机普及的时候，他早已经是编程高手了。</p>
<p>我想到自己小学的时候还拿过年级的口算第一名，我在想也许我曾经是对数学有一定兴趣的。但在后来，老师也没有鼓励，父母也没有在意，当一个人没有刻意培养某些专长或进行持续训练学习的时候，就和常人一样。所以比较遗憾的是我高考的时候数学不及格。</p>
<p>一旦有点苗头的时候，就应该乘势追击。</p>
<p>关于产品运营之类的，其实做什么都好，我不多做评价，就看个人是否喜欢，因为做好任何一份工作都是不容易的，看到的和亲身经历的绝对不同。当然，行业的未来也很重要。</p>
<p>说了那么多，也是想重新和自己见面，因为每年这个时候，我总是会写一份类似这种的文章。也希望将自己的写作保持下去（最近因为要学的技术笔记实在太多了）</p>
<p>回到学校，往称上一站，才发现自己瘦了很多。回到学校的每个晚上都在做梦，前几个晚上需要听一些歌帮助睡眠，可能写了那么多就会安心睡着了吧。</p>
<p>可能我就是一个理想主义者和悲观主义的结合体。每当我做出选择的时候我都信心满满，然而，有些时候又会陷入悲观的自我循环，尤其是深夜的时候，思绪就像黑夜一样蔓延。不过庆幸的是一次又一次我都挺过来了，当然，这一次，就是长征了。</p>
<p>如果非要在结尾加上一句煽情的话，我只想对自己和朋友们说：做什么都好，做自己最好，坚持才能做得更好。</p>
<p>这句话，可以陪我很久。</p>
<p>奚文正</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[用Require进行代码文件依赖管理]]></title>
      <url>https://zaynex.github.io/2016/09/16/%E7%94%A8Require%E8%BF%9B%E8%A1%8C%E4%BB%A3%E7%A0%81%E6%96%87%E4%BB%B6%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/</url>
      <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>通常我们会以手动线性方式在<code>&lt;/body&gt;</code>按顺序放入需要用到的JavaScript文件。我们必须要确保各个文件列在它所依赖的文件的后面，但当数量增加时，以这种方式进行管理文件会变得越发困难，特别是在需要移除某一文件但又不能影响其依赖于此文件的情况下。<br><a id="more"></a></p>
<h2 id="Require"><a href="#Require" class="headerlink" title="Require"></a>Require</h2><p>RequireJS是一款JavaScript模块加载器，可以很好的解决以上问题。并且还有一个优点：异步加载脚本文件。</p>
<p>RequireJS库基于异步模块定义（AMD）的API。 </p>
<h3 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;!doctype html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</div><div class="line">    &lt;title&gt;Mailing list&lt;/title&gt;</div><div class="line">    &lt;link href=&quot;http://fonts.googleapis.com/css?family=Lobster|Abel&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;</div><div class="line">    &lt;link rel=&quot;stylesheet&quot; href=&quot;styles/main.css&quot;&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">    &lt;form action=&quot;thank-you.html&quot; id=&quot;form&quot; method=&quot;post&quot;&gt;</div><div class="line">        &lt;h1&gt;Join our mailing list&lt;/h1&gt;</div><div class="line">        &lt;label for=&quot;email&quot;&gt;Enter your email address&lt;/label&gt;</div><div class="line">        &lt;input type=&quot;text&quot; name=&quot;email&quot; id=&quot;email&quot; placeholder=&quot;e.g. me@mysite.com&quot;&gt;</div><div class="line">        &lt;input type=&quot;submit&quot; value=&quot;Sign up&quot;&gt;</div><div class="line">    &lt;/form&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<p>用户提交email的地址代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;!doctype html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">&lt;head&gt;</div><div class="line">    &lt;meta charset=&quot;utf-8&quot;&gt;</div><div class="line">    &lt;title&gt;Thank you&lt;/title&gt;</div><div class="line">    &lt;link href=&quot;http://fonts.googleapis.com/css?family=Lobster|Abel&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot;&gt;</div><div class="line">    &lt;link rel=&quot;stylesheet&quot; href=&quot;styles/main.css&quot;&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">    &lt;div class=&quot;card&quot;&gt;</div><div class="line">        &lt;h1&gt;Thank you&lt;/h1&gt;</div><div class="line">        &lt;p&gt;Thank you for joining our mailing list.&lt;/p&gt;</div><div class="line">    &lt;/div&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div></pre></td><td class="code"><pre><div class="line">html,</div><div class="line">body &#123;</div><div class="line">    height: 100%;</div><div class="line">&#125;</div><div class="line"></div><div class="line">body &#123;</div><div class="line">    font-size: 62.5%;</div><div class="line">    margin: 0;</div><div class="line">    background: #32534D;</div><div class="line">    background-image: -webkit-gradient(linear, 0% 0%, 0% 100%, from(#1a82f7), to(#2F2727));</div><div class="line">    background-image: -webkit-linear-gradient(top, #1a82f7, #2F2727);</div><div class="line">    background-image: -moz-linear-gradient(top, #1a82f7, #2F2727);</div><div class="line">    background-image: -ms-linear-gradient(top, #1a82f7, #2F2727);</div><div class="line">    background-image: -o-linear-gradient(top, #1a82f7, #2F2727);</div><div class="line">&#125;</div><div class="line"></div><div class="line">body,</div><div class="line">input &#123;</div><div class="line">    font-family: &quot;Lobster&quot;, sans-serif;</div><div class="line">&#125;</div><div class="line"></div><div class="line">h1 &#123;</div><div class="line">    font-size: 4.4em;</div><div class="line">    letter-spacing: -1px;</div><div class="line">    padding-bottom: 0.25em;</div><div class="line">&#125;</div><div class="line"></div><div class="line">form,</div><div class="line">.card &#123;</div><div class="line">    position: absolute;</div><div class="line">    top: 100px;</div><div class="line">    bottom: 100px;</div><div class="line">    min-height: 250px;</div><div class="line">    left: 50%;</div><div class="line">    margin-left: -280px;</div><div class="line">    width: 400px;</div><div class="line">    padding: 20px 80px 80px;</div><div class="line">    border: 2px solid #333;</div><div class="line">    border-radius: 5px;</div><div class="line">    box-shadow: 5px 5px 15px #000;</div><div class="line">    background: #fff;</div><div class="line">    background-image: -webkit-gradient(linear, 0% 0%, 0% 100%, from(#eee), to(#fff));</div><div class="line">    background-image: -webkit-linear-gradient(top, #eee, #fff);</div><div class="line">    background-image: -moz-linear-gradient(top, #eee, #fff);</div><div class="line">    background-image: -ms-linear-gradient(top, #eee, #fff);</div><div class="line">    background-image: -o-linear-gradient(top, #eee, #fff);</div><div class="line">&#125;</div><div class="line"></div><div class="line">label,</div><div class="line">input,</div><div class="line">p &#123;</div><div class="line">    display: block;</div><div class="line">    font-size: 1.8em;</div><div class="line">    width: 100%;</div><div class="line">&#125;</div><div class="line"></div><div class="line">label,</div><div class="line">input[type=email],</div><div class="line">p &#123;</div><div class="line">    font-family: &quot;Abel&quot;, cursive;</div><div class="line">&#125;</div><div class="line"></div><div class="line">input &#123;</div><div class="line">    margin-bottom: 1em;</div><div class="line">    border: 1px solid #42261B;</div><div class="line">    border-radius: 5px;</div><div class="line">    padding: 0.25em;</div><div class="line">&#125;</div><div class="line"></div><div class="line">input[type=submit] &#123;</div><div class="line">    background: #dda;</div><div class="line">    color: #000;</div><div class="line">    font-weight: bold;</div><div class="line">    width: 103%;</div><div class="line">    font-size: 3em;</div><div class="line">    margin: 0;</div><div class="line">    box-shadow: 1px 1px 2px #000;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.error &#123;</div><div class="line">    border: 1px solid #f99;</div><div class="line">    background: #fff5f5;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>在html页面内添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;script src=&quot;scripts/require.js&quot; data-main=&quot;scripts/main&quot;&gt;&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>注意，这里的<code>data-main</code>的文件是可以省略后缀<code>js</code>的。</p>
<h3 id="定义模块"><a href="#定义模块" class="headerlink" title="定义模块"></a>定义模块</h3><p>利用RequireJS提供的<code>define()</code>函数来定义模块，这个模块是其他脚本文件所依赖的代码。比如jQuery。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"> define(</div><div class="line">            moduleName,//参数可选，如果不填写，则默认使用本模块所在文件的文件名</div><div class="line">            dependencies,//可选。一个数组，该数组包含此文件所需的各个依赖项目</div><div class="line">            function(parameters)&#123;</div><div class="line">            	//各依赖项成功加载后所运行的函数</div><div class="line">            	//parameters中包含的各个值来自依赖项，与dependencies参数中各个依赖形成对应关系</div><div class="line">            &#125; </div><div class="line">        );</div><div class="line"></div><div class="line">//示例</div><div class="line">define([&quot;lib/jquery-1.10.2.min&quot;], function($)&#123;</div><div class="line">	//这里放jquery加载完后要执行的模块代码</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>任何由依赖代码文件提供的返回值都会通过输入参数传入给模块函数。这些传入到模块函数的参数只能在这个模块里使用，这样就能把代码与它依赖进行封装。对于JavaScript来说，访问函数作用域之内的局部变量的速度比上一级的作用域范围去解析出变量要快一些。所以还提升了性能。</p>
<p>但是有没有发现，我们要完整的写出jquery版本号？<br>其实我们可以给它起个别名，相应的名称映射放到主应用脚本文件上。</p>
<h3 id="模块名称的别名"><a href="#模块名称的别名" class="headerlink" title="模块名称的别名"></a>模块名称的别名</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">requirejs.config(&#123;</div><div class="line">	paths: &#123;</div><div class="line">		&quot;jquery&quot;: &quot;lib/jquery-1.10.2&quot;</div><div class="line">	&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>现在我们只需要使用<code>jquery</code>作为依赖项名称，而不是文件自身的文件名了。</p>
<p>我们还可以引用CDN的资源，如果用户已经缓存了，那就不用下载啦！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">requirejs.config(&#123;</div><div class="line">    paths: &#123;</div><div class="line">        &quot;jquery&quot;: [</div><div class="line">            &quot;https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min&quot;,</div><div class="line">            // If the CDN fails, load from this local file instead</div><div class="line">            &quot;lib/jquery-1.10.2&quot;</div><div class="line">        ]</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="建立模块"><a href="#建立模块" class="headerlink" title="建立模块"></a>建立模块</h3><p>我们放了一个<code>validation-plugin.js</code>作为jQuery验证插件使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">define([&quot;jquery&quot;], function($) &#123;</div><div class="line">    $.fn.isValidEmail = function()&#123;</div><div class="line">        var isValid = true,</div><div class="line">            regExp = /\S+@S+\.\S+/;</div><div class="line"></div><div class="line">        this.each(function()&#123;</div><div class="line">            if(!regExp.test(this.value)) &#123;</div><div class="line">                isValid = false;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        return isValid;</div><div class="line">    &#125;;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="主应用脚本与所有模块实现关联"><a href="#主应用脚本与所有模块实现关联" class="headerlink" title="主应用脚本与所有模块实现关联"></a>主应用脚本与所有模块实现关联</h3><p>RequireJS提供的<code>define()</code>函数是在声明后，以便将来使用。但是我们需要主应用脚本立即执行，那就需要AMD的<code>require()</code>函数了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">requirejs.config(&#123;</div><div class="line">    paths: &#123;</div><div class="line">        &quot;jquery&quot;: [</div><div class="line">            &quot;https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min&quot;,</div><div class="line">            // If the CDN fails, load from this local file instead</div><div class="line">            &quot;lib/jquery-1.10.2&quot;</div><div class="line">        ]</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">require([&quot;jquery&quot;, &quot;lib/validation-plugin&quot;], function($) &#123;</div><div class="line">    var $form = $(&quot;#form&quot;),</div><div class="line">        $email = $(&quot;#email&quot;);</div><div class="line"></div><div class="line">    $form.on(&quot;submit&quot;, function(e) &#123;</div><div class="line">        e.preventDefault();</div><div class="line">        if ($email.isValidEmail()) &#123;</div><div class="line">            $form.get(0).submit();</div><div class="line">        &#125; else &#123;</div><div class="line">            $email.addClass(&quot;error&quot;).focus();</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    $email.on(&quot;keyup&quot;, function() &#123;</div><div class="line">        $email.removeClass(&quot;error&quot;);</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="请求时才加载额外的脚本"><a href="#请求时才加载额外的脚本" class="headerlink" title="请求时才加载额外的脚本"></a>请求时才加载额外的脚本</h3><p>现在我们已经完成得很棒了！但我们还没有完全发挥出RequireJS的优点。<br>以上的代码是当页面加载完成后就马上加载验证插件，其实我们完成可以在用户提交表单时才加载验证插件进行表单验证。<br>这样就可以减少验证插件的加载并且增强页面加载的性能。（首次加载时，所需的下载脚本文件数减少了）</p>
<h3 id="改进后的主应用脚本文件"><a href="#改进后的主应用脚本文件" class="headerlink" title="改进后的主应用脚本文件"></a>改进后的主应用脚本文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">require([&quot;jquery&quot;], function($)&#123;</div><div class="line">    var $form = $(&quot;#form&quot;),</div><div class="line">        $email = $(&quot;#email&quot;);</div><div class="line"></div><div class="line">    $form.on(&quot;submit&quot;, function(e)&#123;</div><div class="line">        e.preventDefault();//阻止默认事件</div><div class="line">        </div><div class="line">            //添加jQuery验证插件</div><div class="line">        require([&quot;lib/validation-plugin&quot;], function()&#123;</div><div class="line">            if ($email.isValidEmail()) &#123;</div><div class="line">                $form.get(0).submit();</div><div class="line">            &#125;else &#123;</div><div class="line">                $email.addClass(&quot;error&quot;).focus();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line"></div><div class="line">    $email.on(&quot;keyup&quot;, function()&#123;</div><div class="line">        $email.removeClass(&apos;error&apos;);</div><div class="line">    &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>当然，如果插件脚本文件较大时，在文件下载之前是不能提交表单的，这可能会对用户体验有一定影响。我们也可以选择在表单的文本域第一次获得焦点时就下载插件，那就更完美啦！</p>
<h3 id="RequireJS代码优化工具"><a href="#RequireJS代码优化工具" class="headerlink" title="RequireJS代码优化工具"></a>RequireJS代码优化工具</h3>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[《算法第四版》排序笔记]]></title>
      <url>https://zaynex.github.io/2016/09/16/%E3%80%8A%E7%AE%97%E6%B3%95%E7%AC%AC%E5%9B%9B%E7%89%88%E3%80%8B%E6%8E%92%E5%BA%8F%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>排序算法：<br>首先找到数组里最小的元素，其次把它和数组里第一个元素交换。（如果第一个元素就是最小的元素，就和它自己交换）。其次在剩下的元素中找到最小的元素，将它与数组的第二个元素交换。如此反复。</p>
<p>对于0到N-1的任意i都会进行一次交换和N-1-i交换，因此共有N次交换以及(N-1)(N-2)(N-3)+…+2+1 = N(N-1)/2，约为N^2/2次比较。</p>
<p>特点：运行时间与输入无关，也就是说哪怕你是排好序的数据也要进行这么多次排序<br>数据移动时最少的。每次交换都会改变两个数组元素的值。因此选择排序用了N次交换——交换次数和数组的大小是线性关系。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">import java.util.Arrays;</div><div class="line">public class Selection&#123;</div><div class="line">    public static void sort(Comparable[] a)&#123;</div><div class="line">        int N = a.length;</div><div class="line">        for(int i = 0; i &lt; N; i++) &#123;</div><div class="line">            int min = i;</div><div class="line">            for(int j = i+1; j &lt; N; j++) &#123;</div><div class="line">                if(less(a[j],a[min])) min = j;</div><div class="line">            &#125;</div><div class="line">            exch(a, i, min);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">        private static boolean less(Comparable v, Comparable w)&#123;</div><div class="line">            return v.compareTo(w) &lt; 0;</div><div class="line">        &#125;</div><div class="line">        private static void exch(Comparable[] a, int i, int j)</div><div class="line">        &#123;</div><div class="line">            Comparable t = a[i]; a[i] = a[j]; a[j] = t;</div><div class="line">        &#125;</div><div class="line">        private static void show(Comparable[] a)</div><div class="line">        &#123;</div><div class="line">            for (int i = 0; i &lt; a.length; i++)</div><div class="line">                StdOut.print(a[i] + &quot; &quot;);</div><div class="line">            StdOut.println();</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        public static boolean isSorted(Comparable[] a)</div><div class="line">        &#123;</div><div class="line">            for (int i = 1; i &lt; a.length; i++)</div><div class="line">                if(less(a[i], a[i-1])) return false;</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        public static void main(String[] args)</div><div class="line">        &#123;</div><div class="line">            String[] a = In.readStrings();</div><div class="line">            sort(a);</div><div class="line">            assert isSorted(a);</div><div class="line">            show(a);</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>插入排序所需的时间取决于输入中元素的初始顺序。对一个很大且已经有序的数组进行排序会比随机顺序的数组或者是逆序数组进行排序要快得多。</p>
<p>对于随机排序的长度为N且主键不重复的数组，平均情况下插入排序需要N^2/4次比较和N^2/4次交换。最坏情况续爱需要N^2/2次比较和N^2/2次交换，最好情况下需要N-1次比较和0次交换。</p>
<p>有序的数组</p>
<ul>
<li>数组中每个元素离它最终位置不远</li>
<li>一个有序的大数组接一个小数组</li>
<li>数组中只有几个元素的位置不正确</li>
</ul>
<p>如果倒置的元素很少，选择排序很可能是最快的。</p>
<p>插入排序需要的交换操作和数组中倒置的数量相等。需要的比较次数大于等于倒置数量，小于等于倒置的数量加上数组的大小减一。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[提升JavaScript性能]]></title>
      <url>https://zaynex.github.io/2016/09/15/%E6%8F%90%E5%8D%87JavaScript%E6%80%A7%E8%83%BD/</url>
      <content type="html"><![CDATA[<p>简单实用的一些提升JS性能的技巧<br><a id="more"></a></p>
<h3 id="服务器中使用Gzip编码"><a href="#服务器中使用Gzip编码" class="headerlink" title="服务器中使用Gzip编码"></a>服务器中使用Gzip编码</h3><p>发送之前，进行压缩，当数据到达浏览器后再进行解压缩，这样一来路线传输的数据更少文件到达浏览器事件更快。</p>
<h3 id="利用工具缩小JavaScript文件"><a href="#利用工具缩小JavaScript文件" class="headerlink" title="利用工具缩小JavaScript文件"></a>利用工具缩小JavaScript文件</h3><ul>
<li>缩编 (JSMIN)</li>
<li>混淆 (UglifyJS)</li>
<li>编译 (Google Closure Compiler)</li>
</ul>
<h3 id="匿名函数、自执行的函数闭包减少全局变量的使用"><a href="#匿名函数、自执行的函数闭包减少全局变量的使用" class="headerlink" title="匿名函数、自执行的函数闭包减少全局变量的使用"></a>匿名函数、自执行的函数闭包减少全局变量的使用</h3><p>哈哈，贴个复杂点的代码，这段代码很有意思的！<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Class = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">classDefinition, parentPrototype</span>) </span>&#123;</div><div class="line">		<span class="keyword">var</span> _NewClass = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">			<span class="keyword">if</span>(<span class="keyword">this</span>.initializa &amp;&amp; <span class="keyword">typeof</span> <span class="keyword">this</span>.initializa === <span class="string">'function'</span>)&#123;</div><div class="line">				<span class="keyword">this</span>.initializa.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</div><div class="line">			&#125;</div><div class="line">		&#125;,</div><div class="line">		_name;</div><div class="line">		<span class="keyword">if</span>(parentPrototype) &#123;</div><div class="line">			<span class="comment">//如果传入父类原型，则子类继承父类的所有方法和属性，利用constructor传递</span></div><div class="line">			_NewClass.prototype = <span class="keyword">new</span> parentPrototype.constructor();</div><div class="line">			<span class="keyword">for</span>(_name <span class="keyword">in</span> parentPrototype) &#123;</div><div class="line">				<span class="keyword">if</span>(parentPrototype.hasOwnProperty(_name)) &#123;</div><div class="line">					_NewClass.prototype[_name] = parentPrototype[_name];</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">//创建一个闭包，在闭包中返回另一个函数替代传入的函数</span></div><div class="line">		<span class="comment">//将传入的函数包装起来，并为当前对象提供一个_parent()方法</span></div><div class="line">		<span class="comment">//以支持父类中同名的方法的访问，就实现了对多态的继承</span></div><div class="line">		<span class="function"><span class="keyword">function</span> <span class="title">ploymorph</span>(<span class="params">thisFunction, parentFunction</span>)</span>&#123;</div><div class="line">			<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">				<span class="keyword">var</span> output;</div><div class="line">				<span class="keyword">this</span>._parent = parentFunction;</div><div class="line">				output = thisFunction.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</div><div class="line">				<span class="keyword">delete</span> <span class="keyword">this</span>._parent;</div><div class="line">				<span class="keyword">return</span> output;</div><div class="line">			&#125;;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">//将作为参数传递的类定义 应用到新创建的类中</span></div><div class="line">		<span class="comment">//覆盖所有parentPrototype中已存在的属性和方法</span></div><div class="line">		<span class="keyword">for</span>(_name <span class="keyword">in</span> classDefinition) &#123;</div><div class="line">			<span class="keyword">if</span>(classDefinition.hasOwnProperty(_name)) &#123;</div><div class="line">				<span class="comment">//如果正在利用多态，即创建和父类方法同名的新方法</span></div><div class="line">				<span class="comment">//我们希望提供一种在子类方法中调用父类方法的简单方式</span></div><div class="line">				<span class="keyword">if</span>(parentPrototype &amp;&amp; parentPrototype[_name] &amp;&amp; <span class="keyword">typeof</span> classDefinition[_name] === <span class="string">'function'</span>) &#123;</div><div class="line">					_NewClass.prototype[_name] = ploymorph(classDefinition[name], parentPrototype[_name]);</div><div class="line">				&#125;<span class="keyword">else</span> &#123;</div><div class="line">					<span class="comment">//如果不需要多态，则直接将classDefinition对象直接量中的项映射到新类的原型即可</span></div><div class="line">					_NewClass.prototype[_name] = classDefinition[_name];</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		_NewClass.prototype.constructor = _NewClass;</div><div class="line"></div><div class="line">		<span class="comment">//为新创建的类自身定义个extend方法，指向私有的extend函数，这个函数定义在下面，我们通过此方法可以将当前类作为父类来创建一个子类</span></div><div class="line">		_NewClass.extend = extend;</div><div class="line">		<span class="keyword">return</span> _NewClass;</div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line">	<span class="comment">//extend和create方法相同，不过隐藏额外的参数，用来继承父类的原型</span></div><div class="line">	<span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">classDefinition</span>) </span>&#123;</div><div class="line">		<span class="keyword">return</span> create(classDefinition, <span class="keyword">this</span>.prototype);</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//用相同的名字将私有的create方法暴露</span></div><div class="line">	<span class="keyword">return</span> &#123;</div><div class="line">		create: create</div><div class="line">	&#125;;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure></p>
<h3 id="动态加载JavaScript文件"><a href="#动态加载JavaScript文件" class="headerlink" title="动态加载JavaScript文件"></a>动态加载JavaScript文件</h3><p>请求时加载javascript文件，从而不阻塞浏览器，后期可以使用Require.js实现文件延时加载，以及利用标准化格式实现代码文件的依赖管理。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadScript</span>(<span class="params">src, onLoad</span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> scriptTag = <span class="built_in">document</span>.createElemen(<span class="string">"script"</span>);</div><div class="line">	scriptTag.src = src;</div><div class="line"></div><div class="line">	<span class="keyword">if</span>(<span class="keyword">typeof</span> onLoad === <span class="string">'function'</span>)&#123;</div><div class="line">		scriptTag.onload = onLoad;</div><div class="line">		scciptTag.onreadstatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">			<span class="keyword">if</span>(scriptTag.readState == <span class="number">4</span>) &#123;</div><div class="line">				onLoad();</div><div class="line">			&#125;</div><div class="line">		&#125;;</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">document</span>.body.appendChild(scriptTag);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//加载完后弹出提示框，也可以不传入这个方法</span></div><div class="line">loadScript(<span class="string">"my-script.js"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	alert(<span class="string">"script loaded and aviable!"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="优化文档对象操作"><a href="#优化文档对象操作" class="headerlink" title="优化文档对象操作"></a>优化文档对象操作</h3><h4 id="保存变量并通过单独父元素的引用访问子DOM元素"><a href="#保存变量并通过单独父元素的引用访问子DOM元素" class="headerlink" title="保存变量并通过单独父元素的引用访问子DOM元素"></a>保存变量并通过单独父元素的引用访问子DOM元素</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> wrapper = <span class="built_in">document</span>.getElementById(<span class="string">"wrapper"</span>),</div><div class="line">	header = wrapper.getElementsByTagName(<span class="string">"header"</span>)[<span class="number">0</span>],</div><div class="line">	nav = wrapper.getElementsByTagName(<span class="string">"nav"</span>)[<span class="number">0</span>];</div><div class="line"></div><div class="line">header.className += <span class="string">' '</span> + nav.className;</div></pre></td></tr></table></figure>
<h4 id="对新建元素实施DOM修改操作后才将其添加至当前实时页面"><a href="#对新建元素实施DOM修改操作后才将其添加至当前实时页面" class="headerlink" title="对新建元素实施DOM修改操作后才将其添加至当前实时页面"></a>对新建元素实施DOM修改操作后才将其添加至当前实时页面</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> list = <span class="built_in">document</span>.createElement(<span class="string">"ul"</span>),</div><div class="line">	listItem = <span class="built_in">document</span>.createElement(<span class="string">"li"</span>);</div><div class="line">listItem.innerHTML = <span class="string">"I am a list item"</span>;</div><div class="line">list.appendChild(listItem);</div><div class="line"></div><div class="line"><span class="built_in">document</span>.body.appendChild(list);</div></pre></td></tr></table></figure>
<h4 id="复制已有的元素提高性能"><a href="#复制已有的元素提高性能" class="headerlink" title="复制已有的元素提高性能"></a>复制已有的元素提高性能</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> list1 = <span class="built_in">document</span>.createElement(<span class="string">"ul"</span>),</div><div class="line">	list2,</div><div class="line">	listItem1 = <span class="built_in">document</span>.createElement(<span class="string">"li"</span>),</div><div class="line">	listItem2,</div><div class="line">	listItem3;</div><div class="line">listItem1.className = <span class="string">"list-item"</span>;</div><div class="line">listItem1.innerHTML = <span class="string">"I am a list item"</span>;</div><div class="line"></div><div class="line"><span class="comment">//使用cloneNode复制元素，设置参数为true则可以复制该元素下所有子元素，包括相关对象和属性</span></div><div class="line"></div><div class="line">listItem2 = listItem1.cloneNode(<span class="literal">true</span>);</div><div class="line">listItem3 = listItem1.cloneNode(<span class="literal">true</span>);</div><div class="line"></div><div class="line">list1.appendChild(listItem1);</div><div class="line">list1.appendChild(listItem2);</div><div class="line">list1.appendChild(listItem3);</div><div class="line"></div><div class="line"><span class="comment">//复制整个无序列表</span></div><div class="line">list2 = list1.cloneNode(<span class="literal">true</span>);</div><div class="line"></div><div class="line"><span class="comment">//把这两个一模一样的无序列表元素添加至实时页面</span></div><div class="line"><span class="built_in">document</span>.body.appendChild(list1);</div><div class="line"><span class="built_in">document</span>.body.appendChild(list2);</div></pre></td></tr></table></figure>
<h4 id="利用css而非javascript设置页面样式"><a href="#利用css而非javascript设置页面样式" class="headerlink" title="利用css而非javascript设置页面样式"></a>利用css而非javascript设置页面样式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//为重新渲染部分或整个页面，浏览器会重新计算页面元素位置和几何结构的进程叫重排（reflow)</span></div><div class="line"><span class="comment">//更新DOM元素的style属性会引发浏览器重排</span></div><div class="line"><span class="keyword">var</span> nav = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'nav'</span>)[<span class="number">0</span>];</div><div class="line">nav.style.backgroundColor = <span class="string">"red"</span>;</div><div class="line">nav.style.color = <span class="string">"#fff"</span>;</div><div class="line"><span class="comment">//好的方式</span></div><div class="line"><span class="keyword">var</span> nav = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'nav'</span>)[<span class="number">0</span>];</div><div class="line">nav.className += <span class="string">" selected"</span>; <span class="comment">//名称为selected的css类包含着多项样式设定</span></div><div class="line"></div><div class="line"><span class="comment">//如果这种方式不能用，我们可以通过隐藏元素并修改元素的style属性，减少重排的发生</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> nav = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"nav"</span>)[<span class="number">0</span>];</div><div class="line">nav.style.display = <span class="string">"none"</span>;<span class="comment">//引发一次重排</span></div><div class="line">nav.style.backgroundColor = <span class="string">"red"</span>;<span class="comment">//不引发重排</span></div><div class="line">nav.style.color = <span class="string">"#fff"</span>;<span class="comment">//不引发重排</span></div><div class="line">nav.style.display = <span class="string">"block"</span>; <span class="comment">//引发一次重排</span></div></pre></td></tr></table></figure>
<h4 id="提升DOM事件性能"><a href="#提升DOM事件性能" class="headerlink" title="提升DOM事件性能"></a>提升DOM事件性能</h4><h4 id="利用事件冒泡"><a href="#利用事件冒泡" class="headerlink" title="利用事件冒泡"></a>利用事件冒泡</h4><p>给多个子元素<code>对应的父元素</code>上应用该事件处理函数即可，就可以统一管理事件<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;ul id="list"&gt;</div><div class="line">	&lt;li class="list-item"&gt;&lt;a href="/" class="list-item-link"&gt;Home&lt;/a&gt;&lt;/li&gt;</div><div class="line">	&lt;li class="list-item"&gt;&lt;a href="/" class="list-item-link"&gt;News&lt;/a&gt;&lt;/li&gt;</div><div class="line">	&lt;li class="list-item"&gt;&lt;a href="/" class="list-item-link"&gt;Eevent&lt;/a&gt;&lt;/li&gt;</div><div class="line">&lt;/ul&gt;</div><div class="line"></div><div class="line">var list = document.getElementById('list');</div><div class="line">function onClick(event)&#123;</div><div class="line">	//target属性表示获取对所点击的实际元素的引用</div><div class="line">	var clickedElem = event.target;</div><div class="line">	tagNameSought = "a";</div><div class="line">	//检查是否为a标签</div><div class="line">	if(clickedElem &amp;&amp; clickedElem.tagName === tagNameSought) &#123;</div><div class="line">		window.open(clickedElem.href);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h4 id="使用框架化处理频繁发出的事件"><a href="#使用框架化处理频繁发出的事件" class="headerlink" title="使用框架化处理频繁发出的事件"></a>使用框架化处理频繁发出的事件</h4><p>某些事件会在连续状态下频繁发出，比如页面更改时浏览器出现的resize事件，使用鼠标或触屏所触发的mousemove和touchmove事件，或者是滚动页面时所出现的scroll事件。<br>把需要执行大量代码或潜在的计算密集型操作的时间处理函数直接关联在这些事件上会引发性能问题。</p>
<p>如果某事件处理代码正在执行而此时又有另一个事件发出，则事件调用会被积压。只有到事件的代码执行完毕后，后续的第二个事件才能执行。如果很多事件不断快速发出，就会出现卡顿等现象。<br>针对这个问题的解决办法是：<br><strong>让事件处理函数只负责把时间的当前值保存在变量中。把计算密集型的代码转移至单独的函数中，此函数按照计时器间隔运行代码，所使用的是保存在变量中的数据而不是直接取自于事件处理函数。</strong>这一原则被称为事件框架化。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> scrollTopPosition = <span class="number">0</span>,</div><div class="line">	scrollLeftPosition = <span class="number">0</span>,</div><div class="line">	body = <span class="built_in">document</span>.body,</div><div class="line">	header = <span class="built_in">document</span>.createElement(<span class="string">"header"</span>);</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//事件处理函数，只负责保存当前的滚动位置</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">onScroll</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	scrollTopPosition = body.scrollTop;</div><div class="line">	scrollLeftPosition = body.scrollLeft;</div><div class="line">&#125;</div><div class="line"><span class="comment">//增加更加一个函数，把当前的滚动位置显示在页面中id为header的元素中</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">writeScrollPosition</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(scrollTopPosition + <span class="string">"px, "</span> + scrollLeftPosition + <span class="string">"px"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//像往常一样关联事件至事件处理函数</span></div><div class="line"><span class="built_in">document</span>.addEventListener(<span class="string">"scroll"</span>, onScroll, <span class="literal">false</span>);</div><div class="line"></div><div class="line"><span class="comment">//每隔500ms执行一次 writeScrollTop函数，而不是每次scoll事件发出时都执行，从而提升性能</span></div><div class="line"></div><div class="line"><span class="built_in">window</span>.setInterval(writeScrollPosition, <span class="number">500</span>);</div></pre></td></tr></table></figure>
<h3 id="提升函数性能"><a href="#提升函数性能" class="headerlink" title="提升函数性能"></a>提升函数性能</h3><h4 id="记忆函数"><a href="#记忆函数" class="headerlink" title="记忆函数"></a>记忆函数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFactorial</span>(<span class="params">num</span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> result = <span class="number">1</span>,</div><div class="line">		index = <span class="number">1</span>;</div><div class="line">	<span class="keyword">for</span>(; index &lt;= num; index++) &#123;</div><div class="line">		result *= index;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line">alert(getFactorial(<span class="number">3</span>));</div><div class="line">alert(getFactorial(<span class="number">4</span>));</div><div class="line">alert(getFactorial(<span class="number">10</span>));</div><div class="line"></div><div class="line"><span class="comment">//4-19</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFactorial</span>(<span class="params">num</span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> result = <span class="number">1</span>,</div><div class="line">		index = <span class="number">1</span>;</div><div class="line">	<span class="keyword">if</span>(!getFactorial.storage) &#123;</div><div class="line">		getFactorial.storage = &#123;&#125;;</div><div class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span> (getFactorial.storage[num]) &#123;</div><div class="line">		<span class="keyword">return</span> getFactorial[num];</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">for</span>(; index &lt;= num; index++) &#123;</div><div class="line">		result *= index;</div><div class="line">	&#125;</div><div class="line">	getFactorial.storage[num] = result;</div><div class="line">&#125;</div><div class="line"></div><div class="line">alert(getFactorial(<span class="number">50</span>));<span class="comment">//执行函数里的全部内容</span></div><div class="line">alert(getFactorial(<span class="number">50</span>));<span class="comment">//返回一个保存的值。避免执行函数里的全部内容</span></div></pre></td></tr></table></figure>
<p>我们也可以直接封装一个<code>记忆函数</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">memoize</span>(<span class="params">fn</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="keyword">var</span> propertyName;</div><div class="line">		<span class="comment">//如果这个函数还没有用作记忆的对象属性，则为其添加一个</span></div><div class="line">		fn.storage = fn.storage || &#123;&#125;;</div><div class="line"></div><div class="line">		<span class="comment">//属性名称应该基于传给函数所设定的参数，以确保属性名称是唯一的，基于所有可能性输入参数组合的。</span></div><div class="line">		propertyName = <span class="built_in">Array</span>.property.join.call(<span class="built_in">arguments</span>, <span class="string">"|"</span>);</div><div class="line"></div><div class="line">		<span class="keyword">if</span>(propertyName <span class="keyword">in</span> fn.storage) &#123;</div><div class="line">			<span class="keyword">return</span> fn.storage[propertyName];</div><div class="line">		&#125;<span class="keyword">else</span> &#123;</div><div class="line">			<span class="comment">//如果不存在，执行相关函数并将结果保存在用作记忆的对象中</span></div><div class="line">			fn.storage[propertyName] = fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</div><div class="line">			<span class="keyword">return</span> fn.storage[propertyName];</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFactorial</span>(<span class="params">num</span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> result = <span class="number">1</span>,</div><div class="line">		index = <span class="number">1</span>;</div><div class="line">	<span class="keyword">for</span>(; index &lt;= num; index++) &#123;</div><div class="line">		result *= index;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//添加一般性记忆功能至函数</span></div><div class="line"><span class="keyword">var</span> getFactorialMemoized = memoize(getFactorial);</div><div class="line"></div><div class="line">alert(getFactorialMemoized(<span class="number">50</span>));</div><div class="line">alert(getFactorialMemoized(<span class="number">50</span>));</div></pre></td></tr></table></figure>
<h4 id="定义好数组长度后再循环"><a href="#定义好数组长度后再循环" class="headerlink" title="定义好数组长度后再循环"></a>定义好数组长度后再循环</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">在for循环中，先保存数值的长度</div><div class="line">for(var i = 0; i &lt; arr.length; i++) &#123;</div><div class="line">	//bad</div><div class="line">&#125;</div><div class="line">for(var i=0, len = arr.length; i &lt; len; i++)&#123;</div><div class="line">	//good	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="while反向循环"><a href="#while反向循环" class="headerlink" title="while反向循环"></a>while反向循环</h4><p>还有更快的方式，利用反向while循环，这种方式比for循环快的原因是每次for循环中，JavaScript解释器都需要运行一次比较。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> zerototen = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>],</div><div class="line">	len = zerototen.length,</div><div class="line">	index = len,</div><div class="line">	tentozero = [];</div><div class="line"></div><div class="line"><span class="keyword">while</span>(index--) &#123;</div><div class="line">	tentozero.push(zerototen[index]);</div><div class="line">&#125;</div><div class="line">alert(index);</div></pre></td></tr></table></figure>
<h4 id="Web-Worker"><a href="#Web-Worker" class="headerlink" title="Web Worker"></a>Web Worker</h4><p>由于JavaScript是单线程的，有时候难免在处理大量计算时，会出现用户界面锁定。<br>Web Worker允许加速一个运行特定密集代码的新进程，使得原来的进程不会锁定浏览器，其实就是在后台运行。<br>简单来说，就是又开启了一个全新的线程，把复杂的计算交给了这个新线程去处理。</p>
<h4 id="整体处理逻辑"><a href="#整体处理逻辑" class="headerlink" title="整体处理逻辑"></a>整体处理逻辑</h4><p>我们以利用Web Worker处理图像来说明<br>以下代码发生了如下事情：</p>
<ul>
<li>等待原始图片加载完毕</li>
<li>利用canvas复制原始图片数据（像素、宽高）</li>
<li>将原始图片数据传递给 web worker(listing.js)线程处理</li>
<li>web worker(listing.js)监听到有数据传入，处理图片后返回数据</li>
<li>webwork.js接受到线程传入的数据后，将图片数据填入到canvas</li>
<li>将canvas添加到页面中</li>
</ul>
<h5 id="页面"><a href="#页面" class="headerlink" title="页面"></a>页面</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;!doctype html&gt;</div><div class="line">&lt;html lang=&quot;en&quot;&gt;</div><div class="line">&lt;head&gt;</div><div class="line">	&lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class="line">	&lt;title&gt;Document&lt;/title&gt;</div><div class="line">&lt;/head&gt;</div><div class="line">&lt;body&gt;</div><div class="line">&lt;img src=&quot;demo.jpg&quot; alt=&quot;&quot; id=&quot;image&quot;&gt;</div><div class="line">&lt;script src=&quot;webwork.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<h5 id="webwork-js代码部分"><a href="#webwork-js代码部分" class="headerlink" title="webwork.js代码部分"></a>webwork.js代码部分</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> canvas = <span class="built_in">document</span>.createElement(<span class="string">"canvas"</span>),</div><div class="line">	context = canvas.getContext(<span class="string">"2d"</span>),</div><div class="line">	img = <span class="built_in">document</span>.getElementById(<span class="string">"image"</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">processImage</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">var</span> imgWidth = img.width,</div><div class="line">		imgHeight = img.height;</div><div class="line">		<span class="keyword">if</span>(<span class="built_in">window</span>.Worker)&#123;</div><div class="line">			<span class="comment">//定义一个新的Web Worker</span></div><div class="line">			workerThread = <span class="keyword">new</span> Worker(<span class="string">"listing.js"</span>);</div><div class="line">		&#125;</div><div class="line">		canvas.width = imgWidth;</div><div class="line">		canvas.height = imgHeight;</div><div class="line">		<span class="comment">//复制原图像至canvas，左上角开始对齐</span></div><div class="line">		context.drawImage(img, <span class="number">0</span>, <span class="number">0</span>, imgWidth, imgHeight);</div><div class="line">		<span class="comment">//一旦从Web Worker接受到消息（即图片处理完成后），就执行</span></div><div class="line">		workerThread.addEventListener(<span class="string">"message"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line">			<span class="keyword">var</span> imageData = e.data;</div><div class="line">			<span class="comment">//把新处理所得的图片像素填充至Canvas，从左上角开始</span></div><div class="line">			context.putImageData(imageData, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">			<span class="built_in">document</span>.body.appendChild(canvas);</div><div class="line">		&#125;, <span class="literal">false</span>);</div><div class="line"></div><div class="line">		<span class="comment">//向Web Worker线程发送canvas中所显示的原始图像数据，使该线程启动</span></div><div class="line">		workerThread.postMessage(context.getImageData(<span class="number">0</span>, <span class="number">0</span>, imgWidth, imgHeight));</div><div class="line">&#125;</div><div class="line"><span class="comment">//原始图片加载完成后，立即执行processImage</span></div><div class="line">img.addEventListener(<span class="string">"load"</span>, processImage, <span class="literal">false</span>);</div></pre></td></tr></table></figure>
<h5 id="listing-js代码部分"><a href="#listing-js代码部分" class="headerlink" title="listing.js代码部分"></a>listing.js代码部分</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">self.addEventListener(<span class="string">"message"</span>, invertImage, <span class="literal">false</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">invertImage</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> message = e.data,</div><div class="line">		imagePixels = message.data,</div><div class="line">		x = <span class="number">0</span>,</div><div class="line">		len = imagePixels.length;</div><div class="line"></div><div class="line"></div><div class="line">	<span class="keyword">for</span>(; x &lt; len; x += <span class="number">4</span>) &#123;</div><div class="line">		imagePixels[x] = <span class="number">255</span> - imagePixels[x];</div><div class="line">		imagePixels[x + <span class="number">1</span>] = <span class="number">255</span> - imagePixels[x + <span class="number">1</span>];</div><div class="line">		imagePixels[x + <span class="number">2</span>] = <span class="number">255</span> - imagePixels[x + <span class="number">2</span>];</div><div class="line">	&#125;</div><div class="line">	self.postMessage(message);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>感兴趣的同学可以试下最后的图像处理代码。记得要开启服务器哦！</p>
<h3 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> startTime,</div><div class="line">	endTime,</div><div class="line">	duration;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">var</span> index = <span class="number">0</span>,</div><div class="line">		length = <span class="number">10000000</span>,</div><div class="line">		counter = <span class="number">0</span>;</div><div class="line">	<span class="keyword">for</span>(; index &lt; length; index++) &#123;</div><div class="line">		counter += index;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">startTime = <span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line">doSomething();</div><div class="line"></div><div class="line">endTime = <span class="keyword">new</span> <span class="built_in">Date</span>();</div><div class="line">duration = endTime.getTime() - startTime.getTime();</div><div class="line"></div><div class="line">alert(duration);</div></pre></td></tr></table></figure>
<p>其实我们还可以利用<code>console</code>控制台让时间更精确</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">	<span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">length</span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> counter = <span class="number">0</span>,</div><div class="line">		index = <span class="number">0</span>;</div><div class="line">		<span class="built_in">console</span>.time(<span class="string">"Loop Timer "</span> + length);</div><div class="line"></div><div class="line">	<span class="keyword">for</span>(; index &lt; length; index++) &#123;</div><div class="line">		counter += index;</div><div class="line">	&#125;</div><div class="line">	<span class="built_in">console</span>.timeEnd(<span class="string">"Loop Timer "</span> + length);</div><div class="line">&#125;</div><div class="line">doSomething(<span class="number">101100</span>)</div></pre></td></tr></table></figure>
<p>千万要注意，这里的<code>Loop Timer</code>字符串一定要保持一致，不然会开启不同的计时器，不信你试试哈！</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>关于文档碎片<code>(document.createDocumentFragment)</code>在有些浏览器下并没有提高性能。<br>关于性能还有正则表达式没有介绍，想要写好一手正则确实不容易，下次再介绍正则相关的内容吧！</p>
<p>最后，推荐<code>《Pro JavaScript Development》</code>。以上的例子全是来自这本书的！进阶的同学可千万不要错过了哟！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[《Pro JavaScript》对象笔记]]></title>
      <url>https://zaynex.github.io/2016/09/15/%E3%80%8APro-JavaScript%E3%80%8B%E5%AF%B9%E8%B1%A1%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>创建一个类，其子类也可以作为一个类被继承。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div></pre></td><td class="code"><pre><div class="line">var Class = (function()&#123;</div><div class="line">	function create(classDefinition, parentPrototype) &#123;</div><div class="line">		var _NewClass = function()&#123;</div><div class="line">			if(this.initializa &amp;&amp; typeof this.initializa === &apos;function&apos;)&#123;</div><div class="line">				this.initializa.apply(this, arguments);</div><div class="line">			&#125;</div><div class="line">		&#125;,</div><div class="line">		_name;</div><div class="line">		if(parentPrototype) &#123;</div><div class="line">			//如果传入父类原型，则子类继承父类的所有方法和属性，利用constructor传递</div><div class="line">			_NewClass.prototype = new parentPrototype.constructor();</div><div class="line">			for(_name in parentPrototype) &#123;</div><div class="line">				if(parentPrototype.hasOwnProperty(_name)) &#123;</div><div class="line">					_NewClass.prototype[_name] = parentPrototype[_name];</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		//创建一个闭包，在闭包中返回另一个函数替代传入的函数</div><div class="line">		//将传入的函数包装起来，并为当前对象提供一个_parent()方法</div><div class="line">		//以支持父类中同名的方法的访问，就实现了对多态的继承</div><div class="line">		function ploymorph(thisFunction, parentFunction)&#123;</div><div class="line">			return function()&#123;</div><div class="line">				var output;</div><div class="line">				this._parent = parentFunction;</div><div class="line">				output = thisFunction.apply(this, arguments);</div><div class="line">				delete this._parent;</div><div class="line">				return output;</div><div class="line">			&#125;;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		//将作为参数传递的类定义 应用到新创建的类中</div><div class="line">		//覆盖所有parentPrototype中已存在的属性和方法</div><div class="line">		for(_name in classDefinition) &#123;</div><div class="line">			if(classDefinition.hasOwnProperty(_name)) &#123;</div><div class="line">				//如果正在利用多态，即创建和父类方法同名的新方法</div><div class="line">				//我们希望提供一种在子类方法中调用父类方法的简单方式</div><div class="line">				if(parentPrototype &amp;&amp; parentPrototype[_name] &amp;&amp; typeof classDefinition[_name] === &apos;function&apos;) &#123;</div><div class="line">					_NewClass.prototype[_name] = ploymorph(classDefinition[name], parentPrototype[_name]);</div><div class="line">				&#125;else &#123;</div><div class="line">					//如果不需要多态，则直接将classDefinition对象直接量中的项映射到新类的原型即可</div><div class="line">					_NewClass.prototype[_name] = classDefinition[_name];</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		_NewClass.prototype.constructor = _NewClass;</div><div class="line"></div><div class="line">		//为新创建的类自身定义个extend方法，指向私有的extend函数，这个函数定义在下面，我们通过此方法可以将当前类作为父类来创建一个子类</div><div class="line">		_NewClass.extend = extend;</div><div class="line">		return _NewClass;</div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line">	//extend和create方法相同，不过隐藏额外的参数，用来继承父类的原型</div><div class="line">	function extend(classDefinition) &#123;</div><div class="line">		return create(classDefinition, this.prototype);</div><div class="line">	&#125;</div><div class="line">	//用相同的名字将私有的create方法暴露</div><div class="line">	return &#123;</div><div class="line">		create: create</div><div class="line">	&#125;;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line">//initialize方法将成为新类的构造函数</div><div class="line">var Accomodation = Class.create(&#123;</div><div class="line">	isLocked: true,</div><div class="line">	isAlarmed: true,</div><div class="line">	lock: function()&#123;</div><div class="line">		this.isLocked = true;</div><div class="line">	&#125;</div><div class="line">	unlock: function()&#123;</div><div class="line">		this.isLocked = false;</div><div class="line">	&#125;</div><div class="line">	initialize: function()&#123;</div><div class="line">		this.unlock();</div><div class="line">	&#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">var House = Accomodation.extend(&#123;</div><div class="line">	floor: 2,</div><div class="line">	lock: function()&#123;</div><div class="line">		//虽然正在用多态替换父类方法，但仍可以用该方法访问被替换的父类方法</div><div class="line">		this_parent();</div><div class="line">		alert(&quot;Number of floors is locked: &quot; + this.floors);</div><div class="line">	&#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">var myAccommodation = new Accomodation();</div><div class="line">alert(myAccommodation instanceof Accomodation);//true</div><div class="line">alert(myAccommodation instanceof House);//false</div><div class="line"></div><div class="line">var myHouse = new House();</div><div class="line">alert(myHouse.isLocked);//false,由于父类中的initalize方法所设置，该方法被House继承</div><div class="line">alert(myHouse.lock()); //Number of floors is locked: 2;</div><div class="line">alert(myHouse instanceof House);//true</div><div class="line">alert(myHouse instanceof Accomodation);//true4</div></pre></td></tr></table></figure></p>
<h3 id="ES5的新特性"><a href="#ES5的新特性" class="headerlink" title="ES5的新特性"></a>ES5的新特性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">Object.preventExtensions();//禁止拓展对象属性方法，但可以修改原属性方法</div><div class="line">Object.isExtensible();//查看对象是否被锁定</div><div class="line">Object.freeze();//进一步锁定，使其原有属性方法都无法被修改</div><div class="line">Object.isFrozen();//对象是否被冻结</div><div class="line"></div><div class="line"></div><div class="line">var personDetails = &#123;</div><div class="line">	name: &apos;Den Oddle&apos;,</div><div class="line">	email: &quot;ok@ok.com&quot;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Object.getOwnPropertyDescriptor(personDetails, &quot;name&quot;);</div><div class="line">/*</div><div class="line">configurable:true</div><div class="line">enumerable:true</div><div class="line">value:&quot;Den Oddle&quot;</div><div class="line">writable:true</div><div class="line">__proto__:Object</div><div class="line">*/</div><div class="line"></div><div class="line">Object.defineProperty(personDetails,&quot;age&quot;, &#123;</div><div class="line">	value: 35,</div><div class="line">	writable: false,</div><div class="line">	enumerable: true,</div><div class="line">	configurable: true</div><div class="line">&#125;);</div><div class="line"></div><div class="line">Object.defineProperties(personDetails,&#123;</div><div class="line">	ChildAge: &#123;</div><div class="line">	value: 5,</div><div class="line">	writable: false,</div><div class="line">	enumerable: true,</div><div class="line">	configurable: true</div><div class="line">	&#125;,</div><div class="line">	ChildHobby: &#123;</div><div class="line">	value: &quot;basketball&quot;,</div><div class="line">	writable: true</div><div class="line">	&#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">//包含某个对象上所有属性名的数组Object.keys()</div><div class="line">keys = Object.keys(personDetails);</div><div class="line">console.log(keys.join(&quot;,&quot;));//name,email,age,ChildAge</div><div class="line"></div><div class="line">fathersDetails = Object.create(personDetails);</div><div class="line"></div><div class="line">fathersDetails.newName = &apos;Zaynex&apos;;</div><div class="line">console.log(fathersDetails.name);//Den Oddle</div><div class="line">console.log(fathersDetails.newName);//Zaynex</div></pre></td></tr></table></figure>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>在构造一个新的子类来继承并扩展一个类的时候，可能需要将某个方法替换为同名的新方法，新方法和原方法功类似，但仅针对子类做改变，着就是多态。在JS中，只需重写一个函数并给它一个和原方法同样的方法即可实现多态。</p>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>通过集成对已有的类进行改变或特殊化时，父类的所有属性和方法都对子类是可用的，在子类中不需要额外声明或定义任何东西就能使用所有父类的属性和方法。这种特性称为封装，子类只需要定义那些在父类的基础上新增的属性和方法即可。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>虽然没什么营养，但是代码看着还是很过瘾，日后可以回顾下。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[图解Http笔记摘要]]></title>
      <url>https://zaynex.github.io/2016/09/14/%E5%9B%BE%E8%A7%A3Http%E7%AC%94%E8%AE%B0%E6%91%98%E8%A6%81/</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[Javascript正则表达式匹配]]></title>
      <url>https://zaynex.github.io/2016/09/14/Javascript%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/</url>
      <content type="html"><![CDATA[<p>今天看到《JavaScript语言精粹》中的正则表达式这块，还是要整理下以免遗忘。<br><a id="more"></a><br>先以例子为开头，我们匹配一个地址。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">var parse_url = /^(?:([A-Za-z]+):)?(\/&#123;0,3&#125;)([0-9.\-A-Za-z]+)(?::(\d+))?(?:\/([^?#]*))?(?:\?([^#]*))?(?:#(.*))?$/;</div><div class="line">var url = &quot;http://www.github.io:80/username?q#zaynex&quot;;</div><div class="line">var result = parse_url.exec(url);</div><div class="line">var names = [&apos;url&apos;, &apos;scheme&apos;, &apos;slash&apos;, &apos;host&apos;, &apos;port&apos;, &apos;path&apos;, &apos;query&apos;, &apos;hash&apos;];</div><div class="line">var blanks = &apos;        &apos;;</div><div class="line">var i;</div><div class="line"></div><div class="line">for(i = 0; i &lt; names.length; i++) &#123;</div><div class="line">	document.writeln(names[i] + &quot;:&quot; +blanks.substring(names[i].length),result[i] + &quot;&lt;br&gt;&quot; );</div><div class="line">&#125;</div><div class="line">/*</div><div class="line">url: http://zaynex.github.io:80/username?q#zaynex</div><div class="line">scheme: http</div><div class="line">slash: //</div><div class="line">host: zaynex.github.io</div><div class="line">port: 80</div><div class="line">path: username</div><div class="line">query: q</div><div class="line">hash: zaynex</div><div class="line">*/</div></pre></td></tr></table></figure></p>
<h3 id="特殊字符及限定符"><a href="#特殊字符及限定符" class="headerlink" title="特殊字符及限定符"></a>特殊字符及限定符</h3><p>起始的<code>^</code>表示匹配字符串的开始，<br>结尾的<code>&amp;</code>表示匹配字符串的结束。</p>
<p>更多特殊字符参考下表：<br><img src="http://note.youdao.com/yws/public/resource/fe97742cb6713d591624cc9789862bdc/xmlnote/174E4E30EA4C42F384C64BEE4F63C411/35351" alt="image"></p>
<p><strong>注意，如果要匹配特殊字符需要在特殊字符前加转义字符<code>\</code>符来匹配</strong><br><code>(?:([A-Za-z]+):)?</code>中，最后一个<code>?</code>表示匹配0个或一个（惰性匹配，越少越好）。参考上表。<br>这里需要注意的是<code>(?:...)</code>这种格式的表示一个非捕获型分组。</p>
<h3 id="捕获组与非捕获组"><a href="#捕获组与非捕获组" class="headerlink" title="捕获组与非捕获组"></a>捕获组与非捕获组</h3><p>一旦使用了<code>()</code>就默认为捕获组，将<code>()</code>内表达式匹配的内容捕获到组里。</p>
<p>如果没有显式为捕获组命名，即没有使用命名捕获组，那么需要按数字顺序来访问所有捕获组。在只有普通捕获组的情况下，捕获组的编号是按照“(”出现的顺序，从左到右，从1开始进行编号的 。<br><img src="http://hi.csdn.net/attachment/201002/8/35916_12656733930M0l.jpg" alt="image"></p>
<h4 id="为什么要用非捕获组？"><a href="#为什么要用非捕获组？" class="headerlink" title="为什么要用非捕获组？"></a>为什么要用非捕获组？</h4><p>有时候我们不得不使用<code>()</code>，只要使用了就会默认开始捕获分组，但是我们并不关心<code>()</code>中的内容是什么，后面也不会用到捕获到的内容，这样就会占用内存，降低匹配效率。<br>设计非捕获分组的目的抵消捕获分组的副作用。</p>
<h4 id="非捕获型分组和捕获型分组的区别"><a href="#非捕获型分组和捕获型分组的区别" class="headerlink" title="非捕获型分组和捕获型分组的区别"></a>非捕获型分组和捕获型分组的区别</h4><ul>
<li>非捕获型分组仅是匹配，但不会保留匹配的结果。</li>
<li>捕获型分组会把匹配到的字符串保存下来，放入匹配结果数组中，在上面是<code>result</code>数组里，所以我们最后用到的for循环就是获取<code>result</code>数组里的所有捕获型分组。</li>
</ul>
<p>所以我们看到最外层通过非捕获，但是里面还有一层<code>()</code>，就匹配到了<code>http</code>。<br>那么所有匹配分组如下<br><code>(...)</code>表示匹配一个捕获型分组1，放入result数组中<br><code>(\/{0,3})</code>捕获型分组2<br><code>([0-9.\-A-Za-z]+)</code>捕获型分组3<br><code>(?::(\d+))?</code>捕获型分组4<br><code>(?:\/([^?#]*))?</code> 捕获型分组5，以/开始，匹配除了?#以外的所有字符。<br><code>(?:\?([^#]*))?</code> 捕获型分组6，包含0个或多个非#字符<br><code>(?:#(.*))?</code> 以#开始，.匹配除换行结束符以外的所有字符。捕获分组7。</p>
<p><code>[A-Za-z]</code>表示匹配大写A到大写Z和小写a到小写z中的任意字符，多个<code>+</code>，表示匹配一次或多次（贪婪匹配，匹配越多越好）。</p>
<p><code>\/</code>表示匹配<code>/</code>，别忘了，我们需要转移字符才能匹配到特殊字符。<br><code>[^?#]</code>表示匹配除了<code>?</code>和<code>#</code>以外的所有字符，这个<code>^</code>又表示逻辑上的非了。<br><code>(.*)</code>中的<code>.</code>表示匹配除换行符结束以外的所有字符。</p>
<h3 id="常见匹配表达式"><a href="#常见匹配表达式" class="headerlink" title="常见匹配表达式"></a>常见匹配表达式</h3><p>正则表达式是很强大的，想要写好也不容易，到时候再收集下几个常用个以后工作会用到。(未经测试)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[a-z] //匹配所有的小写字母 </div><div class="line">[A-Z] //匹配所有的大写字母 </div><div class="line">[a-zA-Z] //匹配所有的字母 </div><div class="line">[0-9] //匹配所有的数字 </div><div class="line">[0-9\.\-] //匹配所有的数字，句号和减号 </div><div class="line">[ \f\r\t\n] //匹配所有的白字符</div><div class="line">[^a-z] //除了小写字母以外的所有字符 </div><div class="line">[^\\\/\^] //除了(\)(/)(^)之外的所有字符 </div><div class="line">[^\&quot;\&apos;] //除了双引号(&quot;)和单引号(&apos;)之外的所有字符</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line"> Email的规则: name@domain</div><div class="line">  name最长64，domain最长253，总长最长256</div><div class="line">  name可以使用任意ASCII字符:</div><div class="line">    大小写英文字母 a-z,A-Z</div><div class="line">    数字 0-9</div><div class="line">    字符 !#$%&amp;&apos;*+-/=?^_`&#123;|&#125;~</div><div class="line">    字符 .不能是第一个和最后一个，不能连续出现两次</div><div class="line">    但是有些邮件服务器会拒绝包含有特殊字符的邮件地址</div><div class="line">    domain仅限于26个英文字母、10个数字、连词号-</div><div class="line">    连词号-不能是第一个字符</div><div class="line">    顶级域名（com、cn等）长度为2到6个</div><div class="line">*/</div><div class="line">var email = /^([\w-_]+(?:\.[\w-_]+)*)@((?:[a-z0-9]+(?:-[a-zA-Z0-9]+)*)+\.[a-z]&#123;2,6&#125;)$/i;</div><div class="line">email.exec(&apos;x@xxxx.io&apos;) //[&quot;x@xxxx.io&quot;, &quot;x&quot;, &quot;xxxx.io&quot;]</div><div class="line">email.exec(&apos;x@xxxx.ioioioio&apos;) // null</div><div class="line">email.exec(&apos;x@_xxxx.io&apos;) //null</div><div class="line"></div><div class="line">/*</div><div class="line">匹配手机号</div><div class="line"> */</div><div class="line">^1[3|4|5|7|8][0-9]\d&#123;8&#125;]$</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line">匹配中文字符的正则表达式： [\u4e00-\u9fa5]</div><div class="line">评注：匹配中文还真是个头疼的事，有了这个表达式就好办了</div><div class="line"></div><div class="line">匹配双字节字符(包括汉字在内)：[^\x00-\xff]</div><div class="line">评注：可以用来计算字符串的长度（一个双字节字符长度计2，ASCII字符计1）</div><div class="line"></div><div class="line">匹配空白行的正则表达式：\n\s*\r</div><div class="line">评注：可以用来删除空白行</div><div class="line"></div><div class="line">匹配HTML标记的正则表达式：&lt;(\S*?)[^&gt;]*&gt;.*?&lt;/\1&gt;|&lt;.*? /&gt;</div><div class="line">评注：网上流传的版本太糟糕，上面这个也仅仅能匹配部分，对于复杂的嵌套标记依旧无能为力</div><div class="line"></div><div class="line">匹配首尾空白字符的正则表达式：^\s*|\s*$</div><div class="line">评注：可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式</div><div class="line"></div><div class="line">匹配Email地址的正则表达式：\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*</div><div class="line">评注：表单验证时很实用</div><div class="line"></div><div class="line">匹配网址URL的正则表达式：[a-zA-z]+://[^\s]*</div><div class="line">评注：网上流传的版本功能很有限，上面这个基本可以满足需求</div><div class="line"></div><div class="line">匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$</div><div class="line">评注：表单验证时很实用</div><div class="line"></div><div class="line">匹配国内电话号码：\d&#123;3&#125;-\d&#123;8&#125;|\d&#123;4&#125;-\d&#123;7&#125;</div><div class="line">评注：匹配形式如 0511-4405222 或 021-87888822</div><div class="line"></div><div class="line">匹配腾讯QQ号：[1-9][0-9]&#123;4,&#125;</div><div class="line">评注：腾讯QQ号从10000开始</div><div class="line"></div><div class="line">匹配中国邮政编码：[1-9]\d&#123;5&#125;(?!\d)</div><div class="line">评注：中国邮政编码为6位数字</div><div class="line"></div><div class="line">匹配身份证：\d&#123;15&#125;|\d&#123;18&#125;</div><div class="line">评注：中国的身份证为15位或18位</div><div class="line"></div><div class="line">匹配ip地址：\d+\.\d+\.\d+\.\d+</div><div class="line">评注：提取ip地址时有用</div><div class="line"></div><div class="line">匹配特定数字：</div><div class="line">^[1-9]\d*$　 　 //匹配正整数</div><div class="line">^-[1-9]\d*$ 　 //匹配负整数</div><div class="line">^-?[1-9]\d*$　　 //匹配整数</div><div class="line">^[1-9]\d*|0$　 //匹配非负整数（正整数 + 0）</div><div class="line">^-[1-9]\d*|0$　　 //匹配非正整数（负整数 + 0）</div><div class="line">^[1-9]\d*\.\d*|0\.\d*[1-9]\d*$　　 //匹配正浮点数</div><div class="line">^-([1-9]\d*\.\d*|0\.\d*[1-9]\d*)$　 //匹配负浮点数</div><div class="line">^-?([1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0)$　 //匹配浮点数</div><div class="line">^[1-9]\d*\.\d*|0\.\d*[1-9]\d*|0?\.0+|0$　　 //匹配非负浮点数（正浮点数 + 0）</div><div class="line">^(-([1-9]\d*\.\d*|0\.\d*[1-9]\d*))|0?\.0+|0$　　//匹配非正浮点数（负浮点数 + 0）</div><div class="line">评注：处理大量数据时有用，具体应用时注意修正</div><div class="line"></div><div class="line">匹配特定字符串：</div><div class="line">^[A-Za-z]+$　　//匹配由26个英文字母组成的字符串</div><div class="line">^[A-Z]+$　　//匹配由26个英文字母的大写组成的字符串</div><div class="line">^[a-z]+$　　//匹配由26个英文字母的小写组成的字符串</div><div class="line">^[A-Za-z0-9]+$　　//匹配由数字和26个英文字母组成的字符串</div><div class="line">^\w+$　　//匹配由数字、26个英文字母或者下划线组成的字符串</div></pre></td></tr></table></figure>
<h3 id="参考地址："><a href="#参考地址：" class="headerlink" title="参考地址："></a>参考地址：</h3><p><a href="http://www.cnblogs.com/Jason-one/archive/2009/01/14/1375403.html" target="_blank" rel="external">http://www.cnblogs.com/Jason-one/archive/2009/01/14/1375403.html</a><br><a href="http://www.runoob.com/regexp/regexp-syntax.html" target="_blank" rel="external">http://www.runoob.com/regexp/regexp-syntax.html</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript语言精粹学习笔记]]></title>
      <url>https://zaynex.github.io/2016/09/14/JavaScript%E8%AF%AD%E8%A8%80%E7%B2%BE%E7%B2%B9%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[《算法》第四版第一章学习笔记]]></title>
      <url>https://zaynex.github.io/2016/09/14/%E3%80%8A%E7%AE%97%E6%B3%95%E3%80%8B%E7%AC%AC%E5%9B%9B%E7%89%88%E7%AC%AC%E4%B8%80%E7%AB%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript高级程序设计三之AJAX]]></title>
      <url>https://zaynex.github.io/2016/09/07/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%89%E4%B9%8BAJAX/</url>
      <content type="html"><![CDATA[<p>AJAX</p>
<h2 id="XMLHttpRequest对象Level1"><a href="#XMLHttpRequest对象Level1" class="headerlink" title="XMLHttpRequest对象Level1"></a>XMLHttpRequest对象Level1</h2><p>原生实现方法<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">//ie7+</div><div class="line">var xhr = new XMLHttpRequest();</div><div class="line"></div><div class="line">//早期版本</div><div class="line">function createXHR() &#123;</div><div class="line">	if(typeof XMLHttpRequest != &apos;undefined&apos;) &#123;</div><div class="line">		return new XMLHttpRequest();</div><div class="line">	&#125;else if (typeof ActiveXObject != &apos;undefined&apos;) &#123;</div><div class="line">		if(typeof arguments.callee.activeXString != &quot;string&quot;) &#123;</div><div class="line">			var versions = [&apos;MSXML2.XMLHttp.6.0&apos;,&apos;MSXML2.XMLHttp.3.0&apos;,&apos;MSXML2.XMLHttp&apos;],</div><div class="line">			i,len;</div><div class="line"></div><div class="line">			for(i = 0, len = versions.length; i &lt; len; i++) &#123;</div><div class="line">				try&#123;</div><div class="line">					new ActiveXObject(versions[i]);</div><div class="line">					arguments.callee.activeXString = versions[i];</div><div class="line">					break;</div><div class="line">				&#125; catch(ex) &#123;</div><div class="line">					//</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		return new ActiveXObject(arguments.callee.activeXString);</div><div class="line">	&#125; else &#123;</div><div class="line">		throw new Error(&quot;No XHR object available.&quot;);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="XHR用法"><a href="#XHR用法" class="headerlink" title="XHR用法"></a>XHR用法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">//请求类型（get,post等），请求的URL、是否异步发送请求的布尔值</div><div class="line">xhr.open(&apos;get&apos;,&apos;example.php&apos;,false)</div></pre></td></tr></table></figure>
<p>open方法building会真正发送请求，只是启动一个请求以备发送。<br>只能向一个域中使用相同端口号以及协议的URL发送请求。</p>
<h4 id="send"><a href="#send" class="headerlink" title="send"></a>send</h4><p>发送特定类型请求<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">xhr.open(&apos;get&apos;,&apos;example.txt&apos;,false);</div><div class="line">xhr.send(null);</div></pre></td></tr></table></figure></p>
<p>send接受参数表示要作为请求主体发送的数据。如果不需要通过请求主体发送数据则必须传入null。<br>由于这次请求是同步的，JavaScript会等到服务器响应后再继续执行。收到响应的数据会自动填充XHR对象的属性。</p>
<ul>
<li>responseText : 作为响应主体被返回的文本</li>
<li>responseXML : 如果响应内容是”text/xml”或者是”application/xml”.该属性保存响应数据的XML DOM文档</li>
<li>status : 响应的HTTP状态</li>
<li>statusText : HTTP状态说明</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">xhr.open(&apos;get&apos;,&apos;example.php&apos;,false);</div><div class="line">xhr.send(null);</div><div class="line">if((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304) &#123;</div><div class="line">	alert(xhr.responseText);</div><div class="line">&#125;else &#123;</div><div class="line">	alert(&apos;Request was unsuccessful:&apos; + xhr.status);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>无论内容类型是什么，响应主体的内容都会保存到responseText属性中，而对于非XML数据而言，responseText属性值为null.</p>
<h4 id="异步发送请求"><a href="#异步发送请求" class="headerlink" title="异步发送请求"></a>异步发送请求</h4><ul>
<li>0: 未初始化。未调用open()方法</li>
<li>1: 启动。调用open()方法</li>
<li>2: 发送。调用send()方法</li>
<li>3：接受。收到部分响应数据</li>
<li>4：完成，收到全部响应数据，并可以在客户端使用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var xhr = createXHR();</div><div class="line">xhr.onreadyStatechange = function()&#123;</div><div class="line">	if (xhr.readyState == 4) &#123;</div><div class="line">		if((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304)&#123;</div><div class="line">			alert(xhr.responseText);</div><div class="line">		&#125;else&#123;</div><div class="line">			alert(&quot;Request was unsuccessful:&quot; + xhr.status);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line">xhr.open(&apos;get&apos;,&apos;example.txt&apos;,&apos;true&apos;);</div><div class="line">xhr.send(null);</div><div class="line">//xhr.abort()取消异步请求。</div></pre></td></tr></table></figure>
<p>有的代码用this替换了xhr对象，但并不推荐这样使用，原因是<code>onreadystatechange</code>事件处理程序的作用域问题。在有的浏览器中会导致函数执行失败，或者导致错误发生。</p>
<h3 id="HTTP头部信息"><a href="#HTTP头部信息" class="headerlink" title="HTTP头部信息"></a>HTTP头部信息</h3><ul>
<li>Accept: 浏览器能处理的内容类型</li>
<li>Accpet-Charset: 浏览器能显示的字符集</li>
<li>Accpet-Encoding: 浏览器能够处理的压缩编码</li>
<li>Accpet-Language: 浏览器当前设置的语言</li>
<li>Connection: 浏览器和服务器之间连接的类型</li>
<li>Cookie: 当前页面设置的任何Cookie</li>
<li>Host: 发出请求页面所在的域</li>
<li>Referer: 发出请求页面的RUI</li>
<li>User-Agent: 浏览器的用户代理字符串<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var xhr = createXHR();</div><div class="line">xhr.onreadyStatechange = function()&#123;</div><div class="line">	if (xhr.readyState == 4) &#123;</div><div class="line">		if((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status == 304)&#123;</div><div class="line">			alert(xhr.responseText);</div><div class="line">		&#125;else&#123;</div><div class="line">			alert(&quot;Request was unsuccessful:&quot; + xhr.status);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line">xhr.open(&apos;get&apos;,&apos;example.txt&apos;,&apos;true&apos;);</div><div class="line">xhr.setRequestHeader(&quot;Myheader&quot;,&quot;Myvalue&quot;);</div><div class="line">xhr.send(null);</div></pre></td></tr></table></figure>
</li>
</ul>
<p>建议自定义头部字段名称</p>
<p>获取头部信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var myHeader = xhr.getResponseHeader(&quot;MyHeader&quot;);</div><div class="line">var allHeaders = xhr.getAllResponseHeaders();</div></pre></td></tr></table></figure></p>
<h3 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h3><p>常用于向服务器查询某些数据。可以将查询字符串参数追加到RUL末尾，以便将信息发送给服务器。<br>查询字符串参数的名称和值都必须使用encodeURIComponent()进行编码，然后才放到URL的末尾。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> xhr.open(<span class="string">"GET"</span>,<span class="string">"exmaple.php?name1=value2&amp;name2=value2"</span>);</div></pre></td></tr></table></figure></p>
<p>可以使用辅助函数向现有的URL的末尾添加查询字符串参数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">addURLParam</span>(<span class="params">url, name, value</span>)</span>&#123;</div><div class="line">	url += (url.indexOf(<span class="string">"?"</span>)) == <span class="number">-1</span> ?  <span class="string">"?"</span>:<span class="string">"&amp;"</span>;</div><div class="line">	url += <span class="built_in">encodeURIComponent</span>(name) + <span class="string">"="</span> + <span class="built_in">encodeURIComponent</span>(value);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> url = <span class="string">"example.php"</span>;</div><div class="line">url = addURLParam(url, <span class="string">"name"</span>, <span class="string">"Nicholas"</span>);</div><div class="line">url = addURLParam(url, <span class="string">"book"</span>, <span class="string">"Professional JavaScript"</span>);</div><div class="line"></div><div class="line">xhr.open(<span class="string">"get"</span>, url, <span class="literal">false</span>);</div></pre></td></tr></table></figure></p>
<h3 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xhr.open(&quot;post&quot;,&quot;example.php&quot;, true);</div></pre></td></tr></table></figure>
<p>由于服务器对POST和表单请求不会一视同仁，因此服务器必须有程序读取发送过来的原始数据再从中解析出有用的部分。<br>用XHR模拟表单提交。<br>将Content-type的头部信息设置为application/x-www-form-urlencoded.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">submitData</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">	xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="keyword">if</span>(xhr.readyState == <span class="number">4</span>) &#123;</div><div class="line">			<span class="keyword">if</span>(xhr.status === <span class="number">200</span>) &#123;</div><div class="line">				alert(xhr.responseText);</div><div class="line">			&#125;<span class="keyword">else</span>&#123;</div><div class="line">				alert(<span class="string">"Request was failed"</span> + xhr.status);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line">	xhr.open(<span class="string">"post"</span>,<span class="string">"example.php"</span>, <span class="literal">true</span>);</div><div class="line">	xhr.setRequestHeader(<span class="string">"Content-type"</span>,<span class="string">"application/x-www-form-urlencoded"</span>);</div><div class="line">	<span class="keyword">var</span> form = <span class="built_in">document</span>.getElementById(<span class="string">'user-info'</span>);</div><div class="line">	xhr.send(serialize(form));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="XMLHttpRequest-Level2"><a href="#XMLHttpRequest-Level2" class="headerlink" title="XMLHttpRequest Level2"></a>XMLHttpRequest Level2</h2><p>XMLHttpRequest是一个浏览器接口，使得Javascript可以进行 HTTP (S) 通信。但是，这个接口一直没有标准化，每家浏览器的实现或多或少有点不同。HTML 5 的概念形成后，W3C 开始考虑标准化这个接口。2008年 2 月，提出了XMLHttpRequest Level 2 草案。<br>以下是新版本的新增特性：</p>
<ul>
<li>可以设置HTTP（S）请求的时限。</li>
<li>可以使用FormData对象管理表单数据。</li>
<li>可以上传文件。</li>
<li>可以请求不同域名下的数据（跨域请求）。</li>
<li>可以获取服务器端的二进制数据。</li>
<li>可以获得数据传输的进度信息。</li>
</ul>
<h3 id="FormDate"><a href="#FormDate" class="headerlink" title="FormDate"></a>FormDate</h3><p>表单数据序列化,表单序列化的好处就是我们不需要再设定请求头部<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> data = <span class="keyword">new</span> FormData();</div><div class="line">data.append(<span class="string">"name"</span>, <span class="string">"Nicholas"</span>);</div><div class="line"><span class="comment">//也可以用表单元素的数据预先向其中添加键值对</span></div><div class="line"><span class="keyword">var</span> data = <span class="keyword">new</span> FormData(<span class="built_in">document</span>.forms[<span class="number">0</span>]);</div><div class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">if</span>(xhr.readyState == <span class="number">4</span>) &#123;</div><div class="line">		<span class="keyword">if</span>(xhr.status === <span class="number">200</span>) &#123;</div><div class="line">			alert(xhr.responseText);</div><div class="line">		&#125;<span class="keyword">else</span>&#123;</div><div class="line">			alert(<span class="string">"Request was failed"</span> + xhr.status);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line">xhr.open(<span class="string">"post"</span>,<span class="string">"example.php"</span>, <span class="literal">true</span>);</div><div class="line">xhr.setRequestHeader(<span class="string">"Content-type"</span>,<span class="string">"application/x-www-form-urlencoded"</span>);</div><div class="line"><span class="keyword">var</span> form = <span class="built_in">document</span>.getElementById(<span class="string">'user-info'</span>);</div><div class="line">xhr.send(<span class="keyword">new</span> FormData(form));</div></pre></td></tr></table></figure></p>
<h3 id="超时设定"><a href="#超时设定" class="headerlink" title="超时设定"></a>超时设定</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">xhr.open(<span class="string">"post"</span>,<span class="string">"example.php"</span>, <span class="literal">true</span>);</div><div class="line">xhr.timeout = <span class="number">1000</span>;<span class="comment">// 1秒</span></div><div class="line">xhr.outimeout = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	alert(<span class="string">"requset did not return in a second"</span>);</div><div class="line">&#125;</div><div class="line">xhr.send(<span class="literal">null</span>);</div><div class="line"><span class="keyword">var</span> form = <span class="built_in">document</span>.getElementById(<span class="string">'user-info'</span>);</div><div class="line">xhr.send(<span class="keyword">new</span> FormData(form));</div></pre></td></tr></table></figure>
<h3 id="overrideMimeType-方法"><a href="#overrideMimeType-方法" class="headerlink" title="overrideMimeType()方法"></a>overrideMimeType()方法</h3><p>老版本的XMLHttpRequest对象，只能从服务器取回文本数据（否则它的名字就不用XML起首了），新版则可以取回二进制数据。<br>这里又分成两种做法。较老的做法是改写数据的MIMEType，将服务器返回的二进制数据伪装成文本数据，并且告诉浏览器这是用户自定义的字符集。<br>下面是一个获取图片文件的代码示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">var xhr = new XMLHttpRequest();</div><div class="line">//向 server 端获取一张图片</div><div class="line">xhr.open(&apos;GET&apos;, &apos;/path/to/image.png&apos;, true);</div><div class="line"></div><div class="line">// 这行是关键！</div><div class="line">//将响应数据按照纯文本格式来解析，字符集替换为用户自己定义的字符集</div><div class="line">xhr.overrideMimeType(&apos;text/plain; charset=x-user-defined&apos;);</div><div class="line"></div><div class="line">xhr.onreadystatechange = function(e) &#123;</div><div class="line">  if (this.readyState == 4 &amp;&amp; this.status == 200) &#123;</div><div class="line">    //通过 responseText 来获取图片文件对应的二进制字符串</div><div class="line">    var binStr = this.responseText;</div><div class="line">    //然后自己再想方法将逐个字节还原为二进制数据</div><div class="line">    for (var i = 0, len = binStr.length; i &lt; len; ++i) &#123;</div><div class="line">      var c = binStr.charCodeAt(i);</div><div class="line">      //String.fromCharCode(c &amp; 0xff);</div><div class="line">      var byte = c &amp; 0xff; </div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">xhr.send();</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xhr.overrideMimeType(&quot;text/plain; charset=x-user-defined&quot;);</div></pre></td></tr></table></figure>
<p>然后，用responseText属性接收服务器返回的二进制数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">　　var binStr = xhr.responseText;</div></pre></td></tr></table></figure></p>
<p>由于这时，浏览器把它当做文本数据，所以还必须再一个个字节地还原成二进制数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">　　for (var i = 0, len = binStr.length; i &lt; len; ++i) &#123;</div><div class="line">　　　　var c = binStr.charCodeAt(i);</div><div class="line">　　　　var byte = c &amp; 0xff;</div><div class="line">　　&#125;</div></pre></td></tr></table></figure></p>
<p>最后一行的位运算”c &amp; 0xff”，表示在每个字符的两个字节之中，只保留后一个字节，将前一个字节扔掉。原因是浏览器解读字符的时候，会把字符自动解读成Unicode的0xF700-0xF7ff区段。</p>
<h3 id="进度事件"><a href="#进度事件" class="headerlink" title="进度事件"></a>进度事件</h3><p>新版本的XMLHttpRequest对象，传送数据的时候，有一个progress事件，用来返回进度信息。</p>
<ul>
<li>load事件：接收到完整的响应数据时触发。</li>
<li>abort事件：传输被用户终止。</li>
<li>error事件：传输中出现错误。</li>
<li>loadstart事件：传输开始。</li>
<li>loadEnd事件：传输结束，但是不知道成功还是失败。</li>
<li>progress事件： 在接受响应期间不断触发。<br>它分成上传和下载两种情况。下载的progress事件属于XMLHttpRequest对象，上传的progress事件属于XMLHttpRequest.upload对象。<br>我们先定义progress事件的回调函数。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">xhr.onprogress = updateProgress;</div><div class="line">xhr.upload.onprogress = updateProgress;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>然后，在回调函数里面，使用这个事件的一些属性。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">　<span class="function"><span class="keyword">function</span> <span class="title">updateProgress</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">　　　　<span class="keyword">if</span> (event.lengthComputable) &#123;</div><div class="line">　　　　　　<span class="keyword">var</span> percentComplete = event.loaded / event.total;</div><div class="line">　　　　&#125;</div><div class="line">　　&#125;</div></pre></td></tr></table></figure></p>
<p>上面的代码中，event.total是需要传输的总字节，event.loaded是已经传输的字节。如果event.lengthComputable不为真，则event.total等于0。</p>
<h3 id="指定响应格式"><a href="#指定响应格式" class="headerlink" title="指定响应格式"></a>指定响应格式</h3><p>让我们利用 <code>XMLHttpRequest</code> 新增的 <code>responseType</code> 和 <code>response</code> 属性，告知浏览器我们希望返回什么格式的数据。</p>
<ul>
<li>xhr.responseType<br>在发送请求前，根据您的数据需要，将 xhr.responseType 设置为“text”、“arraybuffer”、“blob”或“document”。请注意，设置（或忽略）xhr.responseType = ‘’ 会默认将响应设为“text”。</li>
<li>xhr.response<br>成功发送请求后，xhr 的响应属性会包含 DOMString、ArrayBuffer、Blob 或 Document 形式（具体取决于 responseTyp 的设置）的请求数据。<br>凭借这个优秀的新属性，我们可以修改上一个示例：以 ArrayBuffer 而非字符串的形式抓取图片。将缓冲区移交给 BlobBuilder API 可创建 Blob：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;script src=&quot;http://cdn.bootcss.com/jquery/1.11.1/jquery.min.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;div id=&quot;showImg&quot;&gt;&lt;/div&gt;</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">url = <span class="string">"1.jpg"</span>;<span class="comment">//对应的图片路径</span></div><div class="line">xhr.open(<span class="string">'GET'</span>, url, <span class="literal">true</span>);</div><div class="line"><span class="comment">//可以将`xhr.responseType`设置为`"blob"`也可以设置为`" arrayBuffer"`</span></div><div class="line"><span class="comment">//xhr.responseType = 'arrayBuffer';</span></div><div class="line">xhr.responseType = <span class="string">'blob'</span>;</div><div class="line"></div><div class="line">xhr.onload = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.status == <span class="number">200</span>) &#123;</div><div class="line">    <span class="keyword">var</span> blob = <span class="keyword">this</span>.response;</div><div class="line">    <span class="keyword">var</span> img = <span class="built_in">document</span>.createElement(<span class="string">"img"</span>);</div><div class="line">	img.src = <span class="built_in">window</span>.URL.createObjectURL(blob);</div><div class="line">	img.onload = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</div><div class="line"> 		<span class="built_in">window</span>.URL.revokeObjectURL(img.src);   <span class="comment">//有问题，将blob加载到img中 由于blob太大 会有性能影响 应该怎么在加载之后 如何</span></div><div class="line">	&#125;</div><div class="line">	$(<span class="string">"#showImg"</span>).html(img); jQuery方法</div><div class="line">	<span class="comment">//document.getElementById("showImg").appendChild(img); //也可以这么玩，为什么不能直接用innerHTML呢？想想</span></div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><h3 id="IE实现跨域"><a href="#IE实现跨域" class="headerlink" title="IE实现跨域"></a>IE实现跨域</h3><p>```</p>
<h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><p><a href="http://www.cnblogs.com/aaronjs/p/3279314.html" target="_blank" rel="external">http://www.cnblogs.com/aaronjs/p/3279314.html</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[PHP留言板功能以及正则动态修改表单实现]]></title>
      <url>https://zaynex.github.io/2016/09/05/PHP%E7%95%99%E8%A8%80%E6%9D%BF%E5%8A%9F%E8%83%BD%E4%BB%A5%E5%8F%8A%E6%AD%A3%E5%88%99%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9%E8%A1%A8%E5%8D%95%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<h2 id="PHP留言功能"><a href="#PHP留言功能" class="headerlink" title="PHP留言功能"></a>PHP留言功能</h2><p>虽然简单，但是总有你不熟悉的地方。再次感受正则的魅力。<br><a id="more"></a></p>
<h3 id="处理逻辑"><a href="#处理逻辑" class="headerlink" title="处理逻辑"></a>处理逻辑</h3><p>将form表单中的数据传递给doAdd.php进行处理，包括获取表单中不同字段的值并写入到相应的文本中。<br>查看新添加的数据需要用到show.php，读取新写入的文本中的各项值。利用foreach循环遍历数组，呈现数据。<br>删除表单中的数据逻辑在del.php，使用<code>$_GET[id]</code>，再给每个url末尾加上id值，删除。</p>
<h3 id="需要的知识点"><a href="#需要的知识点" class="headerlink" title="需要的知识点"></a>需要的知识点</h3><ol>
<li>文件操作：<br>  <code>file_put_contents</code>(文件名,内容);文件的写入函数(覆盖原有数据)<br>  <code>file_get_contents</code>(文件名);文件内容的读取函数</li>
<li><p>字符串的处理函数<br>  返回数组 <code>explode</code>(分割符，字符串); 将字串拆分成数组的函数<br>  返回字串 <code>implode</code>(分割符，数组); 将数组以指定分割符合并成子串的函数<br>  返回字符串 <code>rtrim(tring $str [, string $character_mask ])</code> ; 删除字符串末端的空白字符（或者其他字符）</p>
</li>
<li><p>数组：<br>  foreach() 遍历数组的<br>  unset（）销毁变量。<br>  $_POST[] 获取传递的form表单<br>  $_SERVER[“REMOTE_ADDR”];获取客户端的ip地址<br>  time(); //获取当前系统的时间戳<br>  date(); 日期转换函数</p>
</li>
</ol>
<h3 id="示例的目录结构"><a href="#示例的目录结构" class="headerlink" title="示例的目录结构"></a>示例的目录结构</h3><p>===================<br>    |–index.php 添加留言信息界面<br>    |<br>    |–doAdd.php 获取留言信息，并执行添加操作的php文件<br>    |<br>    |–show.php  显示留言信息的界面<br>    |<br>    |–del.php     执行删除留言信息的php文件<br>    |<br>    |–liuyan.txt 用于储存留言信息的文件<br>    |<br>    |–menu.php  留言信息的导航栏</p>
<h2 id="正则匹配动态修改表单"><a href="#正则匹配动态修改表单" class="headerlink" title="正则匹配动态修改表单"></a>正则匹配动态修改表单</h2><h3 id="相关的知识点"><a href="#相关的知识点" class="headerlink" title="相关的知识点"></a>相关的知识点</h3><pre><code>正表达式：
    preg_match_all -- 进行全局正则表达式匹配
    preg_replace -- 执行正则表达式的搜索和替换

文件的读和写
    file_put_contents--文件写入函数
    file_get_contents()--文件读取信息函数
</code></pre><h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><pre><code>1.准备好一个配置文件：dbconfig.php

2. 定义一个edit.php，配置文件信息的编辑界面
    a 读取配置文件的信息
    b 使用正则表达式解析配置文件的信息
    c 遍历解析后的信息，并输出到修改表单中

3. 定义一个doupdate.php执行配置文件信息的修改操作
    （使用正则替换方式）
</code></pre><h3 id="核心代码"><a href="#核心代码" class="headerlink" title="核心代码"></a>核心代码</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//doupdae.php逻辑</span></div><div class="line"></div><div class="line"><span class="comment">//1. 读取配置文件的信息</span></div><div class="line">$info = file_get_contents(<span class="string">"dbconfig.php"</span>);</div><div class="line"><span class="comment">//2.对POST遍历，并对配置文件信息进行正则替换</span></div><div class="line"><span class="keyword">foreach</span>($_POST <span class="keyword">as</span> $k=&gt;$v)&#123;</div><div class="line">	$info = preg_replace(<span class="string">"/define\(\"&#123;$k&#125;\",\".*?\"\)/"</span>,<span class="string">"define(\"&#123;$k&#125;\",\"&#123;$v&#125;\")"</span>,$info);</div><div class="line">&#125;</div><div class="line"><span class="comment">//3. 将替换后的信息写回到配置文件中</span></div><div class="line">file_put_contents(<span class="string">"dbconfig.php"</span>,$info);</div><div class="line"></div><div class="line"><span class="keyword">echo</span> <span class="string">"&lt;h2&gt;修改成功！&lt;/h2&gt;"</span>;</div><div class="line"><span class="keyword">echo</span> <span class="string">"&lt;a href='edit.php'&gt;返回&lt;/a&gt;"</span>;</div></pre></td></tr></table></figure>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>edit.php从文件中读取数据呈现，用户在表单上修改的数据传递给doupdate.php。doupdate.php进行匹配，将读取中的数据利用正则表达式进行修改到原先的文件中。（先读取原文本，正则匹配后将新数据写入该文本）<br>对于删除部分的ID，是自己在url末尾添加再获取进行删除的。<br>对于正则匹配，<code>.*?</code>是贪婪匹配，匹配到最小项就结束。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[表单操作之autocomplete中off失效问题]]></title>
      <url>https://zaynex.github.io/2016/08/29/%E8%A1%A8%E5%8D%95%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<p><img src="http://img.blog.csdn.net/20160805155838408?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="iamge"><br>还是网易大法好！<br><a id="more"></a></p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我们在表单输入框中输入信息，提交表单后，当我们再次进入表单页面，双击输入框时，会出现之前提交的信息，这是因为浏览器一般会记录下输入框之前提交表单的信息。这就是这篇文章要讲的autocomplete.</p>
<p>AutoComplete控件就是指用户在文本框输入前几个字母或是汉字的时候，该控件就能从存放数据的文本或是数据库里将所有以这些字母开头的数据提升给用户，供用户选择，提供方便。</p>
<p>输入框<code>input，textarea, select</code>的<code>AutoComplete</code>的默认值是<code>on</code>，其含义代表是否让浏览器自动记录之前输入的值。</p>
<p>有时用户不希望记录之前输入的值，这时就需要关闭AutoComplete。</p>
<h3 id="向form表单添加属性"><a href="#向form表单添加属性" class="headerlink" title="向form表单添加属性"></a>向form表单添加属性</h3><p>我们通过在<code>form</code>表单上加入，或者对一些输入框单独加入<code>autocomplete=&quot;off&quot;</code>，就能达到关闭AutoComplete的目的。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"demo.asp"</span> <span class="attr">method</span>=<span class="string">"get"</span> <span class="attr">autocomplete</span>=<span class="string">"off"</span>&gt;</span></div><div class="line">First name:<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"fname"</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></div><div class="line">Last name: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"lname"</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></div><div class="line">E-mail: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"email"</span> <span class="attr">name</span>=<span class="string">"email"</span> <span class="attr">autocomplete</span>=<span class="string">"off"</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> /&gt;</span></div></pre></td></tr></table></figure></p>
<h3 id="向input等输入框添加属性"><a href="#向input等输入框添加属性" class="headerlink" title="向input等输入框添加属性"></a>向input等输入框添加属性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;input id=&quot;username&quot; type=&quot;text&quot; name=&quot;username&quot; maxlength=&quot;20&quot;  autocomplete=&quot;off&quot;&gt;</div></pre></td></tr></table></figure>
<p>表单中有<code>input[type=&quot;password&quot;]</code>，点击保存密码后，在Chrome浏览器则自动填充了用户名和密码的输入框，而IE和Firefox则不同。为了统一浏览器样式，我们需要就Chrome的问题修改。</p>
<p>以下是本章的重点，如何兼容浏览器出现的这个问题？</p>
<h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><p>在不需要默认填写的input框中设置<code>autocomplete=&quot;new-password&quot;</code><br>网易邮箱就是采用这种方式。<br><img src="http://img.blog.csdn.net/20160805155838408?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="iamge"></p>
<h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;input style=&quot;display:none&quot; type=&quot;text&quot; name=&quot;fakeusernameremembered&quot;/&gt;</div><div class="line">&lt;input style=&quot;display:none&quot; type=&quot;password&quot; name=&quot;fakepasswordremembered&quot;/&gt;</div></pre></td></tr></table></figure>
<p>参考地址：<br>1.<a href="http://stackoverflow.com/questions/15738259/disabling-chrome-autofill/29582380#29582380" target="_blank" rel="external">http://stackoverflow.com/questions/15738259/disabling-chrome-autofill/29582380#29582380</a><br>2.<a href="http://blog.csdn.net/xw505501936/article/details/52129579" target="_blank" rel="external">http://blog.csdn.net/xw505501936/article/details/52129579</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript面向对象编程读书笔记一]]></title>
      <url>https://zaynex.github.io/2016/08/28/JavaScript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%80/</url>
      <content type="html"><![CDATA[<p><img src="http://pic.baike.soso.com/p/20140126/20140126154707-1231041852.jpg" alt="image"><br><a id="more"></a></p>
<h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><p>没有块级作用域，只有函数作用域，所以for循环或者是if后这样的代码块中的变量，在代码块之外依然是可以见的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	local = <span class="number">10</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//console.log(local);//local is not defined</span></div><div class="line">f();</div><div class="line"><span class="built_in">console</span>.log(local); <span class="comment">// 10</span></div></pre></td></tr></table></figure></p>
<p>在这段代码中，f函数调用之前，<code>local</code>变量是不存在的，该变量会在函数首次被调用时创建，并赋予全局作用域。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">123</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	alert(a);<span class="comment">//undefined</span></div><div class="line">	<span class="keyword">var</span> a = <span class="number">1</span>;</div><div class="line">	alert(a);<span class="comment">//1</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">f();</div></pre></td></tr></table></figure>
<p>函数域优于全局域，所以局部变量<code>a</code>会覆盖掉所有与它同名的全局变量，尽管<code>alert()</code>第一次被调用时，<code>a</code>还没有被正式定义。但该变量本身已经存在于本地空间了。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="number">123</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	alert(a);<span class="comment">//123</span></div><div class="line">	a = <span class="number">1</span>;</div><div class="line">	alert(a);<span class="comment">//1</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">f();</div></pre></td></tr></table></figure></p>
<p>当<code>a</code>都定义全局变量时，正常解析。</p>
<h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><ul>
<li>可以将匿名函数作为参数传递完成其他函数，接受放函数就嫩利用我们所传递的函数完成一些事情</li>
<li>定义某个匿名函数来执行某些一次性任务</li>
</ul>
<h4 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">invoke_and_add</span>(<span class="params">a,b</span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> a() + b();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">one</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">two</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="number">2</span>;</div><div class="line">&#125;</div><div class="line">invoke_and_add(one, two);</div><div class="line"></div><div class="line"><span class="comment">//也可以使用匿名函数来代替</span></div><div class="line"><span class="built_in">console</span>.log(invoke_and_add(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="number">1</span>;&#125;, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="number">2</span>&#125;))</div></pre></td></tr></table></figure>
<h4 id="回调函数的优势"><a href="#回调函数的优势" class="headerlink" title="回调函数的优势"></a>回调函数的优势</h4><ul>
<li>在不做命名的情况下传递函数</li>
<li>将一个函数调用操作委托给另一个函数</li>
</ul>
<h4 id="回调实例"><a href="#回调实例" class="headerlink" title="回调实例"></a>回调实例</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//不用回调函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiplyByTwo</span>(<span class="params">a, b, c</span>)</span>&#123;</div><div class="line">	<span class="keyword">var</span> i,ar = [];</div><div class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</div><div class="line">		ar[i] = <span class="built_in">arguments</span>[i] * <span class="number">2</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> ar;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">addOne</span>(<span class="params">a</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> a + <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> myarr = [];</div><div class="line">myarr = multiplyByTwo(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>);</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</div><div class="line">	myarr[i]  = addOne(myarr[i]);</div><div class="line">&#125;</div><div class="line">myarr;</div><div class="line"><span class="comment">//21,41,61;</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//使用回调函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiplyByTwoCall</span>(<span class="params">a, b, c, callback</span>)</span>&#123;</div><div class="line">	<span class="keyword">var</span> i, ar = [];</div><div class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</div><div class="line">		ar[i] = callback(<span class="built_in">arguments</span>[i] * <span class="number">2</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> ar;</div><div class="line">&#125;</div><div class="line">myarr = multiplyByTwoCall(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, addOne);</div><div class="line">myarr;</div><div class="line"><span class="comment">//21,41,61;</span></div></pre></td></tr></table></figure>
<p>还可以使用匿名函数代替<code>addOne()</code>，这样做可以省去额外的全局变量。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">myarr = multiplyByTwoCall(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;	<span class="keyword">return</span> a + <span class="number">1</span>;&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="自调函数"><a href="#自调函数" class="headerlink" title="自调函数"></a>自调函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">	alert(<span class="string">'Hi '</span> + name + <span class="string">'!'</span>);</div><div class="line">&#125;)(<span class="string">'Zaynex'</span>);</div></pre></td></tr></table></figure>
<p>这种方式会立即执行，并且不会产生任何全局变量，适合执行某些<code>一次性或初始化的任务</code>。</p>
<h3 id="私有函数"><a href="#私有函数" class="headerlink" title="私有函数"></a>私有函数</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">parm</span>)</span>&#123;</div><div class="line">	<span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params">theinput</span>)</span>&#123;</div><div class="line">		<span class="keyword">return</span> theinput*<span class="number">2</span>;</div><div class="line">	&#125;;</div><div class="line">	<span class="keyword">return</span> <span class="string">'The result is:'</span> + b(parm);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">a(<span class="number">2</span>);<span class="comment">//4</span></div><div class="line">b(<span class="number">2</span>);<span class="comment">//b is not defined</span></div></pre></td></tr></table></figure>
<p>当调用全局函数<code>a()</code>时，本地函数<code>b()</code>也会在其内部被调用，但由于<code>b()</code>是本地函数，它在<code>a()</code>以外的地方是不可见的，称之为私有函数。</p>
<ul>
<li>有助于保存全局名字空间的纯净性</li>
<li>私有性，避免暴露给外界使用。</li>
</ul>
<h3 id="返回函数的函数"><a href="#返回函数的函数" class="headerlink" title="返回函数的函数"></a>返回函数的函数</h3><p>函数始终都有返回值，隐式返回<code>undefined</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	alert(<span class="string">'A'</span>);</div><div class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		alert(<span class="string">'B'</span>);</div><div class="line">	&#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> newFunc = a();</div><div class="line">newFunc();</div></pre></td></tr></table></figure>
<p>如果您希望返回的函数立即执行，可以不用将它赋值给变量，直接在该调用后加一对括号即可。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">a()();</div></pre></td></tr></table></figure></p>
<h3 id="重写自己的函数"><a href="#重写自己的函数" class="headerlink" title="重写自己的函数"></a>重写自己的函数</h3><p>第一次调用函数后重写自己，避免每次重复调用不必要的操作，对于某些一次性初始化工作的函数非常有用<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	alert(<span class="string">'A'</span>);</div><div class="line">	a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		alert(<span class="string">"B"</span>);</div><div class="line">	&#125;;</div><div class="line">&#125;</div><div class="line">a();<span class="comment">//A</span></div><div class="line">a();<span class="comment">//B</span></div><div class="line">a();<span class="comment">//B</span></div></pre></td></tr></table></figure></p>
<p>第一次执行 A；<br>第二次调用时a被重新定义 执行B<br>（这个在javascript高级程序设计中也有提到，当存在多个if语句来判断函数执行代码段时可以利用这种方式，以后再次调用该函数时就不需要再判断了）</p>
<h4 id="组合应用"><a href="#组合应用" class="headerlink" title="组合应用"></a>组合应用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var a = function()&#123;</div><div class="line">	function someSetup()&#123;</div><div class="line">		var setup = &apos;done&apos;;</div><div class="line">	&#125;</div><div class="line">	function actualWork()&#123;</div><div class="line">		alert(&quot;Worky-worky&quot;);</div><div class="line">	&#125;</div><div class="line">	someSetup();</div><div class="line">	return actualWork;</div><div class="line">&#125;();</div></pre></td></tr></table></figure>
<p>自调函数、私有函数、返回函数的引用（注意，不是产生函数调用）、重写函数。<br>这就是<code>浏览器特性探测</code>技术的核心代码。</p>
<h3 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h3><p>每个函数在定义时（非执行时）都会创建一个属于自己的环境（作用域）。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> a = <span class="number">10</span>;</div><div class="line">	f2();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> a;</div><div class="line">&#125;</div><div class="line">f1(); <span class="comment">//  a is not defined</span></div></pre></td></tr></table></figure></p>
<p>虽然f2函数在f1中，但是因为在定义的时候，f2中的变量a是不可见的，而f1只能访问自身作用域以及全局作用域，与f2之间不存在共享的词法作用域。</p>
<p>尽管当函数被定义时，它会记录自身所在的环境和相关的作用域链，但并不意味着函数也会对其作用域中个的每一个变量进行记录，函数只会看到变量的最终状态。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a =<span class="number">100</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">var</span> a = <span class="number">10</span>;</div><div class="line">	f2();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="built_in">console</span>.log(a);</div><div class="line">&#125;</div><div class="line">f1();</div><div class="line"><span class="comment">// 100</span></div></pre></td></tr></table></figure>
<p>在f2中a变量来自全局作用域，它记录的a的最终状态为100。这里有个奇怪的地方，如果是var a,那么delete无效，如果是直接a = 10.那么delete有效。</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>一个函数需要在其父级函数返回之后留住对父级作用域的链接，就必须要使用闭包。</p>
<h4 id="闭包1"><a href="#闭包1" class="headerlink" title="闭包1"></a>闭包1</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">var</span> b = <span class="string">"b"</span>;</div><div class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="keyword">return</span> b;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">b;<span class="comment">//b is not defined</span></div><div class="line"><span class="keyword">var</span> n = f();</div><div class="line">f();</div><div class="line">n(); <span class="comment">// "b"</span></div></pre></td></tr></table></figure>
<p>因为b是局部变量，所以在外部是无法访问到的。<br>我们将f()函数返回的结果保存给一个全局变量n，就可以生成一个可以访问f()私有空间的新全局函数了。</p>
<h4 id="闭包2"><a href="#闭包2" class="headerlink" title="闭包2"></a>闭包2</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> n;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">var</span> b = <span class="string">"b"</span>;</div><div class="line">	n = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="keyword">return</span> b;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">n();<span class="comment">//"b"</span></div></pre></td></tr></table></figure>
<p>由于n()是在f()内部定义的，它可以访问f()的作用域。该函数成了全局函数之后，依然保存着对f()作用域的访问权。</p>
<h4 id="闭包3"><a href="#闭包3" class="headerlink" title="闭包3"></a>闭包3</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">arg</span>)</span>&#123;</div><div class="line">	<span class="keyword">var</span> n = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="keyword">return</span> arg;</div><div class="line">	&#125;</div><div class="line">	arg++;</div><div class="line">	<span class="keyword">return</span> n;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> m = f(<span class="number">123</span>);</div><div class="line">m();<span class="comment">//124</span></div></pre></td></tr></table></figure>
<p>请注意，当我们的函数n被调用时，arg++已经经过一次递增操作了。所以M返回的是更新后的值。由此看出：<br><strong>函数绑定的是作用域本身，而不是该作用域中的变量或变量当前所返回的值。</strong></p>
<h4 id="循环中的闭包"><a href="#循环中的闭包" class="headerlink" title="循环中的闭包"></a>循环中的闭包</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">var</span> a = [];</div><div class="line">	<span class="keyword">var</span> i;</div><div class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++) &#123;</div><div class="line">		a[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">			<span class="keyword">return</span> i;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> a;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a = f();</div><div class="line">a[<span class="number">0</span>]();</div><div class="line">a[<span class="number">1</span>]();</div><div class="line">a[<span class="number">2</span>]();</div></pre></td></tr></table></figure>
<p>我们所创建的3个闭包都指向了同一个i。但是闭包不会记录它们的值，它们所拥有的都是一个i的链接，因此只能返回i的当前值。由于循环结束后i的值时3.所以三个函数都指向了一个共同值。</p>
<h4 id="优雅的解决方案"><a href="#优雅的解决方案" class="headerlink" title="优雅的解决方案"></a>优雅的解决方案</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">var</span> a = [];</div><div class="line">	<span class="keyword">var</span> i;</div><div class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++) &#123;</div><div class="line">		a[i] = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</div><div class="line">			<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">				<span class="keyword">return</span> x;</div><div class="line">			&#125;</div><div class="line">		&#125;(i)</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> a;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们将i传递给了一个自调函数，i就被赋值给了局部变量x。</p>
<p>当然还有其他方式，通过内部函数来实现，关键是在每次爹迭代操作中，要在中间函数内将i的值<code>本地化</code>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="function"><span class="keyword">function</span> <span class="title">makeClosure</span>(<span class="params">x</span>) </span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">			<span class="keyword">return</span> x;</div><div class="line">		&#125;;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">var</span> a = [];</div><div class="line">	<span class="keyword">var</span> i;</div><div class="line">	<span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</div><div class="line">		a[i] = makeClosure(i);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">return</span> a;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a = f();</div><div class="line">a[<span class="number">0</span>]();</div></pre></td></tr></table></figure></p>
<h3 id="闭包应用"><a href="#闭包应用" class="headerlink" title="闭包应用"></a>闭包应用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> getValue, setValue;</div><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">var</span> secret = <span class="number">0</span>;</div><div class="line">	getValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="keyword">return</span> secret;</div><div class="line">	&#125;</div><div class="line">	setValue = <span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</div><div class="line">		secret = v;</div><div class="line">	&#125;;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>定义全局变量来确保布局变量secret的不可直接访问性。</p>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">setup</span>(<span class="params">x</span>)</span>&#123;</div><div class="line">	<span class="keyword">var</span> i = <span class="number">0</span>;</div><div class="line">	<span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="keyword">return</span> x[i++];</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> next = setup([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]);</div><div class="line">next();</div></pre></td></tr></table></figure>
<p>定义一个私有指针，该指针始终指向下一个元素。</p>
<h3 id="一些demo"><a href="#一些demo" class="headerlink" title="一些demo"></a>一些demo</h3><p>/<em><br>编写一个将16进制转换为颜色的函数。
 </em>/<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getRBG</span>(<span class="params">str</span>)</span>&#123;</div><div class="line">	<span class="keyword">if</span>(str.length!=<span class="number">7</span>) &#123;</div><div class="line">		alert(<span class="string">"write right as #000000"</span>);</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span>(<span class="regexp">/#(..)(..)(..)/g</span>.test(str)) &#123;</div><div class="line">		rgb = [<span class="built_in">parseInt</span>(<span class="built_in">RegExp</span>.$<span class="number">1</span>, <span class="number">16</span>),<span class="built_in">parseInt</span>(<span class="built_in">RegExp</span>.$<span class="number">2</span>, <span class="number">16</span>),<span class="built_in">parseInt</span>(<span class="built_in">RegExp</span>.$<span class="number">3</span>, <span class="number">16</span>)];</div><div class="line">	&#125;;</div><div class="line">	<span class="keyword">return</span> <span class="string">'rgb('</span>+ rgb.join(<span class="string">","</span>) +<span class="string">')'</span>;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> a = getRBG(<span class="string">"#00ff00"</span>);</div><div class="line">a;</div><div class="line"><span class="comment">//"rgb(0,255,0)"</span></div></pre></td></tr></table></figure></p>
<h3 id="构造器函数"><a href="#构造器函数" class="headerlink" title="构造器函数"></a>构造器函数</h3><p>在创建对象同时也给对象赋予一种特殊的属性——构造器属性，该属性指向一个用于创建该对象的构造器函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Hero</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">	<span class="keyword">this</span>.occupation = <span class="string">'Ninja'</span>;</div><div class="line">	<span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> h2 = <span class="keyword">new</span> Hero(<span class="string">"Zaynex"</span>);</div><div class="line">h2.name;<span class="comment">//Zaynex</span></div><div class="line">h2.constructor; <span class="comment">//Hero(name)</span></div><div class="line"><span class="keyword">var</span> h3 = <span class="keyword">new</span> h2.constructor(<span class="string">"Rafaaello"</span>);</div><div class="line">h3.name;<span class="comment">//Rafaaello</span></div><div class="line"></div><div class="line"><span class="keyword">typeof</span> h2.constructor</div><div class="line"><span class="comment">//function</span></div></pre></td></tr></table></figure></p>
<h3 id="返回对象的函数"><a href="#返回对象的函数" class="headerlink" title="返回对象的函数"></a>返回对象的函数</h3><p>除了new操作符来调用构造器函数以外，也可以抛开new操作符，只用一般函数来创建对象，这就需要一个能执行预备工作并以对象为返回值的函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function factory(name) &#123;</div><div class="line">	return &#123;</div><div class="line">		name: name</div><div class="line">	&#125;;</div><div class="line">&#125;</div><div class="line">var o = factory(&apos;Zaynex&apos;);</div><div class="line">o.name;</div></pre></td></tr></table></figure></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">C</span>(<span class="params"></span>)</span>&#123;</div><div class="line">	<span class="keyword">this</span>.a = <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> C():</div><div class="line">c.a;<span class="comment">// 1;</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">C2</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="keyword">this</span>.a = <span class="number">1</span>;</div><div class="line">	<span class="keyword">return</span> &#123;b:<span class="number">2</span>&#125;;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> c2 = <span class="keyword">new</span> C2();</div><div class="line">c2.a;<span class="comment">// undefined</span></div><div class="line">c2.b;</div></pre></td></tr></table></figure>
<p>这里的构造器返回的不是包含属性a的this对象，而是另一个包含属性b的对象。<br>在函数的返回值是一个对象时才会发生这种情况。当我们企图返回一个<code>非对象类型</code>时，该构造器会照常返回this。</p>
<h3 id="传递对象"><a href="#传递对象" class="headerlink" title="传递对象"></a>传递对象</h3><p>当我们拷贝某个对象或者将它传递给某个函数时，传递的往往是对象的一个引用。因此在引用上做任何的修改都会影响所引用的原对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> original = &#123;hotway:<span class="number">1</span>&#125;;</div><div class="line"><span class="keyword">var</span> copy = original;</div><div class="line">copy.hotway;<span class="comment">//1</span></div><div class="line">copy.hotway = <span class="number">100</span>;</div><div class="line">original.hotway;<span class="comment">//100;</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> nullify = <span class="function"><span class="keyword">function</span>(<span class="params">o</span>) </span>&#123;o.hotway = <span class="number">0</span>&#125;</div><div class="line">nullify(original);</div><div class="line">original.hotway;<span class="comment">//0</span></div></pre></td></tr></table></figure></p>
<h3 id="对象比较"><a href="#对象比较" class="headerlink" title="对象比较"></a>对象比较</h3><p>当且仅当两个引用指向同一个对象时为true。</p>
<h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [];</div><div class="line"><span class="keyword">typeof</span> a; <span class="comment">//object</span></div><div class="line">a.constructor; <span class="comment">// function Array();</span></div><div class="line">a.constructor();<span class="comment">//Array[];</span></div></pre></td></tr></table></figure>
<h3 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFunc</span>(<span class="params">a</span>) </span>&#123;</div><div class="line">	<span class="keyword">return</span> a;</div><div class="line">&#125;</div><div class="line">myFunc.constructor;<span class="comment">//function Function();</span></div><div class="line">myFunc.constructor();<span class="comment">// function() anonymous()</span></div></pre></td></tr></table></figure>
<h4 id="caller"><a href="#caller" class="headerlink" title="caller"></a>caller</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> A.caller&#125;;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> A();&#125;;</div><div class="line">B();</div><div class="line"><span class="comment">//function B();</span></div></pre></td></tr></table></figure>
<p>这个属性会返回一个调用该函数对象的外层函数引用。<br>如果是在全局作用域调用A().(也就是说没有任何外层函数) 就会返回null<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">A();//null</div></pre></td></tr></table></figure></p>
<h3 id="Function对象方法"><a href="#Function对象方法" class="headerlink" title="Function对象方法"></a>Function对象方法</h3><p>所有Function对象方法都继承自父级对象Object的。</p>
<h3 id="argument-callee"><a href="#argument-callee" class="headerlink" title="argument.callee"></a>argument.callee</h3><p>该属性引用的是当前辈调用的函数对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">(</div><div class="line">	<span class="function"><span class="keyword">function</span> (<span class="params">count</span>)</span>&#123;</div><div class="line">		<span class="keyword">if</span>(count &lt; <span class="number">5</span>)&#123;</div><div class="line">			alert(count);</div><div class="line">			<span class="built_in">arguments</span>.callee(++count);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">)(<span class="number">1</span>)</div></pre></td></tr></table></figure></p>
<p>alert()窗口显示1-2-3-4</p>
<h3 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> b1 = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">true</span>);</div><div class="line">b1.valueOf();<span class="comment">//true</span></div><div class="line"><span class="keyword">var</span> b2 = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>);</div><div class="line">b2.valueOf();<span class="comment">//false</span></div><div class="line"><span class="built_in">Boolean</span>(b1);</div><div class="line"><span class="built_in">Boolean</span>(b2);<span class="comment">//true</span></div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[给你两块表，你还能清楚现在是几点吗？]]></title>
      <url>https://zaynex.github.io/2016/08/27/%E7%BB%99%E4%BD%A0%E4%B8%A4%E5%9D%97%E8%A1%A8%EF%BC%8C%E4%BD%A0%E8%BF%98%E8%83%BD%E6%B8%85%E6%A5%9A%E7%8E%B0%E5%9C%A8%E6%98%AF%E5%87%A0%E7%82%B9%E5%90%97%EF%BC%9F/</url>
      <content type="html"><![CDATA[<p>最近在学习上有所懈怠。每次学一段时间总会有一种质疑的心态，这样学习的方式是否正确？是否还有更好的学习方法？是否还有捷径可走？是否…</p>
<p>一千个人有一千个哈姆雷特。每当心中疑惑的时候，询问他人的意见是正确的，但找得过多反而越来越迷失自己，因为你会发现，每个人的答案都那么得给人光明，而答案背后，你又是否真正看到了些什么？</p>
<p>往往大多数，不是我们不知道该怎么做，而是花了太多时间在苦苦追寻一个答案：自己做的是否是有意义的，有前途的。</p>
<p>当你费尽心思去寻找答案的时候，你就已经失去了最终答案，它会告诉你，根本不是如众人所说的那般美好。</p>
<p>为什么？</p>
<p>因为你没有花时间去证明答案是正确的，而仅仅不断在别人的身上证明答案是正确的。</p>
<p>这个角度而言，世界上就分两类人；<br>一类人很努力得去证明自己，实现自己的价值；另一类人很努力得看别人如何证明自己，实现自己的价值是对的。</p>
<p>迷茫的时候就想要寻找答案，究竟是谁得到了答案了呢？</p>
<p>在成长的路上会有各种各样的答案，你所认为的答案是正确的，他人所理解的答案也是正确的。</p>
<p>其实，这个世界上根本不需要什么答案，只要做好你认为该做的事情，时间就会给你预期的答案。</p>
<p>如果只有一块表，你能非常明确现在是几点，但是如果有两块表，你能马上告诉我现在是几点吗？</p>
<p>别在意，人生本来就有无数个解，就麻烦你坚持下去，坚持下去，认定就别回头的死磕精神，去找到自己的钥匙吧。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[你真的懂margin:0 auto吗]]></title>
      <url>https://zaynex.github.io/2016/08/27/%E4%BD%A0%E7%9C%9F%E7%9A%84%E6%87%82margin-0-auto%E5%90%97/</url>
      <content type="html"><![CDATA[<p>转自玉伯曾经<a href="https://github.com/lifesinger/blog/issues/105" target="_blank" rel="external">博客</a>。<br><a id="more"></a><br>而关于<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">width:980px;</div><div class="line">margin:0 atuo;</div></pre></td></tr></table></figure></p>
<p>以及<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">width: 980px;</div><div class="line">margin-left: auto;</div><div class="line">margin-right: auto;</div></pre></td></tr></table></figure></p>
<p>区别的灵感来自<a href="www.imooc.com">慕课网</a>的学习。</p>
<h2 id="感谢他们！"><a href="#感谢他们！" class="headerlink" title="感谢他们！"></a>感谢他们！</h2><p>博客原文</p>
<p>看到克军这条微博后的一天，我就在思索最牛逼的HTML代码有了，那么最牛逼的CSS代码是什么呢？仔细搜寻了一番记忆，于是有了这条微博：</p>
<p>贴一个我见过的写得最好的 CSS 代码,可以想想好在哪。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">.content &#123; width: 980px; margin-left: auto; margin-right: auto; &#125;</div></pre></td></tr></table></figure></p>
<p>算是抖个包袱，早上发完之后，就秋游去了。玩了一天，看看回复，还是挺有意思的，有少数几个回复已经说出了我想说的。其实大部分在上面说最牛逼的HTML时已经说了，但还得说明下：</p>
<ol>
<li>这跟性能没关。怎么老有人喜欢“性能思维”呢？在前端代码里，大部分性能问题都是扯淡。</li>
<li>这跟 980px 没关。栅格年代已经远去了，960 不是 magic number.<br>这段代码的作用，是个前端都能看懂：让块元素水平居中。一般大家都会写成：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">.content &#123;</div><div class="line">  width: 980px;</div><div class="line">  margin: 0 auto;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>上面的代码能正常工作，大部分情况下也不会有问题，但上面的代码存在<code>思维的懒惰</code>。写成:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">.content &#123;</div><div class="line">  width: 980px;</div><div class="line">  margin-left: auto;</div><div class="line">  margin-right auto;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>看起来代码变多了，变啰嗦了。但如果你真经过思考，就会明白：</p>
<ol>
<li><code>margin: 0 auto</code>中的 0 绝大部分情况下是冗余的，页面上早就有 reset.css 或 normalize.css 重置过</li>
<li><code>margin: 0 auto</code>不纯粹，你要的是“水平居中”，却顺便把 top / bottom 给重置了</li>
<li>不纯粹会导致顺序和优先级的依赖，比如有另一处要给 margin-top/bottom 赋值时，就必须要提高优先级</li>
</ol>
<p>进一步的东西是，我一直觉得CSS里，有一个重要的原则：<br>最小影响原则</p>
<p>你在写某段CSS代码时，首先要非常清楚地知道这段CSS代码的功能，其次要尽量严格保障这段CSS代码只实现了你想要实现的功能。</p>
<p>这就如医生动手术，好好做好本分就行，千万别留下一个小镊子在病人身体里。</p>
<p>与HTML代码一样，对CSS代码来说，很重要的两个衡量标准也是稳定和灵活。这里不多说了。</p>
<p>熟悉设计模式的，应该会感知到，最小影响原则和单一职责原则（SRP）本质上是一样的。SRP 作为设计模式的重要原则之一，其重要性不用我在此啰嗦了。</p>
<p>最后想说下下面这段代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;mod&quot;&gt;</div><div class="line">	&lt;div class=&quot;tr&quot;&gt;</div><div class="line">		&lt;div class=&quot;tl&gt;</div><div class="line">			&lt;div class=&quot;tc&quot;&gt;&lt;/div&gt;</div><div class="line">		&lt;/div&gt;</div><div class="line">	&lt;/div&gt;</div><div class="line"></div><div class="line">	&lt;div class=&quot;mr&quot;&gt;</div><div class="line">		&lt;div class=&quot;ml&quot;&gt;</div><div class="line">			&lt;div class=&quot;mc&quot;&gt;&lt;/div&gt;</div><div class="line">		&lt;/div&gt;</div><div class="line">	&lt;/div&gt;</div><div class="line"></div><div class="line">	&lt;div class=&quot;br&quot;&gt;</div><div class="line">		&lt;div class=&quot;bl&gt;</div><div class="line">			&lt;div class=&quot;bc&quot;&gt;&lt;/div&gt;</div><div class="line">		&lt;/div&gt;</div><div class="line">	&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>好像还有人做过九宫格布局……<br>以及最近在 KISSY 开发群里的一段文字：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">我发现DataLazyload有两个问题：</div><div class="line">1.判断节点是否已经在视图之中的时间简单的判断Dom.offset,没有考虑到节点或者上级节点被隐藏的现象</div><div class="line">2.如果页面上脚本自动显示、隐藏或更改一些层的大小，引起某些层从视图外移动到视图类，DataLazyload既没有自己判断这种情况，也没有提供接口来重新执行loadItems</div></pre></td></tr></table></figure></p>
<p>很多DPL了做着做着，很多类库组件开发着开发着，都很容易被诱惑着去“满足所有需求”，去“解决所有bug”……</p>
<p>如何权衡简单与复杂？如何在复杂中依旧能保持简单？没bug的组件是好组件吗？究竟什么是好组件？</p>
<p>然后，没有然后了……</p>
<hr>
<p>虽然还是个菜鸟，但是想要写好可维护可拓展的html和css也绝非易事。平时也不要忽略对这方面的学习。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[PHPGD库图形图像操作]]></title>
      <url>https://zaynex.github.io/2016/08/23/PHPGD%E5%BA%93%E5%9B%BE%E5%BD%A2%E5%9B%BE%E5%83%8F%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<p><img src="http://note.youdao.com/yws/public/resource/4d20c8e7a27b0ceb585cae1a70ae6c98/xmlnote/WEBRESOURCEe2b617a36828bc602a60b45534e1b255/35157" alt="iamge"><br><a id="more"></a></p>
<h2 id="GD库简介"><a href="#GD库简介" class="headerlink" title="GD库简介"></a>GD库简介</h2><p>GD指的是Graphic Device，PHP的GD库是用来处理图形的扩展库，通过GD库提供的一系列API，可以对图像进行处理或者直接生成新的图片。<br>PHP除了能进行文本处理以外，通过GD库，可以对JPG、PNG、GIF、SWF等图片进行处理。GD库常用在图片加水印，验证码生成等方面。<br>PHP默认已经集成了GD库，只需要在安装的时候开启就行。</p>
<p>查看你的gd库。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print_r(gd_info());</div></pre></td></tr></table></figure></p>
<h2 id="使用流程"><a href="#使用流程" class="headerlink" title="使用流程"></a>使用流程</h2><p>1、创建画布<br>2、创建各种颜料<br>3、绘画（如写字，画线，画矩形等形状）<br>4、保存成图片<br>5、清理战场，销毁画布</p>
<h3 id="创建画布"><a href="#创建画布" class="headerlink" title="创建画布"></a>创建画布</h3><p>创建画布我们使用imagecreatetruecolor()函数，函数的返回值为一个句柄或者称为资源，类似连接myslq数据库的返回值。<br>这个函数需要两个参数，x_size和y_size。用白话来讲就是画布的长和宽！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$width = 300;</div><div class="line">$height = 200;</div><div class="line">$im = imagecreatetruecolor($width,$height);</div></pre></td></tr></table></figure></p>
<h3 id="创建各种颜料"><a href="#创建各种颜料" class="headerlink" title="创建各种颜料"></a>创建各种颜料</h3><p>有了画布，我们就开始第二步，创建颜料。<br>创建颜料使用imagecolorallocate()函数，这个函数需要4个参数。第一个参数就是画布（资源型），剩下的三个就是三基色，RGB的值，从0-255。所有的颜色，都可以使用RGB三种颜色来调配出来，这里也可以使用十六进制的颜色来表示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$red=imagecolorallocate($img, 0xFF,  0x00, 0x00);</div></pre></td></tr></table></figure></p>
<p>上面的例子，创建了一个红色的颜料。</p>
<h3 id="绘画"><a href="#绘画" class="headerlink" title="绘画"></a>绘画</h3><p>有了颜料，有了画布，就可以开始画图了。我们先从最简单的开始，直接用颜料涂满整个画布。<br>imagefill() 函数可以帮助我们来完成涂颜料的工作<br>我们也通过调用绘制线段函数imageline进行线条的绘制，通过指定起点跟终点来最终得到线条。<br>imagefill($img, 0, 0, $red);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">imageline($img, 0, 0, 100, 100, $red);</div><div class="line">imagestring($img,5,0,0,&apos;helloworld&apos;,$red);//绘制文字</div></pre></td></tr></table></figure></p>
<h3 id="保存成图片"><a href="#保存成图片" class="headerlink" title="保存成图片"></a>保存成图片</h3><p>填充完颜色，就可以把结果保存下来了。保存的函数有imagepng，表示保存为png格式，imagejpeg、imagegif，分别保存为不同的格式。<br>第一个参数是画布，第二个参数是要保存的位置，如果第二个参数不给，会直接输出给浏览器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">​imagejpeg($img, $filename, 80);</div></pre></td></tr></table></figure></p>
<p>输出图像文件<br>前面我们已经了解到，通过imagepng可以直接输出图像到浏览器，但是很多时候，我们希望将处理好的图像保存到文件，以便可以多次使用。通过指定路径参数将图像保存到文件中。</p>
<h3 id="释放资源"><a href="#释放资源" class="headerlink" title="释放资源"></a>释放资源</h3><p>文件保存完之后，最后要销毁创建的画布，不然会很占资源。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">imagedestroy($img);</div></pre></td></tr></table></figure></p>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">header(&quot;content-type: image/png&quot;);</div><div class="line">$img=imagecreatetruecolor(100, 100);</div><div class="line">$red=imagecolorallocate($img, 0xFF, 0x00, 0x00);</div><div class="line">//$red后面的三个参数是就rgb值。题目中给的是16进制。颜色是ff,00,00。也就是对应10进制的255, 0，0。是红色。你可以改这三个参数。16进制只要在0到ff之间都可以。比如ff,ff,ff就是白色；00,00,00就是黑色；00ff00就是绿色；0000ff就是蓝色。</div><div class="line">imagefill($img, 0, 0, $red);</div><div class="line">imagepng($img);</div><div class="line">imagedestroy($img);</div></pre></td></tr></table></figure>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="简单的验证码"><a href="#简单的验证码" class="headerlink" title="简单的验证码"></a>简单的验证码</h3><p>简单的验证码其实就是在图片中输出了几个字符，通过我们前面章节讲到的imagestring函数就能实现。</p>
<p>但是在处理上，为了使验证码更加的安全，防止其他程序自动识别，因此常常需要对验证码进行一些干扰处理，通常会采用绘制一些噪点，干扰线段，对输出的字符进行倾斜、扭曲等操作。</p>
<p>可以使用imagesetpixel绘制点来实现噪点干扰，但是只绘制一个点的作用不大，因此这里常常会使用循环进行随机绘制。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">for($i=0;$i&lt;50;$i++) &#123;</div><div class="line">  imagesetpixel($im, rand(0, 100) , rand(0, 100) , $black); </div><div class="line">  imagesetpixel($im, rand(0, 100) , rand(0, 100) , $green);</div><div class="line">&#125; </div><div class="line"></div><div class="line">$img = imagecreatetruecolor(100, 40);</div><div class="line">$black = imagecolorallocate($img, 0x00, 0x00, 0x00);</div><div class="line">$green = imagecolorallocate($img, 0x00, 0xFF, 0x00);</div><div class="line">$white = imagecolorallocate($img, 0xFF, 0xFF, 0xFF);</div><div class="line">imagefill($img,0,0,$white);</div><div class="line">//生成随机的验证码</div><div class="line">$code = &apos;&apos;;</div><div class="line">for($i = 0; $i &lt; 4; $i++) &#123;</div><div class="line">    $code .= rand(0, 9);</div><div class="line">&#125;</div><div class="line">imagestring($img, 5, 10, 10, $code, $black);</div><div class="line">//加入噪点干扰</div><div class="line">for($i=0;$i&lt;50;$i++) &#123;</div><div class="line">  imagesetpixel($img, rand(0, 100) , rand(0, 100) , $black); </div><div class="line">  imagesetpixel($img, rand(0, 100) , rand(0, 100) , $green);</div><div class="line">&#125;</div><div class="line">//输出验证码</div><div class="line">header(&quot;content-type: image/png&quot;);</div><div class="line">imagepng($img);</div><div class="line">imagedestroy($img);</div></pre></td></tr></table></figure>
<h3 id="给图片添加水印"><a href="#给图片添加水印" class="headerlink" title="给图片添加水印"></a>给图片添加水印</h3><p>给图片添加水印的方法一般有两种，一种是在图片上面加上一个字符串，另一种是在图片上加上一个logo或者其他的图片。</p>
<p>因为这里处理的是已经存在的图片，所以可以直接从已存在的图片建立画布，通过imagecreatefromjpeg可以直接从图片文件创建图像。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$im = imagecreatefromjpeg($filename);</div></pre></td></tr></table></figure></p>
<p>创建图像对象以后，我们就可以通过前面的GD函数，绘制字符串到图像上。如果要加的水印是一个logo图片，那么就需要再建立一个图像对象，然后通过GD函数imagecopy将logo的图像复制到源图像中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$logo = imagecreatefrompng($filename);</div><div class="line">imagecopy($im, $logo, 15, 15, 0, 0, $width, $height);</div></pre></td></tr></table></figure></p>
<p>当将logo图片复制到原图片上以后，将加水印后的图片输出保存就完成了加水印处理。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">imagejpeg($im, $filename);</div></pre></td></tr></table></figure></p>
<h3 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$filename = &apos;./tmp.jpg&apos;;</div><div class="line">$im = imagecreatefromjpeg($filename);</div><div class="line">$logo = imagecreatefrompng(&apos;./red.png&apos;);//从当前文件位置下取得该图片</div><div class="line">$size = getimagesize(&apos;./red.png&apos;);</div><div class="line">imagecopy($im, $logo, 15, 15, 0, 0, $size[0], $size[1]); </div><div class="line">header(&quot;content-type:image/jpeg&quot;);</div><div class="line">imagejpeg($im);</div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[MySQL数据操作与约束]]></title>
      <url>https://zaynex.github.io/2016/08/22/MySQL%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E6%93%8D%E4%BD%9C/</url>
      <content type="html"><![CDATA[<p><img src="http://note.youdao.com/yws/public/resource/7d33ba2e58727f9063d9732ffe069a4a/xmlnote/DC419B38AE7647C19E67F1C5FA1C1C60/34970" alt="iamge"><br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">show tables;//查看数据表</div><div class="line">create table name(</div><div class="line">username varchar(20), </div><div class="line">age TINYINT UNSIGNED,</div><div class="line">salary FLOAT(8,2) UNSIGNED</div><div class="line">);</div><div class="line"></div><div class="line">INSERT tb1 VALUES(&apos;ZAYNEX&apos;, 20, 5455.88);</div><div class="line">INSERT tb1(username, salary) VALUES(&apos;ZAYNEX&apos;,6755.44);</div><div class="line">对于默认字段自动填充为null;</div><div class="line">SHOW COLUMNS FORM name;//显示 数据表的分类</div><div class="line">SELECT * from tb1; // 显示整个数据表的数据</div></pre></td></tr></table></figure></p>
<h3 id="空值与非空"><a href="#空值与非空" class="headerlink" title="空值与非空"></a>空值与非空</h3><ul>
<li>NULL，字段值可以为空</li>
<li>NOT NULL，字段值禁止为空</li>
</ul>
<h3 id="AUTO-INCREMENT"><a href="#AUTO-INCREMENT" class="headerlink" title="AUTO_INCREMENT"></a>AUTO_INCREMENT</h3><ul>
<li>自动编号，必须与<strong>主键</strong>组合使用</li>
<li>默认情况下，初始值为1，每次的增量为1</li>
</ul>
<h3 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h3><p>PRIMARY KEY<br><strong>主键(primary key) 能够唯一标识表中某一行的属性或属性组。一个表只能有一个主键，但可以有多个候选索引。主键常常与外键构成参照完整性约束，防止出现数据不一致。主键可以保证记录的唯一和主键域非空,数据库管理系统对于主键自动生成唯一索引，所以主键也是一个特殊的索引。</strong></p>
<h4 id="简单描述"><a href="#简单描述" class="headerlink" title="简单描述"></a>简单描述</h4><p>主键不能重复，就像QQ的用户名，有N个叫“虫zi”的网友，可是他们的QQ号码是不一样的，也就是说真正标识一个QQ的身份是“QQ号码”。<br>不过主键和QQ号不一样，因为一个表只能有一个主键，而一个人可以有多个QQ号，这也是为什么人们喜欢在虚拟世界里面互相忽悠，因为你真的不知道电脑那面坐的是一头猪。</p>
<ul>
<li>每张数据表只能存在一个主键</li>
<li>主键必须保证记录的唯一性</li>
<li>主键自动为NOT NULL</li>
</ul>
<h4 id="声明主键的方法"><a href="#声明主键的方法" class="headerlink" title="声明主键的方法"></a>声明主键的方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">您可以在创建表的时候就为表加上主键，如：</div><div class="line">CREATE TABLE tbl_name ([字段描述省略...], PRIMARY KEY(index_col_name));</div><div class="line">也可以更新表结构时为表加上主键，如：</div><div class="line">ALTER TABLE tbl_name ADD PRIMARY KEY (index_col_name,…);</div></pre></td></tr></table></figure>
<h4 id="主键示例"><a href="#主键示例" class="headerlink" title="主键示例"></a>主键示例</h4><p>主键被认为是NOT NULL和UNIQUE约束最好的结合。如果这些列没有被明确地定义为NOT NULL，MySQL会隐含地定义这些列。<br><img src="http://note.youdao.com/yws/public/resource/257edeeb47f554f3bf6a33d42f479a73/xmlnote/527E98AC5AF341C0994DCA2B4FE6A2AB/34695" alt="iamge"></p>
<p>主键不一定要与AUTO_INCREMENT一起使用。主键的值是唯一的，不能重复。</p>
<h4 id="扩充"><a href="#扩充" class="headerlink" title="扩充"></a>扩充</h4><p>不应该使用一个具有意义的column（id 本身并不保存表 有意义信息） 作为主键，并且一个表必须要有一个主键，为方便扩展、松耦合，高可用的系统做铺垫。<br><strong>无特殊需求下Innodb建议使用与业务无关的自增ID作为主键</strong><br>InnoDB引擎使用聚集索引，数据记录本身被存于主索引（一颗B+Tree）的叶子节点上。这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放，因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15/16），则开辟一个新的页（节点）</p>
<p>1、如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。如下图所示：<br><img src="http://7ktwa5.com1.z0.glb.clouddn.com/primary_key_1.jpg" alt="image"><br>这样就会形成一个紧凑的索引结构，近似顺序填满。<strong>由于每次插入时也不需要移动已有数据，因此效率很高，也不会增加很多开销在维护索引上。</strong><br>2、 如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置：<br><img src="http://7ktwa5.com1.z0.glb.clouddn.com/primary_key_2.jpg" alt="iamge"><br>此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。</p>
<p>在使用InnoDB存储引擎时，如果没有特别的需要，请永远使用一个与业务无关的自增字段作为主键。</p>
<p>mysql 在频繁的更新、删除操作，会产生碎片。而含碎片比较大的表，查询效率会降低。此时需对表进行优化，这样才会使查询变得更有效率。</p>
<h3 id="UNIQUE-KEY"><a href="#UNIQUE-KEY" class="headerlink" title="UNIQUE KEY"></a>UNIQUE KEY</h3><ul>
<li>唯一约束可以保证记录的唯一性</li>
<li>唯一约束的字段可以设置为空值NULL</li>
<li>每张数据表可以存在多个唯一约束<br><img src="http://note.youdao.com/yws/public/resource/257edeeb47f554f3bf6a33d42f479a73/xmlnote/7D6B88C78B3A4D778EE7356A02183DAA/34704" alt="image"><br>给username 设置了 UNIQUE KEY。<br><img src="http://note.youdao.com/yws/public/resource/257edeeb47f554f3bf6a33d42f479a73/xmlnote/14A83C5E29E64595A02E0CEDF11AA91F/34706" alt="image"><br>插入两个相同的数据会报错。因为username是UNIQUE KEY.</li>
</ul>
<h3 id="FROEIGN-KEY"><a href="#FROEIGN-KEY" class="headerlink" title="FROEIGN KEY"></a>FROEIGN KEY</h3><p>外键约束<br>是用于建立和加强两个表数据之间的链接的一列或多列。外键约束主要用来维护两个表之间数据的一致性。简言之，表的外键就是另一表的主键，外键将两表联系起来。一般情况下，要删除一张表中的主键必须首先要确保其它表中的没有相同外键（即该表中的主键没有一个外键和它相关联）。<br><img src="http://note.youdao.com/yws/public/resource/7d33ba2e58727f9063d9732ffe069a4a/xmlnote/4F9775224F1346DEABB43C4202E9A06E/34722" alt="iamge"></p>
<h4 id="修改存储引擎"><a href="#修改存储引擎" class="headerlink" title="修改存储引擎"></a>修改存储引擎</h4><p>（1）通过修改MySQL配置文件实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">default-storage-engine = engine</div></pre></td></tr></table></figure></p>
<p>（2）通过创建数据表命令实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE table_name(\</div><div class="line">...</div><div class="line">) ENGINE = engine;</div><div class="line">例如：</div><div class="line">CREATE TABLE tp1(</div><div class="line">s1 VARCHAR(10)</div><div class="line">) ENGINE = MyISAM;</div><div class="line">SHOW CREATE TABLE tp1; // 查看数据表的结构</div></pre></td></tr></table></figure></p>
<p>（3）通过修改数据表命令实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ALTER TABLE table_name ENGINE [=] engine_name; </div><div class="line">例如：</div><div class="line">ALTER TABLE tp1 ENGINE = InnoDB;</div></pre></td></tr></table></figure></p>
<h4 id="外键实例"><a href="#外键实例" class="headerlink" title="外键实例"></a>外键实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE table_name1(</div><div class="line">id SMALLINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,</div><div class="line">name VARCHAR(20) NOT NULL</div><div class="line">)</div><div class="line">CREATE TABLE table_name2(</div><div class="line">id SMALLINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,</div><div class="line">username VARCHAR(20) NOT NULL,</div><div class="line">pid SMALLINT UNSIGNED,</div><div class="line">FOREIGN KEY (pid) REFERENCES table_name1(id) /* 外键 pid 参照 table_name1中的 id 字段 */</div><div class="line">)</div></pre></td></tr></table></figure>
<p><img src="http://note.youdao.com/yws/public/resource/7d33ba2e58727f9063d9732ffe069a4a/xmlnote/E831F170BE9549AFA82ABC3EAE925ED5/34967" alt="iamge"><br><img src="http://note.youdao.com/yws/public/resource/7d33ba2e58727f9063d9732ffe069a4a/xmlnote/DC419B38AE7647C19E67F1C5FA1C1C60/34970" alt="iamge"><br>table_name1就是provience<br>table_name2就是users</p>
<p>因为pid（称为子列）参照了id（称为父列）,所以pid的数据类型必须与id相同。<br>在这里我们给子列创建了索引，如果没有的话，MySQL会自动为其创建。</p>
<h4 id="外键约束的参照操作"><a href="#外键约束的参照操作" class="headerlink" title="外键约束的参照操作"></a>外键约束的参照操作</h4><p><img src="http://note.youdao.com/yws/public/resource/7d33ba2e58727f9063d9732ffe069a4a/xmlnote/16F38EC4BAC04875A9828467774312A0/34974" alt="iamge"></p>
<h5 id="举个例子创建数据表"><a href="#举个例子创建数据表" class="headerlink" title="举个例子创建数据表"></a>举个例子创建数据表</h5><p>我们来验证CASCADE。再创建一个数据表，原先的provience已经创建了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">CREATE TABLE users1_1(</div><div class="line">id SMALLINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,</div><div class="line">username VARCHAR(20) NOT NULL,</div><div class="line">pid SMALLINT UNSIGNED,</div><div class="line">FOREIGN KEY (pid) REFERENCES provience(id) ON DELETE CASCADE</div><div class="line">)</div></pre></td></tr></table></figure></p>
<h5 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">INSERT provience(pname) VALUES(&apos;A&apos;);</div><div class="line">INSERT provience(pname) VALUES(&apos;B&apos;);</div><div class="line">INSERT provience(pname) VALUES(&apos;C&apos;);</div><div class="line">INSERT users1_1(username,pid) VALUES(&apos;TOM&apos;,2);</div></pre></td></tr></table></figure>
<p><img src="http://note.youdao.com/yws/public/resource/7d33ba2e58727f9063d9732ffe069a4a/xmlnote/788A47C70F52469AAF1B07BCB7BA41D3/34990" alt="image"><br>由于子表参照父表，必须在父表中先插入字段，不然子表是不会显示的。而且你插入的pid如果父表中的id不存在，也是插入失败的。</p>
<h5 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">DELETE FROM provience WHERE id = 2;</div></pre></td></tr></table></figure>
<p><img src="http://note.youdao.com/yws/public/resource/7d33ba2e58727f9063d9732ffe069a4a/xmlnote/D47DEA461F9E4AD693A91DDC2B713EA2/34993" alt="image"><br>你看，虽然我们只删除了父表中的id为2的数据。但是由于子表的pid和父表id对应，所以子表也一起被删除了。<br>这就是外键约束强大的地方。</p>
<h4 id="表级约束和列级约束"><a href="#表级约束和列级约束" class="headerlink" title="表级约束和列级约束"></a>表级约束和列级约束</h4><p><img src="http://note.youdao.com/yws/public/resource/7d33ba2e58727f9063d9732ffe069a4a/xmlnote/0D5001FA0B50404BA093AC7BA851684E/34755" alt="iamge"></p>
<h4 id="约束相关操作"><a href="#约束相关操作" class="headerlink" title="约束相关操作"></a>约束相关操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">唯一约束的 index_name 可通过 SHOW INDEX FROM table_name\G; 查询</div><div class="line">外键约束的名字 fk_symbol 可通过 SHOW CREATE TABLE table_name; 查询</div><div class="line">删除主键约束：</div><div class="line">ALTER TABLE table_name DROP PRIMARY KEY;</div><div class="line">删除唯一约束：</div><div class="line">ALTER TABLE table_name DROP &#123;INDEX|KEY&#125; index_name;</div><div class="line">删除外键约束：</div><div class="line">ALTER TABLE table_name DROP FOREIGN KEY fk_symbol;</div></pre></td></tr></table></figure>
<p><strong>修改列定义的时候注意如何数据已经存放了较多，而重新定义了较小的数据类型，可能会导致数据丢失。</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">1.修改列定义</div><div class="line">ALTER TABLE tbl_name MODIFY [COLUMN] col_name column_definition [FIRST |AFTER col_name];</div><div class="line">ALTER TABLE users2 MODIFY id SMALLINT UNSIGNED NOT NULL FIRST; //将id字段的位置提到第一列</div><div class="line">SHOW COLUMNS FROM users2;</div><div class="line">ALTER TABLE users2 MODIFY id TINYINT UNSIGNED NOT NULL; //修改数据类型,需注意数据丢失的问题</div><div class="line">2.修改列名称</div><div class="line">ALTER TABLE tbl_name CHANGE [COLUMN] col_name new_col_name column_definition [FIRST|AFTER col_name];</div><div class="line">ALTER TABLE users2 CHANGE pid p_id TINYINT UNSIGNED; //修改列名称</div><div class="line">3.数据表更名</div><div class="line">方法1</div><div class="line">ALTER TABLE tbl_name RENAME [TO/AS] new_tbl_name</div><div class="line">ALTER TABLE users2 RENAME TO users3;</div><div class="line">SHOW TABLES;</div><div class="line">ALTER TABLE users2 RENAME AS users4;</div><div class="line">SHOW TABLES;</div><div class="line">ALTER TABLE users2 RENAME users5;</div><div class="line">方法2</div><div class="line">RENAME TABLE tbl_name TO new_tbl_name [, tbl_name2 TO new_tbl_name2] ...</div><div class="line">RENAME TABLE users5 TO users2;</div><div class="line">近来少使用数据表的列名及表名的更名。</div></pre></td></tr></table></figure></p>
<p><a href="http://blog.csdn.net/lcg910978041/article/details/52002705" target="_blank" rel="external">http://blog.csdn.net/lcg910978041/article/details/52002705</a><br><a href="http://www.jianshu.com/p/33b7b6e0a396" target="_blank" rel="external">http://www.jianshu.com/p/33b7b6e0a396</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[MySQL环境配置]]></title>
      <url>https://zaynex.github.io/2016/08/20/MYSQL%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
      <content type="html"><![CDATA[<h2 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h2><p><img src="http://note.youdao.com/yws/public/resource/591675023b0f315e221678acb176978a/xmlnote/A5F5DB2443C2481A86601BD8444347B9/34836" alt="image"><br><a id="more"></a><br>出现excute的就都点这个。<br><img src="http://note.youdao.com/yws/public/resource/591675023b0f315e221678acb176978a/xmlnote/63EA5CFCAEA7473CB2C914604120949F/34519" alt="image"><br>这张图片告诉我们还需要下载一些组件，点击EXCUTE即可。有些组件不是必须的，比如MySQL for vs1.2.6。</p>
<h3 id="新建配置文件my-ini"><a href="#新建配置文件my-ini" class="headerlink" title="新建配置文件my.ini"></a>新建配置文件my.ini</h3><p>在安装的目录盘下有个my-default.ini。你复制一份该文件命名为my.ini。<br><img src="http://note.youdao.com/yws/public/resource/591675023b0f315e221678acb176978a/xmlnote/4D4683FAC97C40B98243C3875528B461/34830" alt="image"><br>然后修改文件。<br><img src="http://note.youdao.com/yws/public/resource/591675023b0f315e221678acb176978a/xmlnote/F973DB2EC3554732A9BD0D362302E593/34832" alt="image"><br>注意后面的两个目录是你安装MySQL的目录。还有data目录也是需要你新建的。（系统没有默认生成）</p>
<h3 id="初始化和启动MySQL服务"><a href="#初始化和启动MySQL服务" class="headerlink" title="初始化和启动MySQL服务"></a>初始化和启动MySQL服务</h3><ol>
<li>以管理员权限运行cmd</li>
<li>进入mysql的bin下</li>
<li><p>初始化，生成data文件夹</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt;mysqld  --initialize-insecure （不设置root密码，建议使用）</div><div class="line">&gt;mysqld  --initialize （生成一个随机的root密码）</div></pre></td></tr></table></figure>
</li>
<li><p>安装MySql服务</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;mysqld -install</div></pre></td></tr></table></figure>
</li>
<li><p>启动mysql</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;net start mysql</div></pre></td></tr></table></figure>
</li>
</ol>
<p>如果你是5.7版本的启动和删除<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">net start mysql57</div><div class="line">net stop mysql57</div></pre></td></tr></table></figure></p>
<h3 id="登陆mysql"><a href="#登陆mysql" class="headerlink" title="登陆mysql"></a>登陆mysql</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt;mysql -u root -p</div></pre></td></tr></table></figure>
<p>第一次登录时无需密码直接回车登录。</p>
<h3 id="额外内容"><a href="#额外内容" class="headerlink" title="额外内容"></a>额外内容</h3><p>在安装mysql5.7版本时，经常会遇到mysql -u root -p直接回车登陆不上的情况，原因在于5.7版本在安装时自动给了一个随机密码，MySQL 5.7版本提供了更为简单SSL安全访问配置。坑爹的是在init步骤的时候不像linux系统会给出命令行提示，需要手动在mysql目录下搜索*.err，以文本形式打开才能看到如下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">016-02-25T15:09:43.033062Z 1 [Note] A temporary password is generated for root@localhost: &gt;mso&lt;k70mrWe</div></pre></td></tr></table></figure></p>
<p>@localhost:后为第一次的登陆密码，记得加双引号。<br>(未测试)</p>
<h2 id="使用时容易出错的地方"><a href="#使用时容易出错的地方" class="headerlink" title="使用时容易出错的地方"></a>使用时容易出错的地方</h2><ol>
<li><p>开机之后，如果进程里mysql还在运行，把运行删除中断掉。重新打开cmd。net start mysql57，否则重启的时候会提示无法启动，而且也没有什么报错信息。</p>
</li>
<li><p>Mysql—-error:no query specified<br>mysql下抛出错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">error:no query specified</div></pre></td></tr></table></figure>
</li>
</ol>
<p>出现此错误是sql不合法原因：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">如：select * from abc\G;或者select * from abc;;</div></pre></td></tr></table></figure></p>
<p>\G后面不需要再加分号;</p>
<ol>
<li>出现箭头<br><img src="http://note.youdao.com/yws/public/resource/591675023b0f315e221678acb176978a/xmlnote/0555E0B9F07C4905AB948D7560987C12/34834" alt="image"><br>这是因为你没有输入完整。<br>MySQL语言规范是要有<strong>;</strong>结尾的。如果误输入单引号或者双引号，只要再输入一次使其成对出现就可以解决该问题。</li>
</ol>
<h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">show databases;   //所有数据库列表</div><div class="line">create database dbName; //创建数据库</div><div class="line">use dbName;    //选择数据库</div><div class="line">show tables;  //显示数据表列表</div><div class="line"></div><div class="line">查看数据表中的条目：</div><div class="line">desc tableName;</div><div class="line">describe tableName;</div><div class="line">show columns from tableName;</div><div class="line">show create table tableName;</div><div class="line"></div><div class="line">清空数据表中所有条目：</div><div class="line">truncate table 表名;  //清空全部数据，不写日志，不可恢复，速度极快</div><div class="line">delete from 表名;    //清空全部数据，写日志，数据可恢复，速度慢</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[开启神秘的后端之路]]></title>
      <url>https://zaynex.github.io/2016/08/18/%E5%BC%80%E5%90%AF%E7%A5%9E%E7%A7%98%E7%9A%84%E5%90%8E%E7%AB%AF%E4%B9%8B%E8%B7%AF/</url>
      <content type="html"><![CDATA[<h2 id="PHP初探"><a href="#PHP初探" class="headerlink" title="PHP初探"></a>PHP初探</h2><p>安装WampServer。(window + Apche + mySQL + PHP)<br><a id="more"></a></p>
<h3 id="修改根目录"><a href="#修改根目录" class="headerlink" title="修改根目录"></a>修改根目录</h3><p>设置Apache的httpconfig文件找到<code>DocumentRoot</code>以及<code>&lt;Directory  &quot;D:/codelife/php/&quot;&gt;</code>(改成你想要的站点)可以修改根目录。</p>
<p><strong>这样的好处就是可以让系统配置文件和你的网站分离。</strong></p>
<h3 id="修改默认配置的www目录"><a href="#修改默认配置的www目录" class="headerlink" title="修改默认配置的www目录"></a>修改默认配置的www目录</h3><p> 修改wamp文件中的<code>wampmanager.ini</code>以及tpl文件中的<code>menu.left</code> 中的目录<code>Dir</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Type: item; Caption: &quot;codelifephp 目录&quot;; Action: shellexecute; FileName: &quot;D:/codelife/php&quot;; Glyph: 2</div></pre></td></tr></table></figure></p>
<p>这是我修改的，记得也是两处修改</p>
<h3 id="多站点"><a href="#多站点" class="headerlink" title="多站点"></a>多站点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">C:\wamp\bin\apache\apache2.4.9\conf\extra\httpd-vhosts.conf</div></pre></td></tr></table></figure>
<p>修改完站点之后，还要在Apache服务器的http-config中将 <code>httpd-vhosts</code>文件包含 将#注释去掉。然后将所有文件设置为允许外部访问 Require all granted</p>
<h3 id="修改默认端口号"><a href="#修改默认端口号" class="headerlink" title="修改默认端口号"></a>修改默认端口号</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Listen 0.0.0.0:8080</div><div class="line"></div><div class="line">Listen [::0]:8080</div><div class="line"></div><div class="line">ServerName localhost:8080</div></pre></td></tr></table></figure>
<p>Apache2.4.9版本</p>
<h3 id="谈谈配置文件的坑"><a href="#谈谈配置文件的坑" class="headerlink" title="谈谈配置文件的坑"></a>谈谈配置文件的坑</h3><p>因为视频讲解的版本跟安装的版本不一样，导致出了一些问题。不过还好都已经解决了。以后配置文件一定要确认好文件的版本。<br>然后随手做下记录和备份，避免造成无法挽救的错误，比如文件配置错误后，那就要重新安装了，因为你根本不知道自己原来哪里出错了。</p>
<h2 id="谈谈自己的学习状态"><a href="#谈谈自己的学习状态" class="headerlink" title="谈谈自己的学习状态"></a>谈谈自己的学习状态</h2><p>最近看JavaScriptDOM高级程序设计的时候看得没有那么爽，反倒是JavaScript高级程序设计和面向对象编程看得比较爽一些。所以也是想找点新的东西稍微提升下成就感。</p>
<p>既然DOM高级程序设计这本书更多的是讲解代码，那索性自己跑通了后台的一些基础概念之后，做一个动态网站好了。<br>AJAX和JSON、cookie、Http都还没有好好得跑过，因此借着这次后台的学习把一些前端需要掌握的基础后台知识过一遍。</p>
<p>在JavaScript学习方面，决定暂时放弃看DOM高级程序设计，继续看《JS面向对象编程指南》。原先看过《JavaScript语言精粹》，只觉得精妙但实在一时还是不好消化，尤其是函数这一章，原型继承这块还不是特别熟练，还有神奇的部件（特别懵逼）。</p>
<p>掌握PHP基础语法之后尝试一些表单验证，把正则补充起来。做一个像样的前后端表单验证，以及cookie缓存。</p>
<p>看了几本经典的书之后发现其实很多博客的文章基本都是从经典书籍中的例子演绎而来，少有通过自己的见解全新解读一番的。包括自己目前也是一直属于记读书笔记的状态，主动思考还缺乏一些，这可能也需要更多的结合项目通过code去实践出来。</p>
<p>看完《JS面向对象编程》之后，再去看underscore.js的源码并将其用于一些练习中。</p>
<p>关于数据结构，虽然现在在看的是《啊哈算法》一本及其简单入门的用c写的算法书，但也希望自己能坚持下来，有个对数据结构和算法的大致印象之后，再尝试去看更系统正规的书籍。（把云课堂的ZJU数据结构课程也认真的看一遍）</p>
<p>Http相关的内容每天基本上会看个半个小时到一小时左右。书籍是《图解Http》。手头上有HTTP权威指南，可以作为笔记时翻阅和图解HTTP内容补充。</p>
<p>现在还是比较多的时间基本都花在看书和按照书中打代码的阶段，虽然有时候觉得收获不多，还是希望自己code一些东西，但也不知道该从何下手。想起来原先还在做的百度ife上的一些题目，可以再看看，实在看得憋不住了，就解解题目。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript面向对象之数据基本判断]]></title>
      <url>https://zaynex.github.io/2016/08/18/JavaScript%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E6%95%B0%E6%8D%AE%E5%9F%BA%E6%9C%AC%E5%88%A4%E6%96%AD/</url>
      <content type="html"><![CDATA[<p>虽然都是些很简单的东西， 但是看起来很容易就出错了。<br><a id="more"></a><br>还有|| 是有惰性的，如果前面的是true后面的就不执行了。（这和引擎有关）</p>
<pre><code>var s = &apos;ls&apos;;
s++;
var a;
console.log(typeof a); //undefined
console.log(s); //NaN
console.log(!!undefined); //false
console.log(10 % &quot;0&quot;); //NaN
console.log(undefined == null); // true
console.log(false === &quot;&quot;); // false
console.log(false == &quot;&quot;); // true
console.log(typeof -Infinity); // number
console.log(typeof NaN); // number
/*
c = 3E + 2;
c++;
console.log(c); //Invalid or unexpected token
*/
var v = v || 100;
console.log(v); // 都是取后面的数
delete v; // delete全局函数无效，如果是window对象，则会生效
console.log(v);// 10
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[啊哈算法之链表]]></title>
      <url>https://zaynex.github.io/2016/08/17/%E5%95%8A%E5%93%88%E7%AE%97%E6%B3%95%E4%B9%8B%E9%93%BE%E8%A1%A8/</url>
      <content type="html"><![CDATA[<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>后面有个尾巴指向下个数<br><a id="more"></a><br>指针<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line"></div><div class="line">int main()&#123;</div><div class="line">	int *p;</div><div class="line">	p = (int *)malloc(sizeof(int));</div><div class="line">	// malloc动态分配内存，因为默认返回void*类型指针，所以需要强制转换为int类型指针 </div><div class="line">	*p = 10; </div><div class="line">	printf(&quot;%d&quot;, *p);</div><div class="line">	</div><div class="line">	getchar();</div><div class="line">	return 0; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>动态分配内存的好处就是方便扩展</p>
<h3 id="结构体链表"><a href="#结构体链表" class="headerlink" title="结构体链表"></a>结构体链表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;stdlib.h&gt; </div><div class="line"></div><div class="line">struct node&#123;</div><div class="line">	int data;</div><div class="line"> 	struct node *next;</div><div class="line">	 //因为下一个节点类型也是 struct node，所以指针也必须是 struct node* 类型的指针 </div><div class="line">&#125;;</div><div class="line">int main()&#123;</div><div class="line">	struct node *head,*p,*q,*t; </div><div class="line">	int i,n,a;</div><div class="line">	head = NULL;</div><div class="line">	scanf(&quot;%d&quot;, &amp;n);</div><div class="line"></div><div class="line">	//头指针为null</div><div class="line">	</div><div class="line">	for(i=1;i&lt;=n;i++)&#123;</div><div class="line">		scanf(&quot;%d&quot;, &amp;a);</div><div class="line">		//d动态申请一个空间，存放一个结点，并用临时指针p指向该节点</div><div class="line">		p = (struct node *)malloc(sizeof(struct node));</div><div class="line">		p-&gt;data= a;// 将数据存储到当前节点的data域中</div><div class="line">		p-&gt;next= NULL;//设置当前节点的后继指针为空，也就是当前结点的下一个节点为空</div><div class="line">		// -&gt; 叫结构体指针运算符 </div><div class="line">		if(head== NULL) &#123;</div><div class="line">			head = p;//如果这是第一个创建的结点，则将头指针指向该结点 </div><div class="line">		&#125;else&#123;</div><div class="line">			q-&gt;next = p;//如果创建的不是第一个结点，则将上一个结点的后继节点指向当前结点 </div><div class="line">		&#125;</div><div class="line">		q=p;	 </div><div class="line">	&#125;	</div><div class="line">	t = head;</div><div class="line">	scanf(&quot;%d&quot;, &amp;a);//读入一个待插入的数 </div><div class="line">	while(t!=NULL)&#123;//当还没有达到链表尾部的时候循环 </div><div class="line">		if(t-&gt;next-&gt;data&gt; a)&#123; //如果当前结点的下一个结点的值大于待插入数，将数插入到中间 </div><div class="line">			p=(struct node*)malloc(sizeof(struct node));</div><div class="line">			p-&gt;data= a;</div><div class="line">			p-&gt;next= t-&gt;next;//新增结点的后继指针指向当前结点的后继指针所指向的结点</div><div class="line">			t-&gt;next=p;</div><div class="line">			</div><div class="line">			//t的下一个结点大于a时，就将t后继指针指向a,而a的后继指针就指向原先t的后继指针的结点  </div><div class="line">			break; </div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		t=t-&gt;next;//继续下一个结点 </div><div class="line">		printf(&quot;%d &quot;, t-&gt;data);</div><div class="line">		t = t-&gt;next;//继续下一个结点 </div><div class="line">	&#125; </div><div class="line">	</div><div class="line">	 </div><div class="line">	getchar();</div><div class="line">	return 0; </div><div class="line">&#125;</div><div class="line"></div><div class="line">![iamge](http://note.youdao.com/yws/public/resource/4eeedf8824102a1750093326f70662a0/xmlnote/CF936A9F5047483EB12F6D6DC184D0E7/34315)</div><div class="line">![image](http://note.youdao.com/yws/public/resource/4eeedf8824102a1750093326f70662a0/xmlnote/B2D6D0426A1743EBA5318DFE1A326963/34319)</div></pre></td></tr></table></figure>
<h3 id="模拟链表"><a href="#模拟链表" class="headerlink" title="模拟链表"></a>模拟链表</h3><p>模拟链表保存的是两个数组，一个用来保存他们的数值，一个用来保存他们右边相邻的位置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">int main()&#123;</div><div class="line">	int data[101], right[101];</div><div class="line">	int i,n,t,len;</div><div class="line">	scanf(&quot;%d&quot;, &amp;n);</div><div class="line">	for(i=1; i&lt;=n; i++)&#123;</div><div class="line">		scanf(&quot;%d&quot;, &amp;data[i]);</div><div class="line">	&#125;</div><div class="line">	len = n;</div><div class="line">	</div><div class="line">	for(i=1;i&lt;=n;i++)&#123;</div><div class="line">		if(i!=n)&#123;</div><div class="line">			right[i] = i+1;</div><div class="line">		&#125;else&#123;</div><div class="line">			right[i] = 0;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	//在数组末尾添加一个数 </div><div class="line">	len++;</div><div class="line">	scanf(&quot;%d&quot;, &amp;data[len]);</div><div class="line">	</div><div class="line">	t =1;</div><div class="line">	while(t!=0)&#123;</div><div class="line">		if(data[right[t]]&gt;data[len])//如果当前结点下一个结点的值大于待插入数，将插入数放到中间</div><div class="line">		&#123;</div><div class="line">			right[len] = right[t];</div><div class="line">			right[t] = len;</div><div class="line">			break; </div><div class="line">		&#125; </div><div class="line">	 	t = right[t];</div><div class="line">	&#125;</div><div class="line">	t=1;</div><div class="line">	while(t!=0)&#123;</div><div class="line">		printf(&quot;%d &quot;, data[t]);</div><div class="line">		t= right[t];</div><div class="line">	&#125; </div><div class="line">	</div><div class="line">	getchar();</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[啊哈算法之队列和栈]]></title>
      <url>https://zaynex.github.io/2016/08/16/%E5%95%8A%E5%93%88%E7%AE%97%E6%B3%95%E4%B9%8B%E9%98%9F%E5%88%97%E5%92%8C%E6%A0%88/</url>
      <content type="html"><![CDATA[<p>队列。<br>第一个数出来，第二个数排到队尾。<br>第一个指针指向的是队首，第二个指针指向的是队尾的下一位，不给它设定为队尾是避免当队列为空时队首和队尾重合带来的麻烦。<br><a id="more"></a></p>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">int main()&#123;</div><div class="line">	int q[102] = &#123;0, 6, 3, 1, 7, 5, 8, 9, 2, 4&#125;,head,tail;</div><div class="line">	int i;</div><div class="line">	//初始化队列 </div><div class="line">	 head = 1;</div><div class="line">	 tail = 10; //队列一共有9个元素，tail指向队尾的最后一个位置</div><div class="line">	 while(head &lt; tail)&#123;</div><div class="line"> 		//打印队首并将队首出队</div><div class="line">		 printf(&quot;%d &quot;, q[head] );</div><div class="line">		 head++;</div><div class="line">		 </div><div class="line">		 //先将新队首的数添加到队尾</div><div class="line">		 q[tail] = q[head];</div><div class="line">		 tail++;</div><div class="line">		 //再将队首出队</div><div class="line">		 head++; </div><div class="line"> 	&#125; </div><div class="line">	getchar();</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>队列遵从先进先出的概念，跟排队一样，先到的人先享受服务，再出去。</p>
<h3 id="结构体队列"><a href="#结构体队列" class="headerlink" title="结构体队列"></a>结构体队列</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line"></div><div class="line">struct queue&#123;</div><div class="line">	int data[100];</div><div class="line">	int head;</div><div class="line">	int tail;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line">int main()&#123;</div><div class="line">	struct queue q;</div><div class="line">	int i;</div><div class="line">	//初始化队列 </div><div class="line">	q.head = 1;</div><div class="line">	q.tail = 1;</div><div class="line">	for(i=1;i&lt;=9;i++)&#123;</div><div class="line">		//依次向队列插入9个数 </div><div class="line">		scanf(&quot;%d&quot;,&amp;q.data[q.tail]);</div><div class="line">		q.tail++;</div><div class="line">		//后面的数当然是插到末尾啦 </div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	while(q.head &lt; q.tail)&#123;//当队列不为空时循环 </div><div class="line">		//打印队首并将队首出队 </div><div class="line">		printf(&quot;%d &quot;, q.data[q.head]);</div><div class="line">		q.head++;</div><div class="line">		</div><div class="line">		//将新队首的数添加到队尾</div><div class="line">		q.data[q.tail] = q.data[q.head];</div><div class="line">		q.tail++;</div><div class="line">		</div><div class="line">		q.head++; </div><div class="line">	&#125; </div><div class="line"></div><div class="line">	getchar();</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>栈很好理解，就好像古时候的大炮一样，第一个放进去的总是最后才放出来。<br><img src="http://note.youdao.com/yws/public/resource/5dd6d2fe577dbe51e443337c4b6f6f44/xmlnote/WEBRESOURCE94a6fd4147906f5a26b45be2981fb0c5/34297" alt="image"><br>一图胜前言</p>
<h3 id="回文字符"><a href="#回文字符" class="headerlink" title="回文字符"></a>回文字符</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">#include &lt;string.h&gt;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">	char a[101], s[101] ;</div><div class="line">	int len , i , mid , next , top ;</div><div class="line">	</div><div class="line">	printf(&quot;enter a string : \n&quot;);</div><div class="line">	gets(a);</div><div class="line">	len= strlen(a);</div><div class="line">	mid = len / 2 -1;</div><div class="line"></div><div class="line">	top = 0 ;</div><div class="line">	//将mid前的字符入栈</div><div class="line">	for(i = 0 ; i &lt;= mid ; i++)</div><div class="line">	&#123;</div><div class="line">		s[++top] = a[i];</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	if (len % 2 == 0)</div><div class="line">		next = mid +1 ;</div><div class="line">	else </div><div class="line">		next = mid +2 ;</div><div class="line"></div><div class="line">	//开始匹配</div><div class="line">	for(i = next ; i &lt;=len - 1 ; i++)</div><div class="line">	&#123;</div><div class="line">		if (a[i]!= s[top])</div><div class="line">			break;</div><div class="line">		top--;</div><div class="line">	&#125;</div><div class="line">	//如果top的值为0 ， 则说明栈内数据已全部被匹配</div><div class="line">	printf(&quot;the result is :\n&quot;);</div><div class="line">	if (top == 0 )</div><div class="line">	&#123;</div><div class="line">		printf(&quot;Yes \n&quot;);</div><div class="line">	&#125;</div><div class="line">	else</div><div class="line">		printf(&quot;NO\n&quot;);</div><div class="line">	return 0 ;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="小猫钓鱼"><a href="#小猫钓鱼" class="headerlink" title="小猫钓鱼"></a>小猫钓鱼</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">struct queue &#123;</div><div class="line">	int data [1000];</div><div class="line">	int head ;</div><div class="line">	int tail ;</div><div class="line">&#125;;</div><div class="line">struct stack&#123;</div><div class="line">	int data[10];</div><div class="line">	int top ;</div><div class="line">&#125;;</div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">	struct queue q1 , q2 ;</div><div class="line">	struct stack s ;</div><div class="line">	int book[10];</div><div class="line">	int i , t ;</div><div class="line">//initialize the array </div><div class="line">	q1.head = 1 ;</div><div class="line">	q1.tail = 1 ;</div><div class="line"></div><div class="line">	q2.head = 1 ;</div><div class="line">	q2.tail = 1 ;</div><div class="line">// initialize the stack </div><div class="line">	s.top = 0 ;</div><div class="line">//初始化用来标记的数组，用来标记哪些牌在桌子上</div><div class="line">	for (i = 0 ; i &lt;= 9 ; i++)</div><div class="line">		book[i] = 0 ;</div><div class="line"></div><div class="line">//初始化Q1，小哼手中的牌</div><div class="line">	printf(&quot;输入小哼手中的牌&quot;);</div><div class="line">	for (i = 1 ; i &lt;= 6 ;i++)</div><div class="line">	&#123;</div><div class="line">		scanf(&quot;%d&quot;,&amp;q1.data[q1.tail]);</div><div class="line">		q1.tail++;</div><div class="line">	&#125;</div><div class="line">	//初始化Q2，小哈手中的牌</div><div class="line">	printf(&quot;输入小哈手中的牌&quot;);</div><div class="line">	for (i = 1 ; i &lt;= 6 ;i++)</div><div class="line">	&#123;</div><div class="line">		scanf(&quot;%d&quot;,&amp;q2.data[q2.tail]);</div><div class="line">		q2.tail++;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	while(q1.head &lt; q1.tail &amp;&amp; q2.head &lt; q2.tail)</div><div class="line">	&#123;</div><div class="line">		t= q1.data[q1.head];//小哼出的第一张牌</div><div class="line">		if (book[t] == 0)//桌上没牌</div><div class="line">		&#123;</div><div class="line">			q1.head++;</div><div class="line">			s.top++;</div><div class="line">			s.data[s.top] = t ;</div><div class="line">			book[t] = 1 ;</div><div class="line">		&#125;</div><div class="line">		else</div><div class="line">		&#123;</div><div class="line">			q1.head++;</div><div class="line">			q1.data[q1.tail] = t ;</div><div class="line">			q1.tail++;</div><div class="line"></div><div class="line">			while(s.data[s.top] != t )</div><div class="line">			&#123;</div><div class="line">				book[s.data[s.top]] = 0 ;</div><div class="line">				q1.data[q1.tail] = s.data[s.top];</div><div class="line">				q1.tail++;</div><div class="line">				s.top--;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		t = q2.data[q2.head];//小哈出一张牌</div><div class="line">			if (book[t] == 0 )</div><div class="line">			&#123;//小哈此轮未赢牌</div><div class="line">				q2.head++;</div><div class="line">				s.top++;</div><div class="line">				s.data[s.top] = t ;</div><div class="line">				book[t] = 1 ;</div><div class="line">			&#125;</div><div class="line">			else </div><div class="line">			&#123;//小哈此轮赢牌</div><div class="line">				q2.head++;</div><div class="line">				q2.data[q2.tail] = t;</div><div class="line">				q2.tail++;</div><div class="line">				while(s.data[s.top] != t )</div><div class="line">				&#123;</div><div class="line">					book[s.data[s.top]] = 0 ;</div><div class="line">					q2.data[q2.tail] = s.data[s.top] ;</div><div class="line">					q2.tail++;</div><div class="line">					s.top--;</div><div class="line">				&#125;</div><div class="line"></div><div class="line">			&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	if (q2.head == q2.tail)</div><div class="line">	&#123;</div><div class="line">		printf(&quot;小哼win\n&quot;);</div><div class="line">		printf(&quot;小哼现在手中的牌是\n&quot;);</div><div class="line">		for(i = q1.head ;i &lt;= q1.tail - 1 ; i++)</div><div class="line">			printf(&quot; %d &quot;, q1.data[i]);</div><div class="line"></div><div class="line">		if (s.top&gt;0)</div><div class="line">		&#123;</div><div class="line">			printf(&quot;桌面上的牌是\n&quot;);</div><div class="line">			for(i = 1 ; i &lt;= s.top ; i++)</div><div class="line">				printf(&quot; %d &quot;, s.data[i]);</div><div class="line">		&#125;</div><div class="line">		else</div><div class="line">			printf(&quot;桌面上没牌了\n&quot;);</div><div class="line">	&#125;</div><div class="line">	else</div><div class="line">	&#123;</div><div class="line">		printf(&quot;小哈win\n&quot;);</div><div class="line">		printf(&quot;小哈现在手中的牌是\n&quot;);</div><div class="line">		for(i = q2.head ;i &lt;= q2.tail - 1 ;i++)</div><div class="line">			printf(&quot; %d &quot;, q2.data[i]);</div><div class="line">		</div><div class="line">		if (s.top&gt;0)</div><div class="line">		&#123;</div><div class="line">			printf(&quot;桌面上的牌是\n&quot;);</div><div class="line">			for(i = 1 ; i &lt;= s.top ; i++)</div><div class="line">				printf(&quot; %d &quot;, s.data[i]);</div><div class="line">		&#125;</div><div class="line">		else</div><div class="line">			printf(&quot;\n桌面上没牌了\n&quot;);</div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>栈和队列的操作每次都需要把指针移到相应的位置。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript语言精粹之继承]]></title>
      <url>https://zaynex.github.io/2016/08/16/JavaScript%E8%AF%AD%E8%A8%80%E7%B2%BE%E7%B2%B9%E4%B9%8B%E7%BB%A7%E6%89%BF/</url>
      <content type="html"><![CDATA[<p>往往会把一件完整的东西化为无数的形象。就像凹凸镜一般，从正面望去，只见一片模糊。<br><a id="more"></a></p>
<h2 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h2><p>当一个对象被创建时，Function构造器产生的函数对象会运行类似这样的一些代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">this.prototype = &#123;constructor: this&#125;;</div></pre></td></tr></table></figure></p>
<p>新函数对象被赋予一个prototype属性，其值包含一个constructor属性且属性值为该新函数对象。<br>因为JS语言没有提供一种方法确定哪个函数打算用来做构造器的，所以每个函数都会得到一个prototype对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">Function.method(&quot;new&quot;, function()&#123;</div><div class="line">	//创建一个新对象，它继承自构造函数的原型对象</div><div class="line">	var that= Object.beget(this.prototype);</div><div class="line">	//调用构造函数，绑定this到新对象上</div><div class="line">	var other= this.apply(that, arguments);</div><div class="line">	//如果它的返回值不是一个对象，就返回该新对象</div><div class="line">	return (typeof other === &apos;object&apos; &amp;&amp; other) || that;</div><div class="line">&#125;);</div><div class="line">//定义个构造器并扩充它的原型</div><div class="line">var Mammal = function(name) &#123;</div><div class="line">	this.name = name;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Mammal.prototype.get_name = function()&#123;</div><div class="line">	return this.name;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Mammal.prototype.says = function()&#123;</div><div class="line">	return this.saying || &apos;&apos;;</div><div class="line">&#125;;</div><div class="line">//我们构造一个实例</div><div class="line">var myMammal = new Mammal(&quot;Herb the Mammal&quot;);</div><div class="line">var name = myMammal.get_name();</div><div class="line">console.log(name);//Herb the Mammal</div></pre></td></tr></table></figure>
<p>我们可以构造另一个伪类来继承Mammal，通过定义它的constructor函数并替换它的prototype为一个Mammal的实例来实现的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">var Cat = function(name)&#123;</div><div class="line">	this.name= name;</div><div class="line">	this.saying = &quot;meow&quot;;</div><div class="line">&#125;</div><div class="line">//替换Cat.prototype为一个新的Mammal实例</div><div class="line">Cat.prototype = new Mammal();</div><div class="line">//扩充原型对象，增加purr 和 get_name方法</div><div class="line"></div><div class="line">Cat.prototype.purr = function(n) &#123;</div><div class="line">	var i, s= &quot;&quot;;</div><div class="line">	for(i = 0; i &lt; n; i += 1)&#123;</div><div class="line">		if(s) &#123;</div><div class="line">			s += &apos;-&apos;;</div><div class="line">		&#125;</div><div class="line">		s += &apos;r&apos;;</div><div class="line">	&#125;</div><div class="line">	return s;</div><div class="line">&#125;;</div><div class="line">Cat.prototype.get_name = function()&#123;</div><div class="line">	return this.says() + &apos; &apos; + this.name + &apos; &apos; + this.says();</div><div class="line">&#125;;		</div><div class="line"></div><div class="line">var myCat = new Cat(&quot;Henmrimg&quot;);</div><div class="line">var says = myCat.says();</div><div class="line">var purr = myCat.purr(5);</div><div class="line">var name = myCat.get_name();</div><div class="line">console.log(name);//meow Henmrimg meow</div></pre></td></tr></table></figure>
<h3 id="隐藏prototype"><a href="#隐藏prototype" class="headerlink" title="隐藏prototype"></a>隐藏prototype</h3><p>伪类模式本意是向面向对象靠拢，但看起来格格不入。我们可以隐藏一些细节。通过method方法定义个inherits方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Function.method(&apos;inherits&apos;, function(Parent)&#123;</div><div class="line">	this.prototype = new Parent();</div><div class="line">	return this;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>inherits和method都访问this，这将允许我们可以以级联的样式编程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">var Cat = function(name)&#123;</div><div class="line">	this.name = name;</div><div class="line">	this.saying = &apos;meow&apos;;</div><div class="line">&#125;.</div><div class="line">	inherits(Mammal).method(&apos;purr&apos;, function(n)&#123;</div><div class="line">	var i , s= &quot;&quot;;</div><div class="line">	for(i=0; i&lt; n; i+=1)&#123;</div><div class="line">		if(s)&#123;</div><div class="line">			s+= &apos;-&apos;;</div><div class="line">		&#125;</div><div class="line">		s += &apos;r&apos;;</div><div class="line">	&#125;</div><div class="line">	return s;</div><div class="line">	&#125;).</div><div class="line">	method(&apos;get_name&apos;, function()&#123;</div><div class="line">		return this.says() + &apos; &apos; + this.name + &quot; &quot; + this.says();</div><div class="line">	&#125;);</div><div class="line"></div><div class="line">var myCat = new Cat(&quot;Henmrimg&quot;);</div><div class="line">var says = myCat.says();</div><div class="line">var purr = myCat.purr(5);</div><div class="line">var name = myCat.get_name();</div><div class="line">console.log(name);</div></pre></td></tr></table></figure></p>
<p>这样就隐藏了prototype操作细节。但问题是：<br><strong>没有私有环境，所有属性都是公开的。无法访问 super(父类)的方法。</strong></p>
<p>使用构造函数存在一个严重的危害就是如果在调用构造函数时 忘记了在前面加一个new前缀，那么this将不会绑定到一个新对象上。它会被绑定到全局对象上。</p>
<p>为了降低这个问题带来的风险，所有的构造函数都约定命名成首字母大写的形式。这样就可以方便检查是否少了new前缀，但是更好的方案就是根本不使用new。</p>
<h2 id="对象说明符"><a href="#对象说明符" class="headerlink" title="对象说明符"></a>对象说明符</h2><p>在编写构造器时使其接受一个简单的对象说明符会使得构造器参数更加友好。对那个对象包含了将要构建的对象的规格说明。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var myObject = maker(f, l, m, c, s);</div><div class="line">var myObject = maker(&#123;</div><div class="line">	first: f,</div><div class="line">	last: l,</div><div class="line">	state: s,</div><div class="line">	city: c</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">var myMammal = &#123;</div><div class="line">	name: &apos;Herb the mamal&apos;,</div><div class="line">	get_name: function()&#123;</div><div class="line">		return this.name;</div><div class="line">	&#125;,</div><div class="line">	says: function()&#123;</div><div class="line">		return this.saying || &apos;&apos;;</div><div class="line">	&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>我们先创建一个对象，一旦有了这个对象，我们就可以利用Object.beget()方法构造出更多的实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">var myCat = Object.beget(myMammal);</div><div class="line">myCat.name = &quot;Henrietta&quot;;</div><div class="line">myCat.saying = &quot;meow&quot;;</div><div class="line">myCat.purr = function(n)&#123;</div><div class="line">	var i, s = &apos;&apos;;</div><div class="line">	for(i = 0; i &lt; n; i+=1)&#123;</div><div class="line">		if(s)&#123;</div><div class="line">			s += &apos;-&apos;;</div><div class="line">		&#125;</div><div class="line">		s += &apos;r&apos;;</div><div class="line">	&#125;</div><div class="line">	return s;</div><div class="line">&#125;;</div><div class="line">myCat.get_name = function()&#123;</div><div class="line">	return this.says + &apos; &apos; + this.name + &apos; &apos; + this.says;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这种方式叫“差异化继承”。通过制定一个新的对象，指明了它与所基于的基本对象的区别。<br>其实就是原型继承，但要注意的是基础原型上的属性和方法是共享的。如果新对象修改了基础原型的属性或方法，原对象也会得到相应的呈现。</p>
<h2 id="函数化"><a href="#函数化" class="headerlink" title="函数化"></a>函数化</h2><p>构造私有的属性。</p>
<ol>
<li>创建一个新对象。</li>
<li>选择性地定义私有实例变量和方法。这些都是在函数中通过var语句定义的普通变量。</li>
<li>给这个心对象扩充方法。这些方法将拥有特权去访问参数以及在第二部中通过var语句定义的变量。</li>
<li>它返回那个新对象。</li>
</ol>
<p>函数化构造器的伪代码模板。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var constructor = function(spec, my)&#123;</div><div class="line">	var that,其他私有的实例变量;</div><div class="line">	my = my || &#123;&#125;;</div><div class="line">    把共享的变量和函数添加到my中</div><div class="line">	that = 一个新对象</div><div class="line"></div><div class="line">	添加给that 的特权方法</div><div class="line">	return that;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>spec对象包含构造器需要构造一个新实例的所有信息。spec的内容可能会被复制到私有变量胡总恶化是其他函数中。或者方法可以在需要的时候访问spec的信息。<br>my对象是一个为继承链中的构造器提供秘密共享的容器。如果没有传入my对象，那就创建一个my对象。</p>
<p>接下来扩充that。比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var methodcal = function()&#123;</div><div class="line">	...</div><div class="line">&#125;;</div><div class="line">that.methodcal = methodcal;</div></pre></td></tr></table></figure></p>
<p>分两步定义methodcal的好处是如果其他方法想调用methodcal就可以直接调用methodcal()而不是that.methodcal()。如果该实例被破坏或篡改，甚至被that.methodcal替换掉，调用methodcal()的方法同样会继续工作，因为它们私有的methodcal不受该实例修改的影响。</p>
<p>最后返回that。</p>
<p>name 和 saying 属性现在是完全私有的。只有通过get_name和says两个特权方法才能访问。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var mammal = function(spec)&#123;</div><div class="line">	var that = &#123;&#125;;</div><div class="line">	that.get_name = function()&#123;</div><div class="line">		return spec.name;</div><div class="line">	&#125;;</div><div class="line">	that.says = function()&#123;</div><div class="line">		return spec.saying || &apos;&apos;;</div><div class="line">	&#125;;</div><div class="line">	return that;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var myMammal = mammal(&#123;name: &apos;Herb&apos;&#125;);</div></pre></td></tr></table></figure></p>
<p>其实就是JS高级程序设计三中的<strong>稳妥构造函数模式。</strong></p>
<p>在伪类模式中，构造器函数Cat不得不重复构造Mammal已经完成的工作。<br>在函数化模式中就不再需要了。因为构造器Cat将会调用构造器Mammal，让Mammal去做对象创建中的大部分工作，所以Cat只需关注自身的差异即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">var cat = function(spec)&#123;</div><div class="line">	spec.saying = spec.saying || &apos;meow&apos;;</div><div class="line">	var that = mammal(spec);</div><div class="line">	that.purr = function(n)&#123;</div><div class="line">		var i, s = &apos;&apos;;</div><div class="line">		for(i=0; i &lt; n; i+=1)&#123;</div><div class="line">			if(s) &#123;</div><div class="line">				s += &apos;-&apos;;</div><div class="line">			&#125;</div><div class="line">			s += &apos;r&apos;;</div><div class="line">		&#125;</div><div class="line">		return s;</div><div class="line">	&#125;;</div><div class="line">	that.get_name = function()&#123;</div><div class="line">		return that.says() + &apos; &apos; + spec.name + &quot; &quot; + that.says();</div><div class="line">	&#125;</div><div class="line">	return that;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var myCat = cat(&#123;name: &apos;Henrietta&apos;&#125;);</div></pre></td></tr></table></figure></p>
<p>函数化模式提供一个处理父类方法的方法。构造一个superior方法，取得一个方法名并返回调用那个方法的函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">Object.method(&quot;superior&quot;, function(name)&#123;</div><div class="line">	var that = this,</div><div class="line">		method = that[name];</div><div class="line">	return function()&#123;</div><div class="line">		return method.apply(that, arguments);</div><div class="line">	&#125;;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">var coolcat = function(spec)&#123;</div><div class="line">	var that = cat(spec),</div><div class="line">		super_get_name = that.superior(&quot;get_name&quot;);</div><div class="line">		that.get_name = function(n)&#123;</div><div class="line">			return &quot;like &quot; + super_get_name() + &quot; baby&quot;;</div><div class="line">		&#125;;</div><div class="line">	return that;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var myCoolCat = coolcat(&#123;name: &quot;Bix&quot;&#125;);</div><div class="line">var name = myCoolCat.get_name();</div><div class="line">console.log(name);</div></pre></td></tr></table></figure></p>
<p>函数模块化有很多的灵活性。它不仅不像伪类模式那样需要很多功夫，还让我们更好的封装和信息隐藏，以及访问父类的方法的能力。</p>
<h2 id="部件"><a href="#部件" class="headerlink" title="部件"></a>部件</h2><p>我们可以从一套部件中组合出对象来。例如构造一个能添加简单事件处理特性到任何对象上的函数。它会给对象添加一个on方法，一个fire方法和一个私有的时间注册表对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">var eventuality = function(that)&#123;</div><div class="line">	var registry = &#123;&#125;;</div><div class="line">	that.fire = function(event)&#123;</div><div class="line">	//在一个对象上触发一个事件，该事件可以是一个包含事件名称的字符串，或者是一个拥有包含事件名称的type属性的对象。</div><div class="line">	//通过on方法注册是事件处理程序中匹配事件名称的函数将被调用。</div><div class="line">	//</div><div class="line">		var array,</div><div class="line">			func,</div><div class="line">			handler,</div><div class="line">			i,</div><div class="line">			type = typeof event === &apos;string&apos; ? event : event.type;</div><div class="line">			//如果这个事件存在一组事件处理程序，那么遍历它们并按顺序依次执行</div><div class="line">			if（registry.hasOwnProperty(type) &#123;</div><div class="line">				array = registry[type];</div><div class="line">				for(i = 0; i &lt; array.length ;i ++)&#123;</div><div class="line">					handler = array[i];</div><div class="line"></div><div class="line">					func = handler.method;</div><div class="line">					if (typeof func === &apos;string&apos;) &#123;</div><div class="line">						func = this[func];</div><div class="line">					&#125;</div><div class="line"></div><div class="line">					//调用一个处理程序。如果该条目包含参数，那么传递它们过去，否则传递该事件对象。</div><div class="line">					</div><div class="line">					func.apply(this,handler.parameters || [event]);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">		return this;</div><div class="line">	&#125;;</div><div class="line">	that.on = function(type ,method, parameters)&#123;</div><div class="line">		var handler = &#123;</div><div class="line">			method: method,</div><div class="line">			parameters: parameters</div><div class="line">		&#125;;</div><div class="line">		if (registry.hasOwnProperty(type)) &#123;</div><div class="line">			registry[type].push(handler);</div><div class="line">		&#125; else &#123;</div><div class="line">			registry[type] = [handler]</div><div class="line">		&#125;</div><div class="line">		return this;</div><div class="line">	&#125;;</div><div class="line">	return that;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[啊哈算法之排序]]></title>
      <url>https://zaynex.github.io/2016/08/15/%E5%95%8A%E5%93%88%E7%AE%97%E6%B3%95%E4%B9%8B%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>今天学了桶排序（简化版）、冒泡和快排。想不到桶排序是时间复杂度最低的，但花费内存大， 不过也符合计算机时间换空间的概念。<br>快速排序其实就是冒泡排序升级版，采用了<strong>分治</strong>的思想。<br>总的来说，还是很满意的。<br><a id="more"></a></p>
<h3 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">int main(int argc, char *argv[])</div><div class="line">&#123;</div><div class="line">	int a[11], i, j, t;</div><div class="line">	for(i=0; i&lt;=10;i++)&#123;</div><div class="line">		a[i]= 0;</div><div class="line">	&#125;</div><div class="line">	for(j=1;j&lt;=5;j++)&#123;</div><div class="line">		scanf(&quot;%d&quot;, &amp;t);</div><div class="line">		a[t]++;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	for(i=0; i&lt;=10;i++) &#123;</div><div class="line">		for(j=1; j&lt;=a[i]; j++)&#123; // 桶内出现几次就打印几次 </div><div class="line">			printf(&quot;%d &quot;, i );</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	getchar(); </div><div class="line">	return 0;</div><div class="line">	//桶排序的方式是将所有可能的情况都列入数组内，借助数组序号分别读取（数组序号本身就是排序了） </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line"></div><div class="line">struct student&#123;</div><div class="line">	char name[21];</div><div class="line">	char score;</div><div class="line">&#125;;</div><div class="line">//结构体保存姓名和分数 </div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">	struct student a[100], t; </div><div class="line">	int i,j,n;</div><div class="line">	scanf(&quot;%d&quot;, &amp;n);</div><div class="line">	for(i=1; i&lt;=n; i++)</div><div class="line">		scanf(&quot;%s %d&quot;,&amp;a[i].name, &amp;a[i].score);</div><div class="line">	//最好是1开头，原因未知 </div><div class="line">	for(i=1; i&lt;=n-1; i++)&#123;</div><div class="line">		for(j=1; j&lt;=n-i; j++)&#123;</div><div class="line">			if(a[j].score &lt; a[j+1].score)&#123;</div><div class="line">				t = a[j];</div><div class="line">				a[j] = a[j+1];</div><div class="line">				a[j+1] = t;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">			</div><div class="line">	for(i=1; i&lt;=n ;i++)&#123;</div><div class="line">		printf(&quot;%s %d\n &quot;, a[i].name,a[i].score);</div><div class="line">	&#125;	</div><div class="line">	getchar();</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>冒泡排序的核心为双层嵌套循环。算法复杂度是N^2.</p>
<p>快速排序因为交换的距离变长了，所以比冒泡排序快。在最快的情况下算法复杂度还是N^2。平均时间复杂度为NlogN。</p>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">int a[101], n;</div><div class="line">void quickSort(int left, int right)&#123;</div><div class="line">	int i,j,t,temp;</div><div class="line">	if(left &gt; right)&#123;</div><div class="line">		return ;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	temp = a[left];</div><div class="line">	i = left;</div><div class="line">	j = right;</div><div class="line">	</div><div class="line">	while(i!=j)&#123;</div><div class="line">		//当i和j没有相遇的时候 </div><div class="line">		while(a[j]&gt;=temp &amp;&amp; j&gt;i)&#123;</div><div class="line">			j--;</div><div class="line">		&#125;</div><div class="line">		//先从右边开始搜索 </div><div class="line">		while(a[i]&lt;=temp &amp;&amp; i&lt;j)&#123;</div><div class="line">			i++;</div><div class="line">		&#125;</div><div class="line">		//先从左边开始搜索 </div><div class="line">		if(i &lt; j)&#123;</div><div class="line">			t = a[i];</div><div class="line">			a[i] = a[j];</div><div class="line">			a[j] = t;</div><div class="line">		&#125;</div><div class="line">		//交换他们的值 </div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	//将基准数归位</div><div class="line">	a[left] = a[i];</div><div class="line">	a[i] = temp; </div><div class="line">	</div><div class="line">	quickSort(left, i-1); // 递归 </div><div class="line">	quickSort(i+1, right);	</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main()&#123;</div><div class="line">	int i, j, t;</div><div class="line">	scanf(&quot;%d&quot;, &amp;n);</div><div class="line">	for(i=1; i&lt;=n; i++)&#123;</div><div class="line">		scanf(&quot;%d&quot;, &amp;a[i]);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	quickSort(1, n);</div><div class="line">	</div><div class="line">	for(i=1; i&lt;=n; i++)&#123;</div><div class="line">		printf(&quot;%d &quot;, a[i]);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	getchar();</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="数组去重再排序"><a href="#数组去重再排序" class="headerlink" title="数组去重再排序"></a>数组去重再排序</h2><h3 id="木桶去重排序"><a href="#木桶去重排序" class="headerlink" title="木桶去重排序"></a>木桶去重排序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">int main()&#123;</div><div class="line">	int a[1001], n, t, i;</div><div class="line">	for(i=1; i&lt;=1000; i++)&#123;</div><div class="line">		a[i] = 0;</div><div class="line">	&#125;//初始化</div><div class="line">	</div><div class="line">	scanf(&quot;%d&quot;, &amp;n);</div><div class="line">	</div><div class="line">	for(i=1; i&lt;=n; i++)&#123;</div><div class="line">		scanf(&quot;%d&quot;, &amp;t);</div><div class="line">		a[t] = 1;</div><div class="line">	&#125; //将数组坐标值设为1表示存在 </div><div class="line">	</div><div class="line">	for(i=1; i&lt;=1000;i++)&#123;</div><div class="line">		if(a[i] == 1)&#123;</div><div class="line">			printf(&quot;%d &quot;, i);</div><div class="line">		&#125;//如果该坐标值为1，则从小到大输出坐标值</div><div class="line">	&#125;</div><div class="line">	getchar();</div><div class="line">	return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>算法复杂度O（N+M）</p>
<h2 id="先排序再去重"><a href="#先排序再去重" class="headerlink" title="先排序再去重"></a>先排序再去重</h2><h3 id="冒泡"><a href="#冒泡" class="headerlink" title="冒泡"></a>冒泡</h3><p>#include <stdio.h><br>int main(){<br>    int a[1001], n, t, i,j;<br>    scanf(“%d”, &amp;n);<br>    for(i=1; i&lt;=n;i++){<br>        scanf(“%d”, &amp;a[i]);<br>    }</stdio.h></p>
<pre><code>//开始冒泡排序
for(i=1; i&lt;n-1; i++){
    for(j=1; j&lt;n-i; j++){
        if(a[j] &gt; a[j+1]) {
            t = a[j];
            a[j] = a[j+1];
            a[j+1] = t;                
        }
    }
} 

printf(&quot;%d &quot;, a[1]);
for(i=2; i&lt;=n; i++){
    if( a[i] != a[i-1]){
        printf(&quot;%d &quot;, a[i]);
    }
} 
getchar();
return 0;
</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">在输出时判断前后是否相同。</div><div class="line"></div><div class="line"></div><div class="line">机器1S大概运行10亿次。虽然桶排序的时间复杂度是O(M+N)，但要申请较大的内存。如果数字过大，就无法使用。</div><div class="line">冒泡排序时间复杂度为N^2。当数字较多时，该排序算法依然很慢，但是快速排序算法就能很好的平衡该问题。</div><div class="line">### 快速排序</div></pre></td></tr></table></figure></p>
<p>#include <stdio.h><br>int a[101], n;<br>void quickSort(int left, int right){<br>int i,j,temp,t;</stdio.h></p>
<p>if(left &gt; right){<br>    return ;<br>}</p>
<p>temp = a[left];<br>i = left;<br>j = right;</p>
<p>while(i!=j){<br>    while(a[j] &gt;= temp &amp;&amp; i&lt;j){<br>        j–;<br>    }<br>    while(a[i] &lt;= temp &amp;&amp; i&lt;j) {<br>        i++;<br>    }</p>
<pre><code>if(i&lt;j){
    t = a[i];
    a[i] = a[j];
    a[j] = t;
}
</code></pre><p>}<br>a[left] = a[i];<br>a[i] = temp;</p>
<p>quickSort(left, i-1);<br>quickSort(i+1,right);<br>}</p>
<p>int main(){<br>    int n, t, i,j;<br>    scanf(“%d”, &amp;n);<br>    for(i=1; i&lt;=n;i++){<br>        scanf(“%d”, &amp;a[i]);<br>    }</p>
<pre><code>quickSort(1,n);

printf(&quot;%d &quot;, a[1]);
for(i=2; i&lt;=n; i++){
    if( a[i] != a[i-1]){
        printf(&quot;%d &quot;, a[i]);
    }
} 
getchar();
return 0;
</code></pre><p>}<br>```</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript高级程序设计三第十三章事件]]></title>
      <url>https://zaynex.github.io/2016/08/15/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%89%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0%E4%BA%8B%E4%BB%B6/</url>
      <content type="html"><![CDATA[<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>###　DOM0级事件处理程序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var btn = document.getElementById(&quot;div&quot;);</div><div class="line">btn.onclick = function()&#123;</div><div class="line">	//code</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<h3 id="DOM2级事件处理程序"><a href="#DOM2级事件处理程序" class="headerlink" title="DOM2级事件处理程序"></a>DOM2级事件处理程序</h3><p>好处是可以添加多个事件，false表示冒泡阶段触发<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var btn= document.getElementById(&apos;button&apos;);</div><div class="line">btn.addEventListener(&quot;click&quot;, function()&#123;</div><div class="line">	alert(&quot;hello!&quot;);</div><div class="line">&#125;, false);</div><div class="line">btn.addEventListener(&quot;click&quot;, function()&#123;</div><div class="line">	alert(&quot;world&quot;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="移除事件"><a href="#移除事件" class="headerlink" title="移除事件"></a>移除事件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&quot;myDiv&quot;&gt;</div><div class="line">	&lt;input type=&quot;button&quot; id=&quot;myBtn&quot; value=&quot;click me &quot;&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">	&lt;script&gt;</div><div class="line">	var btn = document.getElementById(&apos;myBtn&apos;);</div><div class="line">	btn.onclick = function  (argument) &#123;</div><div class="line">     		//先执行某些操作</div><div class="line">		btn.onclick =null; // 手工移除</div><div class="line">		document.getElementById(&apos;myDiv&apos;).innerHTML = &quot;Processing&quot;;</div><div class="line">	&#125;</div><div class="line">		//传统的做法是为了避免双击，将单个按钮移除并替换成了一条消息，但问题在于当按钮从页面中移除时，依然带有事件处理程序。在&lt;div&gt;设置 innerHTML 可以把按钮移走，但事件处理程序仍然与按钮保持引用关系。因此建议手工删除</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<p>对于DOM2级需要使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var btn = document.getElementById(&apos;myBtn&apos;);</div><div class="line">var handler = function()&#123;</div><div class="line">	alert(&quot;hello&quot;);</div><div class="line">&#125;;</div><div class="line">btn.removeEventListner(&quot;click&quot;,handler,false);</div></pre></td></tr></table></figure></p>
<p>这里添加handler参数时因为删除事件必须要与添加事件的处理程序一致。</p>
<h3 id="IE处理程序"><a href="#IE处理程序" class="headerlink" title="IE处理程序"></a>IE处理程序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var btn = document.getElementById(&apos;button&apos;);</div><div class="line"></div><div class="line">btn.attachEvent(&quot;onclick&quot;, function()&#123;</div><div class="line">	alert(this === window); //true</div><div class="line">&#125;);</div><div class="line">var handler = function () &#123;</div><div class="line">	alert(&quot;hi&quot;);</div><div class="line">&#125;</div><div class="line">btn.attachEvent(&quot;onclick&quot;, handler)</div><div class="line"></div><div class="line">//删除事件</div><div class="line">btn.detachEvent(&quot;onclick&quot;, handler);</div></pre></td></tr></table></figure>
<p>事件会反向执行，先输出 hi， 再输出 true；(IE9已修复)</p>
<h3 id="跨浏览器事件处理程序"><a href="#跨浏览器事件处理程序" class="headerlink" title="跨浏览器事件处理程序"></a>跨浏览器事件处理程序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var EventUtil = &#123;</div><div class="line">	addHandler: function  (element, type, handler) &#123;</div><div class="line">		if (element.addEventListener) &#123;</div><div class="line">			element.addEventListener(type, handler, false);</div><div class="line">		&#125; else if (element.attchEvent) &#123;</div><div class="line">			element.attchEvent(&quot;on&quot; + type, handler);</div><div class="line">		&#125; else &#123;</div><div class="line">			element[&quot;on&quot; + type] = handler;</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var btn = document.getElementById(&apos;id&apos;);</div><div class="line">btn.onclick =function  (event) &#123;</div><div class="line">	alert(event.currentTarget === this); // true</div><div class="line">	alert(event.target === this); //true;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>currentTarget表示的是其事件处理程序正在处理事件的那个元素（就是代码里写的），Target表示你在实际操作时所触发的目标。在事件处理程序内部，this始终等于currentTarget的值。<br>由于click 的目标是按钮。三个值是相同的。</p>
<p>如果事件处理程序存在于按钮的父节点中，那么是不相同的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">document.body.onclick = function (event) &#123;</div><div class="line">	alert(event.currentTarget === document.body); // true;</div><div class="line">	alert(event.target === document.getElementById(&quot;id&quot;)); // true</div><div class="line">	alert(this === document.body); /// true</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>this 和 currentTarget 都是 document.body。<br>target是按钮，因为他才是click 的真正目标。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">var btn = document.getElementById(&apos;id&apos;);</div><div class="line">var handler = function  (event) &#123;</div><div class="line">	switch(event.type)&#123;</div><div class="line">		case &quot;click&quot;:</div><div class="line">			alert(&quot;clicked&quot;);</div><div class="line">			break;</div><div class="line"></div><div class="line">		case &quot;mouseover&quot;:</div><div class="line">			event.target.style.backgroundColor = &quot;red&quot;;</div><div class="line">			break;</div><div class="line"></div><div class="line">		case &quot;mouseout&quot;:</div><div class="line">			event.target.style.backgroundColor = &quot;&quot;;</div><div class="line">			break;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">btn.onclick = handler;</div><div class="line">btn.onmouseover = handler;</div><div class="line">btn.onmouseout = handler;</div></pre></td></tr></table></figure>
<h3 id="取消事件"><a href="#取消事件" class="headerlink" title="取消事件"></a>取消事件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//取消默认事件</div><div class="line">event.preventDefault();</div><div class="line">//取消事件传播</div><div class="line">evenet.stopPropagation();</div><div class="line">//IE取消默认事件</div><div class="line">window.event.returnValue = false;</div><div class="line">//IE取消事件冒泡</div><div class="line">window.event.cancelBubble = true;</div></pre></td></tr></table></figure>
<h3 id="跨浏览器事件对象"><a href="#跨浏览器事件对象" class="headerlink" title="跨浏览器事件对象"></a>跨浏览器事件对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">var EventUil = &#123;</div><div class="line">	addHander : function(element, type, handler) &#123;</div><div class="line">		if (element.addEventListener) &#123;</div><div class="line">			element.addEventListener(type, handler, false);</div><div class="line">		&#125; else if (element.attachEvent) &#123;</div><div class="line">			element.attachEvent(type, handler);</div><div class="line">		&#125; else &#123;</div><div class="line">			element[&quot;on&quot; + type] = handler;</div><div class="line">		&#125;</div><div class="line">	&#125;,</div><div class="line"></div><div class="line">	removeHander: function(element, type, handler) &#123;</div><div class="line">		if(element.removeEventListener) &#123;</div><div class="line">			element.removeEventListener(type ,handler, false);</div><div class="line">		&#125; else if (element.detachEvent) &#123;</div><div class="line">			element.detachEvent(type, handler);</div><div class="line">		&#125;else &#123;</div><div class="line">			element[&quot;on&quot; + type] = null;</div><div class="line">		&#125;</div><div class="line">	&#125;,</div><div class="line">	</div><div class="line">	getEvent:function(event) &#123;</div><div class="line">		return event ? event : window.event;</div><div class="line">	&#125;,</div><div class="line"></div><div class="line">	getTarget: function(event) &#123;</div><div class="line">		return event.target || event.srcElement;</div><div class="line">	&#125;,</div><div class="line"></div><div class="line">	preventDefault: function(event)&#123;</div><div class="line">		if(event.preventDefault)&#123;</div><div class="line">			event.preventDefault();</div><div class="line">		&#125; else &#123;</div><div class="line">			event.returnValue = false;</div><div class="line">		&#125;</div><div class="line">	&#125;,</div><div class="line"></div><div class="line">	stopPropagation: function (event) &#123;</div><div class="line">		if (event.stopPropagation)&#123;</div><div class="line">			event.stopPropagation();</div><div class="line">		&#125; else &#123;</div><div class="line">			event.cancelBubble = true;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="事件类型"><a href="#事件类型" class="headerlink" title="事件类型"></a>事件类型</h3><ul>
<li>mouseenter: 在鼠标光标从元素外部首次移动到了元素范围内触发。事件不冒泡，而且移动到后代元素不触发。</li>
<li>mouseleave: 在位于元素上方的鼠标移动到元素范围外时触发，事件不冒泡，而且在移动光标到后代元素上不会触发。</li>
<li>mousemove: 在鼠标指针在元素内部移动时重复触发</li>
<li>mouseout: 在鼠标指针位于一个元素上方，将其移动到另一个元素时触发。（也有可能只是移动到另一个子元素）</li>
<li>mouseover: 鼠标指针位于一个元素的上方，将其移动到另一个元素时触发。（有可能只是移动到另一个子元素）</li>
</ul>
<h4 id="客户端坐标位置"><a href="#客户端坐标位置" class="headerlink" title="客户端坐标位置"></a>客户端坐标位置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">EventUil.addHander(div, &quot;click&quot;, function()&#123;</div><div class="line">	event = EventUil.getEvent(event);</div><div class="line">	alert(&quot;clientX:&quot; + event.clientX + &quot;  clientY:&quot; + event.clientY);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><img src="http://note.youdao.com/yws/res/34268/WEBRESOURCE8acaf78a9877416974e19aa3e57c7b98" alt="image"><br>不包括客户端滚动距离，只是客户端可视区到鼠标点击的距离。</p>
<h4 id="页面坐标位置"><a href="#页面坐标位置" class="headerlink" title="页面坐标位置"></a>页面坐标位置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">EventUil.addHander(btn, &quot;click&quot;, function()&#123;</div><div class="line">	event = EventUil.getEvent(event);</div><div class="line">	alert(&quot;pageX:&quot; + event.pageX + &quot;  pageY:&quot; + event.pageY);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p><img src="http://note.youdao.com/yws/res/34266/WEBRESOURCE8c6df7a11d2f8a3859e0bede9e47bbc2" alt="image"><br>在没有滚动的情况下，pageX和clientX是相等的。</p>
<h3 id="屏幕坐标位置"><a href="#屏幕坐标位置" class="headerlink" title="屏幕坐标位置"></a>屏幕坐标位置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">EventUil.addHander(btn, &quot;click&quot;, function()&#123;</div><div class="line">	event = EventUil.getEvent(event);</div><div class="line">	alert(&quot;screenX:&quot; + event.screenX + &quot;  screenY:&quot; + event.screenY);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><img src="http://note.youdao.com/yws/res/34270/WEBRESOURCE9b0d4055ae7666983a95c86102c54cb5" alt="image"></p>
<h3 id="鼠标按钮"><a href="#鼠标按钮" class="headerlink" title="鼠标按钮"></a>鼠标按钮</h3><p>0表示左键，2表示右键，1表示中间键（非IE）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">	getButton: function(event) &#123;</div><div class="line">		if(document.implementation.hasFeature(&quot;MouseEvents&quot;, &quot;2.0&quot;))&#123;</div><div class="line">			return event.button;</div><div class="line">		&#125;else &#123;</div><div class="line">			switch(event.button) &#123;</div><div class="line">				case 0:</div><div class="line">				case 1:</div><div class="line">				case 3:</div><div class="line">				case 5:</div><div class="line">				case 7:</div><div class="line">					return 0;</div><div class="line">				case 2:</div><div class="line">				case 6:</div><div class="line">					return 2;</div><div class="line">				case 4:</div><div class="line">					return 1;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">EventUil.addHander(btn, &quot;mousedown&quot;, function()&#123;</div><div class="line">	event = EventUil.getEvent(event);</div><div class="line">	alert(EventUil.getButton(event));</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="keycode"><a href="#keycode" class="headerlink" title="keycode"></a>keycode</h3><p><img src="http://note.youdao.com/yws/res/34272/WEBRESOURCE549fb59c8ce833862b5cc3126a49757f" alt="image"><br><img src="http://note.youdao.com/yws/res/34274/WEBRESOURCE8e9065794e6576a1fc515cdc36ca8300" alt="image"><br><img src="http://note.youdao.com/yws/res/34276/WEBRESOURCE08ebd4e32d49bd98b88546e0a38e93cb" alt="image"></p>
<h2 id="性能与内存（事件委托）"><a href="#性能与内存（事件委托）" class="headerlink" title="性能与内存（事件委托）"></a>性能与内存（事件委托）</h2><p>事件委托利用冒泡事件，只指定一个事件处理程序，可以管理某一类型所有的事件。在DOM树上尽量最高的层次上添加一个事件处理程序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">	&lt;ul id=&quot;mylinks&quot;&gt;</div><div class="line">		&lt;li id=&quot;gosomewhere&quot;&gt;GO somewhere&lt;/li&gt;</div><div class="line">		&lt;li id=&quot;dosomething&quot;&gt;Do something&lt;/li&gt;</div><div class="line">		&lt;li id=&quot;sayhi&quot;&gt;Sayhi&lt;/li&gt;</div><div class="line">	&lt;/ul&gt;</div><div class="line">var item1 = document.getElementById(&quot;gosomewhere&quot;);</div><div class="line">var item2 = document.getElementById(&apos;dosomething&apos;);</div><div class="line">var item3 = document.getElementById(&apos;sayhi&apos;);</div><div class="line"></div><div class="line">EventUil.addHandler(item1, &quot;click&quot;, function  (event) &#123;</div><div class="line">	location.href = &quot;http://www.worx.com&quot;;</div><div class="line">&#125;);</div><div class="line">EventUil.addHandler(item2, &quot;click&quot;, function (event)&#123;</div><div class="line">	document.title = &quot;I changed the document title&quot;;</div><div class="line">&#125;);</div><div class="line">EventUil.addHandler(item3, &quot;click&quot;, function  (event) &#123;</div><div class="line">	alert(&quot;hi&quot;)</div><div class="line">&#125;);</div><div class="line">// 在一个负责的web应用程序中，对所有可单机的元素都采用该方式，将会造成大量代码</div><div class="line">var list = document.getElementById(&apos;mylinks&apos;);</div><div class="line"></div><div class="line">EventUil.addHandler(list, &quot;click&quot;, function  (event) &#123;</div><div class="line">	event = EventUil.getEvent(event);</div><div class="line">	var target = EventUil.getTarget(event);</div><div class="line"></div><div class="line">	switch(target.id) &#123;</div><div class="line">		case &quot;dosomething&quot; :</div><div class="line">			document.title = &quot;I changed the document title&quot;;</div><div class="line">			break;</div><div class="line">		case &quot;gosomewhere&quot; :</div><div class="line">			location.href = &quot;http://www.worx.com&quot;;</div><div class="line">			break;</div><div class="line">		case &quot;sayhi&quot; :</div><div class="line">			alert(&quot;hi&quot;)</div><div class="line">			break;</div><div class="line">	&#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript高级程序设计三第十一章DOM扩展]]></title>
      <url>https://zaynex.github.io/2016/08/14/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%89%E7%AC%AC11%E7%AB%A0DOM%E6%89%A9%E5%B1%95/</url>
      <content type="html"><![CDATA[<h2 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h2><h3 id="H5拓展方法遍历元素"><a href="#H5拓展方法遍历元素" class="headerlink" title="H5拓展方法遍历元素"></a>H5拓展方法遍历元素</h3><p>（1）childElementCount：返回子元素（不包括文本节点和注释）的个数。<br>（2）firstElementChild：指向第一个子元素；<br>（3）lastElementChild：指向最后一个子元素；<br>（4）previousElementSibling：指向前一个同辈元素；<br>（5）nextElementSibling：指向后一个同辈元素；<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">var i,len,	</div><div class="line">child = element.firstChild;</div><div class="line">while(child != element.lastChild)&#123;</div><div class="line">	if(child.nodeType == 1)&#123;  //检查是否为元素，避免文本节点干扰</div><div class="line">		processChild(child);</div><div class="line">	&#125;</div><div class="line">	child = child.nextSibling;</div><div class="line">&#125;</div><div class="line"></div><div class="line">//使用 Element Traversal</div><div class="line">var i,len,</div><div class="line">child = element.firstElementChild;</div><div class="line">while(child != element.lastElementChild)&#123;</div><div class="line">	processChild(child);</div><div class="line">	child = child.nextElementSibing;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>支持该Element Traversal 规范的浏览器 IE9+。</p>
<h2 id="HTML5-1"><a href="#HTML5-1" class="headerlink" title="HTML5"></a>HTML5</h2><h3 id="getElementsByClassName"><a href="#getElementsByClassName" class="headerlink" title="getElementsByClassName"></a>getElementsByClassName</h3><p>在IE9+的版本可以使用该方法直接添加calss名。</p>
<h3 id="classList"><a href="#classList" class="headerlink" title="classList"></a>classList</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">var div = document.getElementsByTagName(&quot;div&quot;)[0];</div><div class="line">var classNames = div.className.split(/\s+/);</div><div class="line"></div><div class="line">var pos = -1,</div><div class="line">	i,</div><div class="line">	len;</div><div class="line">for(i=0, len=classNames.length; i&lt;len; i++)&#123;</div><div class="line">	if(classNames[i] == &quot;user&quot;)&#123;</div><div class="line">		pos = i;</div><div class="line">		break;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">classNames.splice(i,1); //删除类名</div><div class="line"></div><div class="line">div.className = classNames.join(&quot; &quot;);</div><div class="line">//添加类名拼成字符串重新设置</div><div class="line">// var div = document.getElementsByTagName(&quot;div&quot;)[0];</div><div class="line"></div><div class="line"></div><div class="line">// div.classList.remove(&quot;user&quot;);</div><div class="line">		</div><div class="line">	div.classList.toggle(&quot;user&quot;);//如果有user的className就删除，如果没有就新建一个</div><div class="line">	div.classList.add(&quot;user&quot;);//新建className 为 user的值，如果值已存在，则不添加</div><div class="line">	if(div.classList.contains(&quot;bd&quot;)&amp;&amp;div.classList.contains(&quot;user&quot;))&#123;</div><div class="line">	 // code</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>除非要删除所有雷鸣或者重写所有class属性，使用classList是很不错的选择。<br>classList属性支持浏览器有火狐 chrome ，其他的都不行。</p>
<h3 id="HTML5焦点管理"><a href="#HTML5焦点管理" class="headerlink" title="HTML5焦点管理"></a>HTML5焦点管理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var button = document.getElementById(&apos;mybutton&apos;);</div><div class="line">button.focus();</div><div class="line">alert(document.activeElement === button); //true</div><div class="line">alert(document.hasFocus());</div><div class="line">//通过检测文档是否获得了焦点，可以知道用户是否正在与页面交互</div></pre></td></tr></table></figure>
<h3 id="innerHTML"><a href="#innerHTML" class="headerlink" title="innerHTML"></a>innerHTML</h3><p>返回的是调用元素的所有子节点（包括元素、注释和文本节点）<br>写入模式下，会把里面的内容解析成DOM熟，替换调用元素原来的所有子节点。</p>
<h3 id="内存与性能问题"><a href="#内存与性能问题" class="headerlink" title="内存与性能问题"></a>内存与性能问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">for (var i=0,len=values.length; i&lt;len; i++)&#123;</div><div class="line">	ul.innerHTML += &quot;&lt;li&gt;&quot; + values[i] + &quot;&lt;/li&gt;&quot;;</div><div class="line">&#125;//避免循环操作，每次循环要从innerHTML读取一次信息，而设置innerHTML相当于创建HTML解析器，但是创建和销毁解析器也会带来很大性能损失。因此要将innerHTML访问次数控制在合理范围</div><div class="line"></div><div class="line">//解决办法，单独构建字符串，然后一次性将结果字符串赋值给innerHTML.</div><div class="line"></div><div class="line">var itemsHtml = &quot;&quot;;</div><div class="line">for (var i=0, len=values.length; i&lt;len ;i++)&#123;</div><div class="line">	itemsHtml += &quot;&lt;li&gt;&quot; + values[i] + &quot;&lt;/li&gt;&quot;;</div><div class="line">&#125;</div><div class="line">ul.innerHTML = itemsHtml;</div></pre></td></tr></table></figure>
<h3 id="children"><a href="#children" class="headerlink" title="children"></a>children</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var childCount = element.children.length;</div><div class="line">var firstChild = element.children[0];</div></pre></td></tr></table></figure>
<p>由于浏览器在处理文本空白符中存在差异，因此出现了该属性。</p>
<h3 id="containes"><a href="#containes" class="headerlink" title="containes"></a>containes</h3><p>containes方法确认该节点是否包含子代节点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">var result = document.documentElement.compareDocumentPosition(document.body);</div><div class="line">		alert(!!(result &amp; 16));</div><div class="line">		//20</div><div class="line">        //16表示的是被包含（给定的节点是参考节点的后代）</div><div class="line"></div><div class="line">		function contains(refNode ,otherNode)&#123;</div><div class="line">			if (typeof refNode.contains == &quot;function&quot; &amp;&amp;(!client.engine.webkit || client.engine.webkit &gt;=522))&#123;</div><div class="line">				return refNode.contains(otherNode);</div><div class="line">			&#125; else if (typeof refNode.compareDocumentPosition == &quot;function&quot;)&#123;</div><div class="line">				return !!(refNode.compareDocumentPosition(otherNode) &amp;16);</div><div class="line">			&#125; else &#123;</div><div class="line">				var node = otherNode.parentNode;</div><div class="line">				do &#123;</div><div class="line">					if (node ===refNode)&#123;</div><div class="line">						return true;</div><div class="line">					&#125;else &#123;</div><div class="line">						node = node.parentNode;</div><div class="line">					&#125;</div><div class="line">				&#125;while (node !== null);</div><div class="line">				return false;</div><div class="line">			&#125;</div><div class="line">		&#125;</div></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript高级程序设计三DOM操作（含微专业）]]></title>
      <url>https://zaynex.github.io/2016/08/12/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%89DOM%E6%93%8D%E4%BD%9C%EF%BC%88%E5%90%AB%E5%BE%AE%E4%B8%93%E4%B8%9A%EF%BC%89/</url>
      <content type="html"><![CDATA[<h2 id="节点操作"><a href="#节点操作" class="headerlink" title="节点操作"></a>节点操作</h2><p>querySelectorAll获取的是静态的列表，当时获取的是多少就是多少。<br><a id="more"></a><br>返回的是动态的列表有（NodeList）：</p>
<ul>
<li>getElementsByTagName</li>
<li>getElementsByClassName<br>因为是动态的，最好将他们提前保存起来，减少访问开销。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var divs = document.getElementsByTagName(&quot;div&quot;);</div><div class="line">len = divs.length;</div><div class="line">for(var i=0 ;i&lt;len; i++)&#123;</div><div class="line">    //code</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&quot;users&quot;&gt;</div><div class="line">    &lt;h2&gt;8882人在学习该课程:&lt;/h2&gt;</div><div class="line">    &lt;ul&gt;</div><div class="line">        &lt;li class=&quot;user&quot;&gt;</div><div class="line">            &lt;a href=&quot;/user/1&quot;&gt;Satoshi&lt;/a&gt;</div><div class="line">        &lt;/li&gt;</div><div class="line">        &lt;li class=&quot;user&quot;&gt;</div><div class="line">            &lt;a href=&quot;/user/2&quot;&gt;春来草青&lt;/a&gt;</div><div class="line">        &lt;/li&gt;</div><div class="line">        &lt;li id=&quot;lastUser&quot; class=&quot;user last&quot;&gt;</div><div class="line">            &lt;a href=&quot;/user/3&quot;&gt;Kash&lt;/a&gt;</div><div class="line">        &lt;/li&gt;</div><div class="line">    &lt;/ul&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">&lt;script&gt;</div><div class="line">	var a = document.querySelectorAll(&quot;#users .user&quot;);</div><div class="line"></div><div class="line">	alert(&apos;一共有&apos; + a.length + &apos;个用户!&apos;);</div><div class="line"></div><div class="line">    var lastUser = document.getElementById(&apos;lastUser&apos;);</div><div class="line">     lastUser.parentNode.removeChild(lastUser);</div><div class="line">     alert(&apos;一共有&apos; + a.length + &apos;个用户!&apos;);</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<h3 id="文本内容"><a href="#文本内容" class="headerlink" title="文本内容"></a>文本内容</h3><p>element.textContent——获得节点以及其后代节点的文本内容。<br>IE9以下不支持。</p>
<p>element.innerText<br>FF不支持</p>
<p>innerHTML——节点的html内容<br>innerHTML会重新设置节点属性，可能会导致内存泄漏以及安全问题。<br>因此仅建议用于新的节点，并且该内容不是由用于用户填写的。</p>
<h3 id="getElementsByClassName兼容版"><a href="#getElementsByClassName兼容版" class="headerlink" title="getElementsByClassName兼容版"></a>getElementsByClassName兼容版</h3><p>function getElementsByClassName(elements,names){<br>    if(elements.getElementsByClassName){<br>        return elements.getElementsByClassName(names);<br>    }<br>}</p>
<h2 id="属性操作"><a href="#属性操作" class="headerlink" title="属性操作"></a>属性操作</h2><p>注意获取class属性和for属性的方式。<br><img src="http://note.youdao.com/yws/res/34098/WEBRESOURCEa1724d9e66ca1098931029794e2e0a78" alt="image"></p>
<p><img src="http://note.youdao.com/yws/res/34100/WEBRESOURCE0b7f45341c707bff0829eb960c28fd7b" alt="image"><br>通过属性访问符访问的属性，是转换过的实用对象。此外boolean对象为true，不管对象的属性为true或false.</p>
<p>通过getAttribute()获取的属性类型是字符串。<br><img src="http://note.youdao.com/yws/res/34102/WEBRESOURCE10b3070191db7a365278ace3309a9da4" alt="image"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">button.disabled = true;</div><div class="line">button.setAttribute(&apos;class&apos;, &apos;disabled&apos;);</div><div class="line">//两种方式</div></pre></td></tr></table></figure></p>
<h3 id="遍历元素的特性"><a href="#遍历元素的特性" class="headerlink" title="遍历元素的特性"></a>遍历元素的特性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function outputAttribute (element) &#123;</div><div class="line">    var pairs = new Array(),attrName,attrValue,i,len;</div><div class="line">    for(i=0, len = element.attributes.length; i &lt; len; i++) &#123;</div><div class="line">        attrName = element.attributes[i].nodeName;</div><div class="line">        attrValue = element.attributes[i].nodeValue;</div><div class="line">        if(element.attributes[i].specified)&#123;</div><div class="line">            //?޸?IE7?¸???onresizeend=null&quot; onrowenter=null&quot; aria-haspopup=&quot; ondragleave=null&quot; oncut=null&quot; onbeforepaste=null&quot;????????ʾ???⣬ֻ?????ض?????</div><div class="line">            pairs.push(attrName + &quot;=&quot; + attrValue + &quot;\&quot;&quot;);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return pairs.join(&quot; &quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="元素的子节点"><a href="#元素的子节点" class="headerlink" title="元素的子节点"></a>元素的子节点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;ul&gt;</div><div class="line">    &lt;li&gt;&lt;/li&gt;</div><div class="line">    &lt;li&gt;&lt;/li&gt;</div><div class="line">    &lt;li&gt;&lt;/li&gt;</div><div class="line">&lt;/ul&gt;</div><div class="line"></div><div class="line">for(var i=0,len = element.childNodes.length; i&lt; len;i++)&#123;</div><div class="line">    if(element.childNodes[i].nodeTye === 1)&#123;</div><div class="line">        //code</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其他浏览器会读取空白的节点，IE不会，做兼容。</p>
<h3 id="文档碎片"><a href="#文档碎片" class="headerlink" title="文档碎片"></a>文档碎片</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var fragment =  document.createDocumentFragment();</div><div class="line">var ul = document.getElementById(&quot;myList&quot;);</div><div class="line">var li = null;</div><div class="line"></div><div class="line">for(var i=0; i &lt; 3; i++) &#123;</div><div class="line">    li = document.createElement(&quot;li&quot;);</div><div class="line">    li.appendChild(document.createTextNode(&quot;Item&quot; + (i+1)));</div><div class="line">    fragment.appendChild(li);</div><div class="line">&#125;</div><div class="line"></div><div class="line">ul.appendChild(fragment);</div></pre></td></tr></table></figure>
<p>将新创建的节点保存到文档碎片中，再插入文档碎片，实际上没有提高效率。</p>
<h3 id="dataset"><a href="#dataset" class="headerlink" title="dataset"></a>dataset</h3><p><img src="http://note.youdao.com/yws/res/34106/WEBRESOURCEb0dbafa8caeb36a308b4128ffa1ee689" alt="image"><br>在HTML5中我们可以使用data-前缀设置我们需要的自定义属性，来进行一些数据的存放。DOM对象中有个dataset属性对象，可以在该对象中存一些与该DOM对象相关的数据。</p>
<h3 id="样式操作"><a href="#样式操作" class="headerlink" title="样式操作"></a>样式操作</h3><ul>
<li><p>修改单个元素的样式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">element.style.cssTetx = &quot;border-color:red;color:red&quot;;</div></pre></td></tr></table></figure>
</li>
<li><p>推荐做法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">element.className += &quot; newClass&quot;;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>样式表和html结构分离，便于维护管理</p>
<ul>
<li>对于元素较多直接修改样式表<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">element.href = &quot; newstyle.css&quot;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>style获取到的不一定为实际的样式值，推荐使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">window.getComputedStyle(element).color;</div></pre></td></tr></table></figure></p>
<h3 id="CSSDOM"><a href="#CSSDOM" class="headerlink" title="CSSDOM"></a>CSSDOM</h3><ul>
<li>获取样式表 element.sheet</li>
<li>获取样式表中的选择器 element.sheet.cssRules[1]</li>
<li>获取样式表中选择器所有样式 element.sheet.cssRules[1].selectorText</li>
<li>获取样式表中选择器的某个样式 element.sheet.cssRules[1].style.lineHeight</li>
</ul>
<p><img src="http://note.youdao.com/yws/res/34108/WEBRESOURCEebaeecb7022cb49975d5675b7ad88838" alt="image"></p>
<h3 id="兼容IE获取style"><a href="#兼容IE获取style" class="headerlink" title="兼容IE获取style"></a>兼容IE获取style</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function getStyle(ele)&#123;</div><div class="line">    if(window.getComputedStyle)&#123;</div><div class="line">        return window.getComputedStyle(ele);</div><div class="line">    &#125;else &#123;</div><div class="line">        return ele.currentStyle(ele)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="动态加载脚本"><a href="#动态加载脚本" class="headerlink" title="动态加载脚本"></a>动态加载脚本</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    function loadScript(url) &#123;</div><div class="line">        var  script = document.createElement(&quot;script&quot;);</div><div class="line">        script.type = &quot;text/javascript&quot;;</div><div class="line">        script.src = url;</div><div class="line">        document.body.appendChild(script);</div><div class="line">    &#125;</div><div class="line">&lt;/script&gt;</div><div class="line">loadScript(&quot;client.js&quot;);</div><div class="line"></div><div class="line">function loadStyles(url)&#123;</div><div class="line">    var link = document.createElement(&quot;link&quot;);</div><div class="line">    link.rel = &quot;stylesheet&quot;;</div><div class="line">    link.type = &quot;text/css&quot;;</div><div class="line">    link.href = url;</div><div class="line">    var head = document.getElementsByTagName(&quot;head&quot;)[0];</div><div class="line">    head.appendChild(link);</div><div class="line">&#125;</div><div class="line">loadStyles(&quot;style.css&quot;);</div></pre></td></tr></table></figure>
<p>动态加载代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">function loadScriptString(code)&#123;</div><div class="line">    var script = document.createElement(&quot;script&quot;);</div><div class="line">    script.type = &quot;text/javascript&quot;;</div><div class="line">    try &#123;</div><div class="line">        script.appendChild(document.createTextNode(code));</div><div class="line">    &#125; catch (ex)&#123;</div><div class="line">        script.text = &quot;code&quot;;//兼容Safari</div><div class="line">    &#125;</div><div class="line">    document.body.appendChild(script);</div><div class="line">&#125;</div><div class="line">loadScriptString(&quot;function sayHi()&#123;window.write(&apos;ss&apos;);&#125;&quot;);</div><div class="line"></div><div class="line">function loadStyleString(css)&#123;</div><div class="line">    var style = document.createElement(&quot;style&quot;);</div><div class="line">    style.type = &quot;text/css&quot;;</div><div class="line">    try&#123;</div><div class="line">        style.appendChild(document.createTextNode(css));</div><div class="line">    &#125;catch (ex)&#123;</div><div class="line">        style.stylesheet.cssText = css;</div><div class="line">    &#125;</div><div class="line">    var head = document.getElementsByTagName(&quot;head&quot;)[0];</div><div class="line">    head.appendChild(style);</div><div class="line">&#125;</div><div class="line"></div><div class="line">loadStyleString(&quot;body&#123;backgroud-color:red&#125;&quot;);</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript高级程序设计三第七章闭包及私有变量]]></title>
      <url>https://zaynex.github.io/2016/08/11/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%89%E7%AC%AC%E4%B8%83%E7%AB%A0%E9%97%AD%E5%8C%85%E5%8F%8A%E7%A7%81%E6%9C%89%E5%8F%98%E9%87%8F/</url>
      <content type="html"><![CDATA[<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>有权访问另一个函数作用域中的变量的函数。<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function createComparisonFunction (propertyName) &#123;</div><div class="line">	// body...</div><div class="line">	return function(object1, object2)&#123;</div><div class="line">		var value1 = object1[propertyName];</div><div class="line">		var value2 = object2[propertyName];</div><div class="line"></div><div class="line">		if(value1 &lt; value2) &#123;</div><div class="line">			return -1;</div><div class="line">		&#125;  else if (value2 &lt; value1)&#123;</div><div class="line">			return 1;</div><div class="line">		&#125; else &#123;</div><div class="line">			return 0;</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当函数被调用的时候，会创建一个执行环境及相应的作用域链。然后使用arguments和其他命名参数来初始化活动对象。但在作用域链中，<br>外部函数的活动对象始终处于第二位，外部函数的外部函数的活动对象处于第三位……直至作为作用域链重点的全局执行环境</p>
<p>有了匿名函数调用后，活动对象不会被销毁。作用域链仍然引用这个活动对象。因此当函数执行完后，其执行环境的作用域链会被销毁，<br>但它的活动对象仍留在内存中。</p>
<p>闭包会占用较多的内存，所以要慎重使用</p>
<h3 id="闭包与变量"><a href="#闭包与变量" class="headerlink" title="闭包与变量"></a>闭包与变量</h3><p>作用域链的这种配置机制引出了一个值得注意的副作用，即闭包只能取得包含函数中任何变量的最后一个值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function createFunctions() &#123;</div><div class="line">	var result = new Array();</div><div class="line"></div><div class="line">	for(var i=0; i &lt; 0;i++) &#123;</div><div class="line">		result[i] = function()&#123;</div><div class="line">			return i;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>变量i的值为10.返回的都是10.</p>
<p>通过匿名函数强制让闭包行为符合预期<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function createFunctions()&#123;</div><div class="line">	var result = new Array();</div><div class="line"></div><div class="line">	for(var i=0;i &lt; 10; i++) &#123;</div><div class="line">		result[i] = function(num) &#123;</div><div class="line">			return  function()&#123;</div><div class="line">				return num;</div><div class="line">			&#125;;</div><div class="line">		&#125;(i);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>将匿名函数的结果返回给数组。在调用匿名函数时，我们传入变量i.由于函数时按值传递，所以就会将变量i的当前值复制给参数num,<br>在这个匿名函数内部，又创建并返回了一个访问 num 的闭包。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function assignHandle()	&#123;</div><div class="line">	var element = document.getElementById(&quot;someElement&quot;);</div><div class="line">	element.onclick = function()&#123;</div><div class="line">		alert(element.id);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>创建了一个作为element 元素事件处理邓旭的闭包。闭包又创建另一个循环引用。<br>由于匿名函数保存了一个队 assignHandle() 的活动对象的引用。因此就会导致无法减少element的引用数<br>element 的引用数至少为1，因此它占用的内存就不会被回收。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function assignHandle()&#123;</div><div class="line">	var element = document.getElementById(&quot;someElement&quot;);</div><div class="line">	var id = element.id;</div><div class="line"></div><div class="line">	element.onlick = function()&#123;</div><div class="line">		alert(id);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	element = null;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>把 element.id 的一个副本保存在一个变量中。并且在闭包中引用该变量消除循环引用。仅仅做到这一步还无法解决内存泄漏问题</p>
<p>闭包会引用包含函数的整个活动对象，而其中包含着element。<br>因此有必要将 element  设置为 null;</p>
<h2 id="模仿块级作用域"><a href="#模仿块级作用域" class="headerlink" title="模仿块级作用域"></a>模仿块级作用域</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function  outPutNumbers(court) &#123;</div><div class="line">	for (var i=0; i&lt;court; i++)&#123;</div><div class="line">		alert(i);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	var i;</div><div class="line">	alert(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在其他语言中，由于块级作用域的存在，i变量出了for循环之后就被销毁了。但JS不会，以为他没有块级作用域。</p>
<p>JS不会告诉你是否多次声明了同一变量，它只会对后续的声明视而不见，但会执行声明中的变量初始化。 匿名函数可以模仿块级作用域解决这个问题<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(function()&#123;</div><div class="line">	//块级作用域</div><div class="line">&#125;)();</div></pre></td></tr></table></figure></p>
<p><strong>函数声明后面不能跟原括号，但是函数表达式可以</strong>，所以将函数声明转化为函数表达式，只要加() 即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function outPutNumbers(court) &#123;</div><div class="line">		(function()&#123;</div><div class="line">			for (var i=0; i &lt; court; i++) &#123;</div><div class="line">				alert(i);</div><div class="line">			&#125;</div><div class="line">		&#125;)();</div><div class="line"></div><div class="line">		alert(i); //错误</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在for循环外部插入一二私有作用域，在匿名函数中定义的任何变量，都会在执行结束后被销毁。 i只能在循环中使用。</p>
<h2 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h2><p>在函数中定义的变量都可以认为是私有变量。（包括函数参数、局部变量、以及在函数内部定义的其他函数。</p>
<h3 id="创建访问私有变量的公共方法"><a href="#创建访问私有变量的公共方法" class="headerlink" title="创建访问私有变量的公共方法"></a>创建访问私有变量的公共方法</h3><p>有权访问私有变量和私有函数的公共方法称为特权函数，因为外部函数无法访问内部函数，我们就借助闭包返回函数得以访问。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function MyObject() &#123;</div><div class="line">	var privateVariable = 10;</div><div class="line"></div><div class="line">	function privateFunction()&#123;</div><div class="line">		return false;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	this.publicMethod = function() &#123;</div><div class="line">		privateVariable++;</div><div class="line">		return privateFunction();</div><div class="line">	&#125;;</div><div class="line">&#125;</div><div class="line">var new1 = new MyObject();</div><div class="line">document.writeln(new1.publicMethod());</div></pre></td></tr></table></figure></p>
<p>在创建MyObject的实例new1后，除了使用publicMethod方法外，没有任何办法可以直接访问 privateVariable和privateFunction()。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function Person(name) &#123;</div><div class="line">	this.getName = function() &#123;</div><div class="line">		return name;</div><div class="line">	&#125;;</div><div class="line">	this.setName = function(value)&#123;</div><div class="line">		name = value;</div><div class="line">	&#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var person1 = new Person(&quot;Zaynex&quot;); </div><div class="line">alert(person1.getName()); //Zaynex</div><div class="line">person1.setName(&quot;Greg&quot;);</div><div class="line">alert(person1.getName());//Greg</div></pre></td></tr></table></figure></p>
<p>两个方法都在构造函数内部定义，它们作为闭包能够通过作用域链访问name。私有变量name在Person的不同实例中都不相同，因为每次调用构造和桉树都会重新创建这两个方法。<br>构造函数模式也有缺点：针对每个实例都会创建同一组新方法，而使用静态私有变量可以避免这个问题。</p>
<h3 id="静态私有变量"><a href="#静态私有变量" class="headerlink" title="静态私有变量"></a>静态私有变量</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">(function()&#123;</div><div class="line">	var privateVariable = 10;</div><div class="line">	function privateFunction() &#123;</div><div class="line">		return false;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	//构造函数</div><div class="line">	MyObject = function()&#123;</div><div class="line">	&#125;;</div><div class="line">	//公有/特权方法</div><div class="line">	MyObject.prototype.publicMethod = function()&#123;</div><div class="line">		privateVariable++;</div><div class="line">		return privateFunction();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;)();</div></pre></td></tr></table></figure>
<p>这个模式创建了私有作用域。定义了私有变量和私有函数，以及构造函数。公有方法是定义在原型上的（原型模式）。<br>需要注意的是，这个模式在定义构造函数时并没有使用函数声明，如果使用函数声明那么 MyObject构造函数就成了局部变量。所以没有使用var关键字去声明。</p>
<p><strong>初始化未经声明的变量，总是会创建一个全局变量</strong>。<br>但在严格模式下，给未经声明的变量赋值会导致错误。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&quot;use strict&quot;;</div><div class="line">//...这里放原先的代码</div><div class="line">//Uncaught ReferenceError: MyObject is not defined</div></pre></td></tr></table></figure></p>
<p>这个模式与构造函数定义特权方法最主要的区别就是私有变量和函数都是由实例共享的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">(function()&#123;</div><div class="line">	var name = &quot;&quot;;</div><div class="line">	Person = function(value) &#123;</div><div class="line">		name = value;</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	Person.prototype.getName = function()&#123;</div><div class="line">		return name;</div><div class="line">	&#125;</div><div class="line">	Person.prototype.setName = function(value) &#123;</div><div class="line">		name = value;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;)();</div><div class="line"></div><div class="line">var person1 = new Person(&quot;Zaynex&quot;);</div><div class="line">document.writeln(person1.getName());</div><div class="line">//Zaynex</div><div class="line">person1.setName(&quot;Simon&quot;);</div><div class="line">document.writeln(person1.getName());</div><div class="line">//Simon</div><div class="line"></div><div class="line">var person2 = new Person(&quot;Michael&quot;);</div><div class="line">document.writeln(person1.getName());</div><div class="line">document.writeln(person2.getName());</div><div class="line">//Michael </div><div class="line">//Michael</div></pre></td></tr></table></figure></p>
<p>这种方式创建私有变量会因为使用原型而增进代码的复用，但每个实例都没有自己的私有变量。</p>
<h3 id="模块模式"><a href="#模块模式" class="headerlink" title="模块模式"></a>模块模式</h3><p>模块模式是为单例模式创建私有变量和特权方法。<strong>所谓单例，指的就是只有一个实例的对象。</strong><br>通过JS是以对象字面量的方式创建单例的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var singleton = &#123;</div><div class="line">	name : value,</div><div class="line">	method: function()&#123;</div><div class="line">		//code...</div><div class="line">	&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>模块模式为单例添加自由变量和特权方法使其得到增强。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">var singleton = function()&#123;</div><div class="line">	//私有方法</div><div class="line">	var privateVariable = 10;</div><div class="line">	function privateFunction()&#123;</div><div class="line">		return false;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	//特权、公有方法</div><div class="line">	return &#123;</div><div class="line">		publicProperty: true,</div><div class="line">		publicMethod: function()&#123;</div><div class="line">			privateVariable++;</div><div class="line">			return privateFunction();</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line">&#125;();</div></pre></td></tr></table></figure></p>
<p>在模块模式章使用了一个返回对象的匿名函数。首先定义了私有变量和函数，然后将一个对象字面量作为函数的值返回，返回的对象字面量只包含可以公开的属性和方法。<br>由于这个对象是在匿名函数内部定义的，因此它的公有方法有权访问私有变量和函数。</p>
<p>从本质上讲，这个对象字面量定义的是单例的公共接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">var application = function()&#123;</div><div class="line">	//私有变量和函数</div><div class="line">	var components = new Array();</div><div class="line"></div><div class="line">	//初始化</div><div class="line">	components.push(new BaseComponent());</div><div class="line"></div><div class="line">	//公共</div><div class="line">	return &#123;</div><div class="line">		getComponentCount: function()&#123;</div><div class="line">			return components.length;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		registerComponent: function(component) &#123;</div><div class="line">			if (typeof component === &apos;object&apos;) &#123;</div><div class="line">				components.push(component);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line">&#125;();</div></pre></td></tr></table></figure>
<p><strong>如果必须创建一个对象并以某些数据对其进行初始化，同时还要公开一些能够访问这些私有变量数据的方法，那么就可以使用模块模式</strong><br>以这种模式创建的每个单例都是Object的实例。所以使用instanceof检测对象类型就没必要了。</p>
<h3 id="增强的模块模式"><a href="#增强的模块模式" class="headerlink" title="增强的模块模式"></a>增强的模块模式</h3><p>在返回对象之前加入对其增强的代码。这种增强的模块模式适合那些单例必须是某种类型的实例，同时还必须添加某些属性或方法对其加以增强的情况。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">var singleton = function()&#123;</div><div class="line">	//私有方法、变量</div><div class="line">	var privateVariable = 10;</div><div class="line">	function privateFunction()&#123;</div><div class="line">		return false;</div><div class="line">	&#125;</div><div class="line">	//创建对象</div><div class="line">	var object = new CustomType();</div><div class="line">	//特权、公有方法</div><div class="line">	object.publicProperty = true;</div><div class="line">	object.publicMethod = function()&#123;</div><div class="line">		privateVariable++;</div><div class="line">		return privateFunction();</div><div class="line">	&#125;</div><div class="line">	return object;</div><div class="line">&#125;();</div></pre></td></tr></table></figure></p>
<p>如果前面的模块模式的例子中的application对象必须是BaseComponent的实例，那么就可以使用以下代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">var application = function()&#123;</div><div class="line">	//私有变量和函数</div><div class="line">	var components = new Array();</div><div class="line"></div><div class="line">	//初始化</div><div class="line">	components.push(new BaseComponent());</div><div class="line"></div><div class="line">	//创建application的一个副本</div><div class="line">	var app = new BaseComponent();</div><div class="line">	</div><div class="line"></div><div class="line">	//公共方法</div><div class="line">	app.getComponentCount = function()&#123;</div><div class="line">		return components.length;</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	app.registerComponent = function(component) &#123;</div><div class="line">		if (typeof component === &apos;object&apos;) &#123;</div><div class="line">			components.push(component);</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line">	return app;</div><div class="line">&#125;();</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript高级程序设计三第七章函数表达式]]></title>
      <url>https://zaynex.github.io/2016/08/11/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%89%E7%AC%AC%E4%B8%83%E7%AB%A0%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>函数声明提升<br>在执行代码之前会读取函数声明。<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">// 函数声明</div><div class="line">function foo() &#123;&#125;</div><div class="line"></div><div class="line">// 函数表达式</div><div class="line">(function bar() &#123;&#125;)</div><div class="line"></div><div class="line">// 函数表达式</div><div class="line">x = function hello() &#123;&#125;</div><div class="line"></div><div class="line">if (x) &#123;</div><div class="line">   // 函数表达式</div><div class="line">   function world() &#123;&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 函数声明</div><div class="line">function a() &#123;</div><div class="line">   // 函数声明</div><div class="line">   function b() &#123;&#125;</div><div class="line">   if (0) &#123;</div><div class="line">      //函数表达式</div><div class="line">      function c() &#123;&#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">sayHi();</div><div class="line">function sayHi () &#123;</div><div class="line">	alert(&quot;hi&quot;);</div><div class="line">&#125;;</div><div class="line">//hi</div><div class="line">var functionName = function  (arg0, arg1, arg2) &#123;</div><div class="line">	//函数体</div><div class="line">&#125;</div><div class="line"></div><div class="line">//匿名函数</div><div class="line"></div><div class="line">sayHi();</div><div class="line"></div><div class="line">var sayHi = function  () &#123;</div><div class="line">	alert(&quot;hi&quot;);</div><div class="line">&#125;;</div><div class="line">//错误</div></pre></td></tr></table></figure>
<p>函数表达式和其他表达式一样，使用前必须先赋值。</p>
<p>递归函数<br>函数通过名字的调用自身<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">function factorial (num) &#123;</div><div class="line">	if (num &lt;= 1) &#123;</div><div class="line">		return 1;</div><div class="line">	&#125; else &#123;</div><div class="line">		return num * factorial(num-1);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var anotherFactorial = factorial;</div><div class="line">factorial = null;</div><div class="line">alert(anotherFactorial(4));  // Error</div><div class="line"></div><div class="line"></div><div class="line">function factorial (num) &#123;</div><div class="line">	if(num &lt;= 1)&#123;</div><div class="line">		return 1;</div><div class="line">	&#125; else&#123;</div><div class="line">		return num * arguments.callee(num-1);  //代替函数名</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>如果你想在函数体内部引用当前函数，则需要创建一个命名函数表达式。然后函数名称将会（且只会）作为函数体（作用域内）的本地变量。这样也可以避免使用非标准的 arguments.callee 属性。<br>在严格模式下，不能访问 arguments.callee()，不过可以用函数命名表达式达到相同的效果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var factorial = (function f(num) &#123;</div><div class="line">	if(num &lt;= 1)&#123;</div><div class="line">		return 1;</div><div class="line">	&#125; else&#123;</div><div class="line">		return num * f(num-1);  //代替函数名</div><div class="line">	&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>上述代码中f()就是命名函数表达式。<br>要记住：这个名字只在新定义的函数作用域内有效，因为规范规定了标示符不能在外围的作用域内有效。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var f = function foo()&#123;</div><div class="line">    return typeof foo; // foo是在内部作用域内有效</div><div class="line">  &#125;;</div><div class="line">  // foo在外部用于是不可见的</div><div class="line">  typeof foo; // &quot;undefined&quot;</div><div class="line">  f(); // &quot;function&quot;</div></pre></td></tr></table></figure>
<p>命名函数表达式对调试来说非常方便。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function foo()&#123;</div><div class="line">   return bar();</div><div class="line"> &#125;</div><div class="line"> function bar()&#123;</div><div class="line">   return baz();</div><div class="line"> &#125;</div><div class="line"> function baz()&#123;</div><div class="line">   debugger;</div><div class="line"> &#125;</div><div class="line"> foo();</div></pre></td></tr></table></figure></p>
<p><img src="http://note.youdao.com/yws/res/33607/WEBRESOURCEae9e978c13b3626a211851993df2ad21" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">function foo()&#123;</div><div class="line">	return bar();</div><div class="line">&#125;</div><div class="line"></div><div class="line">var bar = (function()&#123;</div><div class="line">	if(window.addEventListener) &#123;</div><div class="line">		return function()&#123;</div><div class="line">			return baz();</div><div class="line">		&#125;;</div><div class="line">	&#125;else if (window.attachEvent) &#123;</div><div class="line">		return function()&#123;</div><div class="line">			return baz();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line">function baz()&#123;</div><div class="line">debugger;</div><div class="line">&#125;</div><div class="line">foo();</div></pre></td></tr></table></figure>
<p><img src="http://note.youdao.com/yws/res/33609/WEBRESOURCEf48f566eb5b88714a9623a646155a857" alt="image"><br>在上述调用栈中我们发现bar函数没有显示出来。这是google浏览器下的。<br>但在Firefox中已经修复这个问题<br><img src="http://note.youdao.com/yws/res/33611/WEBRESOURCE92309646cad82fba6aa3dac609e4aa3f" alt="image"><br>我们可以使用命名函数表达式方便调试。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">function foo()&#123;</div><div class="line">	return bar();</div><div class="line">&#125;</div><div class="line">var bar = (function()&#123;</div><div class="line">	if(window.addEventListener) &#123;</div><div class="line">		return function bar()&#123;</div><div class="line">			return baz();</div><div class="line">		&#125;;</div><div class="line">	&#125;else if(window.attachEvent) &#123;</div><div class="line">		return function bar() &#123;</div><div class="line">			return baz();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;)();</div><div class="line"></div><div class="line">function baz()&#123;</div><div class="line">	debugger;</div><div class="line">&#125;</div><div class="line">foo();</div></pre></td></tr></table></figure></p>
<p><img src="http://note.youdao.com/yws/res/33613/WEBRESOURCE3989a79389e09c940f7b22160b6af1e3" alt="image"><br>好吧，命名函数表达式就这点P作用。</p>
<p>JScript中的BUG。<br><strong>函数表达式的标示符泄露到外部作用域</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var f = function g()&#123;&#125;;</div><div class="line">		console.log(typeof g);</div></pre></td></tr></table></figure></p>
<p>chorme<br><img src="http://note.youdao.com/yws/res/33615/WEBRESOURCEc958ec6edb823174c2d6aecba5ab7677" alt="image"></p>
<p>IE<br><img src="http://note.youdao.com/yws/res/33617/WEBRESOURCEd700aa46874d60756a1f7d75fa0ade55" alt="image"></p>
<p>上面我们说过，命名函数表达式的标示符在外部作用域是无效的，但JScript明显是违反了这一规范，上面例子中的标示符g被解析成函数对象，这就乱了套了，很多难以发现的bug都是因为这个原因导致的。</p>
<p><strong>注：IE9修复了该问题</strong></p>
<p>命名函数表达式同时当作函数声明和函数表达式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">console.log(typeof g);</div><div class="line">	var f = function g()&#123;&#125;;</div></pre></td></tr></table></figure>
<p>特性环境下，函数声明会优先于任何表达式被解析，上面的例子展示的是JScript实际上是把命名函数表达式当成函数声明了，因为它在实际声明之前就解析了g。</p>
<p>命名函数表达式会创建两个截然不同的函数对象！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var f = function g()&#123;&#125;;</div><div class="line">    f === g; // false</div><div class="line"></div><div class="line">    f.expando = &apos;foo&apos;;</div><div class="line">    g.expando; // undefined</div><div class="line">		</div><div class="line">		//IE9已经修复了该问题</div></pre></td></tr></table></figure></p>
<p>因为修改任何一个对象，另外一个没有什么改变，这太恶了。通过这个例子可以发现，创建2个不同的对象，也就是说如果你想修改f的属性中保存某个信息，然后想当然地通过引用相同对象的g的同名属性来使用，那问题就大了，因为根本就不可能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var f = function g() &#123;</div><div class="line">  return 1;</div><div class="line">&#125;;</div><div class="line">if (false) &#123;</div><div class="line">  f = function g()&#123;</div><div class="line">    return 2;</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line">g(); // 2</div></pre></td></tr></table></figure>
<p>这个bug查找就难多了，但导致bug的原因却非常简单。首先，g被当作函数声明解析，由于JScript中的函数声明不受条件代码块约束，所以在这个很恶的if分支中，g被当作另一个函数function g(){ return 2 }，也就是又被声明了一次。然后，所有“常规的”表达式被求值，而此时f被赋予了另一个新创建的对象的引用。由于在对表达式求值的时候，永远不会进入“这个可恶if分支，因此f就会继续引用第一个函数function g(){ return 1 }。分析到这里，问题就很清楚了：假如你不够细心，在f中调用了g，那么将会调用一个毫不相干的g函数对象。        </p>
<p>你可能会问，将不同的对象和arguments.callee相比较时，有什么样的区别呢？我们来看看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var f = function g()&#123;</div><div class="line">    return [</div><div class="line">      arguments.callee == f,</div><div class="line">      arguments.callee == g</div><div class="line">    ];</div><div class="line">  &#125;;</div><div class="line">  f(); // [true, false]</div><div class="line">  g(); // [false, true]</div></pre></td></tr></table></figure></p>
<p>可以看到，arguments.callee的引用一直是被调用的函数，实际上这也是好事，稍后会解释。</p>
<p>还有一个有趣的例子，那就是在不包含声明的赋值语句中使用命名函数表达式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(function()&#123;</div><div class="line">  f = function f()&#123;&#125;;</div><div class="line">&#125;)();</div></pre></td></tr></table></figure></p>
<p>按照代码的分析，我们原本是想创建一个全局属性f（注意不要和一般的匿名函数混淆了，里面用的是带名字的生命），JScript在这里捣乱了一把，首先他把表达式当成函数声明解析了，所以左边的f被声明为局部变量了（和一般的匿名函数里的声明一样），然后在函数执行的时候，f已经是定义过的了，右边的function f(){}则直接就赋值给局部变量f了，所以f根本就不是全局属性。</p>
<p>了解了JScript这么变态以后，我们就要及时预防这些问题了，首先防范标识符泄漏带外部作用域，其次，应该永远不引用被用作函数名称的标识符；还记得前面例子中那个讨人厌的标识符g吗？——如果我们能够当g不存在，可以避免多少不必要的麻烦哪。因此，关键就在于始终要通过f或者arguments.callee来引用函数。如果你使用了命名函数表达式，那么应该只在调试的时候利用那个名字。最后，还要记住一点，一定要把命名函数表达式声明期间错误创建的函数清理干净。</p>
<p>JScript内存管理</p>
<p>知道了这些不符合规范的代码解析bug以后，我们如果用它的话，就会发现内存方面其实是有问题的，来看一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var f = (function()&#123;</div><div class="line">    if (true) &#123;</div><div class="line">      return function g()&#123;&#125;;</div><div class="line">    &#125;</div><div class="line">    return function g()&#123;&#125;;</div><div class="line">  &#125;)();</div></pre></td></tr></table></figure></p>
<p>我们知道，这个匿名函数调用返回的函数（带有标识符g的函数），然后赋值给了外部的f。我们也知道，命名函数表达式会导致产生多余的函数对象，而该对象与返回的函数对象不是一回事。所以这个多余的g函数就死在了返回函数的闭包中了，因此内存问题就出现了。这是因为if语句内部的函数与g是在同一个作用域中被声明的。这种情况下 ，除非我们显式断开对g函数的引用，否则它一直占着内存不放。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var f = (function()&#123;</div><div class="line">    var f, g;</div><div class="line">    if (true) &#123;</div><div class="line">      f = function g()&#123;&#125;;</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">      f = function g()&#123;&#125;;</div><div class="line">    &#125;</div><div class="line">    // 设置g为null以后它就不会再占内存了</div><div class="line">    g = null;</div><div class="line">    return f;</div><div class="line">  &#125;)();</div></pre></td></tr></table></figure>
<p>通过设置g为null，垃圾回收器就把g引用的那个隐式函数给回收掉了，为了验证我们的代码，我们来做一些测试，以确保我们的内存被回收了。</p>
<p>中文出处：<a href="http://www.cnblogs.com/TomXu/archive/2011/12/29/2290308.html" target="_blank" rel="external">http://www.cnblogs.com/TomXu/archive/2011/12/29/2290308.html</a><br>英文地址：<a href="https://kangax.github.io/nfe/#function-statements" target="_blank" rel="external">https://kangax.github.io/nfe/#function-statements</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript语言精粹之函数]]></title>
      <url>https://zaynex.github.io/2016/08/10/JavaScript%E8%AF%AD%E8%A8%80%E7%B2%BE%E7%B2%B9%E4%B9%8B%E5%87%BD%E6%95%B0/</url>
      <content type="html"><![CDATA[<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>所有的过失在未犯之前，都已定下应处的惩罚。<br><a id="more"></a></p>
<h3 id="对象字面量"><a href="#对象字面量" class="headerlink" title="对象字面量"></a>对象字面量</h3><p>对象字面量产生的对象连接到Object.prototype。函数对象连接到Function.prototype(该原型对象本身连接到 Object.prototype)。</p>
<p>每个 函数对象 创建时带有prototype属性，它的值是一个拥有constructor属性且值就是该函数的对象。这和隐藏连接到Function.prototype完全不同。</p>
<p>一个内部函数自然可以访问自己的参数和变量，同事也能方便访问它被嵌套在其中的那个函数的参数和变量。通过函数字面量创建的函数包含一个连到外部上下文的连接。这就是闭包。</p>
<h3 id="函数调用-this指向"><a href="#函数调用-this指向" class="headerlink" title="函数调用(this指向)"></a>函数调用(this指向)</h3><p>方法调用模式、函数调用模式、构造器调用模式和apply调用模式</p>
<h4 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h4><p>当一个函数被保存为对象的一个属性我们称为方法。并且这个方法被调用时，this被绑定到该对象。即方法调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var myObject = &#123;</div><div class="line">	value: 0,</div><div class="line">	increment: function(inc) &#123;</div><div class="line">		this.value += typeof inc ===  &apos;number&apos; ?  inc:1;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">myObject.increment(); </div><div class="line">document.writeln(myObject.value); // 1</div><div class="line">myObject.increment(4);</div><div class="line">document.writeln(myObject.value); //5</div></pre></td></tr></table></figure></p>
<p>this到对象的绑定发生在调用的时候。这个(very late binding)似的函数可以对this高度复用。通过this可取得它们所属对象的上下文的方法称为公共方法。</p>
<h4 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h4><p>当一个函数并且一个对象的属性时，那就当作一个函数来调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function add(a,b)&#123;</div><div class="line">	return a+b;</div><div class="line">&#125;</div><div class="line">var sum = add(3,4);</div><div class="line">console.log(sum);//7</div></pre></td></tr></table></figure></p>
<p>函数以此模式调用时，this被绑定了全局对象。这是语言设计上的一次错误。倘若语言设计正确，当内部函数被调用时，this应该仍然绑定到外部函数的this变量。这个设计的错误后果就是不能利用内部函数来帮助它工作。因为内部的this被绑定了错误的值，所以不能共享该方法对对象的访问权。</p>
<p>不过我们在该方法定义一个变量并赋予值为this，那么内部函数就可以通过那个变量访问到this。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var obj = &#123;</div><div class="line">	x: 10,</div><div class="line">	fn: function()&#123;</div><div class="line">		//console.log(&quot;我是fn的this: &quot; + this);</div><div class="line">		//console.log(&quot;我是fn的this.x: &quot; + this.x);</div><div class="line">		var that = this;</div><div class="line">		function f()&#123;</div><div class="line">			console.log(&quot;我保存了fn函数里面的this: &quot; + that);</div><div class="line">			console.log(&quot;我保存了fn函数里面的this.x: &quot;+that.x);</div><div class="line">		&#125;</div><div class="line">		f();</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line">obj.fn();</div></pre></td></tr></table></figure></p>
<h4 id="构造器调用模式"><a href="#构造器调用模式" class="headerlink" title="构造器调用模式"></a>构造器调用模式</h4><p>如果在一个函数前面带上new调用，则将创建爱你一个隐藏连接到该函数的 property 成员的新对象，同时this将会被绑定到那个新对象上。</p>
<p>new前缀也会改变return语句的行为。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var Quo = function(string) &#123;</div><div class="line">	this.status = string;</div><div class="line">&#125;;</div><div class="line">//给Quo的所有实例提供一个名为 get_status的公共方法。</div><div class="line">Quo.prototype.get_status = function() &#123;</div><div class="line">	return this.status;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var myQuo = new Quo(&quot;confused&quot;);</div><div class="line">document.writeln(myQuo.get_status()); //confused</div></pre></td></tr></table></figure></p>
<p>this指向了myQuo</p>
<h4 id="Apply调用模式"><a href="#Apply调用模式" class="headerlink" title="Apply调用模式"></a>Apply调用模式</h4><p>apply()接受两个参数。第一个是将被绑定给this的值。第二个参数时一个数组。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var obj = &#123;</div><div class="line">	x : 10,</div><div class="line">&#125;;</div><div class="line">var x = 100;</div><div class="line">var fn = function()&#123;</div><div class="line">	var x = 12;</div><div class="line">	console.log(this);</div><div class="line">	console.log(this.x);</div><div class="line">&#125;;</div><div class="line">fn(); //window 100</div><div class="line">fn.call(obj); // object 10</div></pre></td></tr></table></figure></p>
<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var sum  = function()&#123;</div><div class="line">	var i, sum = 0;</div><div class="line">	for (i = 0; i &lt; arguments.length; i++) &#123;</div><div class="line">		sum += arguments[i];</div><div class="line">	&#125;</div><div class="line">	return sum;</div><div class="line">&#125;;</div><div class="line">document.writeln(sum(3,4,5,7754,2));</div></pre></td></tr></table></figure>
<h4 id="返回"><a href="#返回" class="headerlink" title="返回"></a>返回</h4><p>如果没有指定返回值，则返回 undefined。</p>
<p>如果函数以new + 函数名 的方式来调用，且返回值不是一个对象，则返回 this(该新对象)。</p>
<h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var add = function(a, b) &#123;</div><div class="line">	if (typeof a !== &apos;number&apos; || typeof b !== &apos;number&apos; ) &#123;</div><div class="line">		throw &#123;</div><div class="line">			name: &apos;TypeError&apos;,</div><div class="line">			message: &apos;add needs numbers&apos;</div><div class="line">		&#125;;</div><div class="line">	&#125;</div><div class="line">	return a + b;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>throw语句中断函数的执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var try_it = function() &#123;</div><div class="line">	try &#123;</div><div class="line">		add(&quot;seven&quot;);</div><div class="line">	&#125; catch(e) &#123;</div><div class="line">		document.writeln(e.name + &quot;:&quot; + e.message);</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line">try_it();</div></pre></td></tr></table></figure></p>
<p>如果在try语句中抛出异常，控制权就会在catch从句中。</p>
<h3 id="给类型增加方法"><a href="#给类型增加方法" class="headerlink" title="给类型增加方法"></a>给类型增加方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Function.prototype.method = function(name, func) &#123;</div><div class="line">	this.prototype[name] = func;</div><div class="line">	return this;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>通过给 Function.propertype增加一个method方法，我们就不必键入propertype这个属性名。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Function.prototype.method = function(name, func) &#123;</div><div class="line">	this.prototype[name] = func;</div><div class="line">	return this;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Number.method(&apos;integer&apos;, function()&#123;</div><div class="line">	return Math[this &lt; 0 ? &apos;ceiling&apos; : &apos;floor&apos;](this);</div><div class="line">&#125;);</div><div class="line">document.writeln((-3.3).integer());</div></pre></td></tr></table></figure></p>
<p>JS缺少一个移除字符串末端空白的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">String.method(&apos;trim&apos;, function()&#123;</div><div class="line">	return this.replace(/^\s+|\s+$/g,&quot;&quot;);</div><div class="line">&#125;);</div><div class="line">document.writeln(&apos;&quot;&apos; + &quot; nwat &quot;.trim() + &apos;&quot;&apos;);</div></pre></td></tr></table></figure></p>
<p>我们借助正则吧表达式来实现完善的trim()。</p>
<p>通过给基本类型增加方法，可以提高语言的表现力。因为JS原型继承的动态本质，新的方法立刻被赋予到所有的值（对象实例）上，哪怕值（对象实例）时在方法被创建之前就创建好了。</p>
<p>基本类型的原型时公共的结构，所以在类库混用时需要小心。保险的做法是在确定没有该方法时才添加它。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Function.prototype.method = function(name, func) &#123;</div><div class="line">	if(!this.prototype[name]) &#123;</div><div class="line">		this.prototype[name] = func</div><div class="line">	&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>//遍历节点，并给每个节点调用相应的函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">var walk_the_DOM = function walk(node, func) &#123;</div><div class="line">	func(node);</div><div class="line">	node = node.firstChild;</div><div class="line">	while(node) &#123;</div><div class="line">		walk(node, func);</div><div class="line">		node = node.nextSibling;</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">//取得一个属性名称字符串和可选的匹配值value,将陪陪的节点保存到数组中</div><div class="line">var getElementsByAttribute = function (attr, value) &#123;</div><div class="line">	var results = [];</div><div class="line"></div><div class="line">	walk_the_DOM(decument.body, function (node) &#123;</div><div class="line">		var actual = node.nodeType === 1 &amp;&amp; node.getAttribute(att);</div><div class="line">		if(typeof actual === &quot;string&quot; &amp;&amp; (actual === value || typeof value !== &apos;string&apos;))&#123;</div><div class="line">			results.push(node);</div><div class="line">		&#125;</div><div class="line">	&#125;);</div><div class="line">	return results;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">var foo = function() &#123;</div><div class="line">	var a = 3, b = 5;</div><div class="line"></div><div class="line">	var bar = function ()&#123;</div><div class="line">		var b = 7, c = 11;</div><div class="line"></div><div class="line">		// 此时 a 为3,b为7,c为11</div><div class="line">		</div><div class="line">		a += b + c;</div><div class="line">		//此时 a为21,b为7,c为11;</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	// 此时 a为3,b为5,c未定义</div><div class="line">	</div><div class="line">	bar();</div><div class="line">	//此时 a为21,b为5</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>JS不支持块级作用域。<br>但JS有函数作用域，定义在函数中的参数和变量在函数外部是不可见的，但在函数内部可以访问外部的变量和参数。<br>也就是说，房间里的人可以看到外面的世界的人，但是外面的世界的人却看不到房间里面的人。<br>而且一个函数中的任何位置定义的变量在该函数中的任何地方都可见。那就是自己看自己咯</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var myObject = function()&#123;</div><div class="line">	var value = 0;</div><div class="line">	return &#123;</div><div class="line">		increment: function(inc) &#123;</div><div class="line">			value += typeof inc === &apos;number&apos; ? inc : 1;</div><div class="line">		&#125;,</div><div class="line">		getValue: function() &#123;</div><div class="line">			return value;</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line">&#125;();</div></pre></td></tr></table></figure>
<p>我们通过调用一个函数的形式初始化myObject，该函数返回一个对象字面量。此函数定义了一个value变量。该变量对inrement和getValue方法总是可用的，但函数的作用域使得它对其他的程序来说是不可见的。</p>
<p>注意：这里是把函数调用后返回的结果赋值给myObject。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var quo = function (status) &#123;</div><div class="line">	return &#123;</div><div class="line">		get_status: function()&#123;</div><div class="line">			return status;</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var  myQuo = quo(&quot;amazed&quot;);</div><div class="line">document.writeln(myQuo.get_status());</div></pre></td></tr></table></figure>
<p>这个quo函数被设计成无需用 new 使用，所以名字有没有首字母大写。<br>我们在调用quo的时候，它返回包含get_status方法的一个新对象，该对象的一个引用保存在myQuo中。即使quo已经发挥了，但是get_status方法仍然享有访问quo对象的status属性的特权，这是因为get_status方法访问的是该参数本身，而不是参数的一个拷贝或者是其他值。所以该函数能够访问到它被创建时所处的上下文环境。这就被称为闭包。</p>
<p>你不能杀死我，因为我心里还藏着一个你牵挂的人。</p>
<p>让屏幕从黄色变白<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var fade = function (node) &#123;</div><div class="line">	var level = 1;</div><div class="line">	var step = function() &#123;</div><div class="line">		var hex = level.toString(16);</div><div class="line">		node.style.backgroundColor = &quot;#FFFF&quot; + hex + hex;</div><div class="line">		if(level &lt; 15) &#123;</div><div class="line">			level += 1;</div><div class="line">			setTimeout(step, 100);</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line">	setTimeout(step, 3000);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">fade(document.body);</div></pre></td></tr></table></figure></p>
<h4 id="糟糕的例子"><a href="#糟糕的例子" class="headerlink" title="糟糕的例子"></a>糟糕的例子</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">//构造一个函数，用错误的方式给一个数组中的节点设置事件处理程序。</div><div class="line">//点击一个节点时，按照设想应该弹出该节点的序号</div><div class="line">//但它总是会显示节点的数目。</div><div class="line">var add_the_handlers = function(nodes) &#123;</div><div class="line">	var i;</div><div class="line">	for(i = 0; i &lt; nodes.length; i++) &#123;</div><div class="line">		nodes[i].onclick = function(e) &#123;</div><div class="line">			alert(i);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>无法达到预期的原因是事件处理函数绑定了变量i，而不是函数在构造时的变量i的值。</p>
<h4 id="正确的例子"><a href="#正确的例子" class="headerlink" title="正确的例子"></a>正确的例子</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var add_the_handlers = function(nodes) &#123;</div><div class="line">	var i;</div><div class="line">	for (i = 0; i &lt; nodes.length; i++) &#123;</div><div class="line">		nodes[i].onclick = function(i) &#123;</div><div class="line">			return function(e) &#123;</div><div class="line">				alert(e);</div><div class="line">			&#125;;</div><div class="line">		&#125;(i);</div><div class="line">	&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>定义了一个函数并立即传递i进去执行，而不是把一个函数赋值给onclick。而该函数会翻出一个事件处理器函数。这个事件处理器函数绑定的是传递进入的i的值。而不是定义在 add_the_handlers函数里的i的值。</p>
<h3 id="回调"><a href="#回调" class="headerlink" title="回调"></a>回调</h3><p>函数可以让不连续事件的处理变得更容易。<br>假设一个序列，由用户交互开始，向服务器发送请求，最终显示服务器的响应。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">request = prepare_the_request();</div><div class="line">response = send_request_asynchronously(request);</div><div class="line">display(response);</div></pre></td></tr></table></figure></p>
<p>这种方式的问题在于网络的同步请求将会导致客户端进入假死状态。</p>
<p>更好的方式是发起异步请求，提供一个当服务器的响应达到时被调用的回调函数，异步的函数立即执行，这样客户端就不会被阻塞。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">request = prepare_the_request();</div><div class="line">send_request_asynchronously(request, function(response)&#123;</div><div class="line">	display(response);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>我们传递了一个函数作为参数 给 send-request-asynchronously 安徽省农户，它将在收到响应时被调用。</p>
<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>通过函数和闭包来构造模块。模块式一个提供接口却隐藏状态与实现的函数或对象。通过使用函数去产生模块，几乎可以完全摒弃全局变量的使用。</p>
<p>HTML字符实体替换成对应的字符。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">Function.prototype.method = function(name, func) &#123;</div><div class="line">	this.prototype[name] = func;</div><div class="line">	return this;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">String.method(&apos;deentityify&apos;, function()&#123;</div><div class="line">	var entity = &#123;</div><div class="line">		quot : &apos;&quot;&apos;,</div><div class="line">		lt: &apos;&lt;&apos;,</div><div class="line">		gt: &apos;&gt;&apos;</div><div class="line">	&#125;;</div><div class="line">	return function()&#123;</div><div class="line"></div><div class="line">	//这里是deentityify方法，它调用字符串的replace方法</div><div class="line">		return this.replace(/&amp;[^&amp;;]+;/g, </div><div class="line">			function (a, b) &#123;</div><div class="line">				var r = entity[b];</div><div class="line">				return typeof r === &apos;string&apos; ? r : a;</div><div class="line">			&#125;</div><div class="line">		);</div><div class="line">	&#125;;</div><div class="line">&#125;());</div><div class="line">//最后一行用()运算法立刻调用我们构造出来的函数，这个调用所创建并返回的函数才是deentityify方法。</div><div class="line">document.writeln(&apos;&amp;lt;&amp;quot;&amp;gt;&apos;.deentityify());</div><div class="line">//&lt;&quot;&gt;</div></pre></td></tr></table></figure></p>
<p>模块模式利用了函数作用域和闭包来创建绑定对象与私有成员的关联。<br>模块模式的一般形式是： 一个定义了私有变量和函数的函数，利用闭包创建可以访问私有变量和函数的特权函数；最后返回这个特权函数，或者把他们保存到一个可以访问到的地方。</p>
<p>模块模式也可以产生安全的对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">var serical_maker = function () &#123;</div><div class="line">//返回一个用来产生唯一字符串的对象</div><div class="line"></div><div class="line">	var prefix = &apos;&apos;;</div><div class="line">	var seq = 0;</div><div class="line">	return &#123;</div><div class="line">		set_prefix: function (p) &#123;</div><div class="line">			prefix = String(p);</div><div class="line">		&#125;,</div><div class="line">		set_seq: function (s) &#123;</div><div class="line">			seq = s;</div><div class="line">		&#125;,</div><div class="line">		gensym: function() &#123;</div><div class="line">			var result = prefix + seq;</div><div class="line">			seq += 1;</div><div class="line">			return result;</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var seqer = serical_maker();</div><div class="line">seqer.set_prefix(&quot;Q&quot;);</div><div class="line">seqer.set_seq(1000);</div><div class="line">var unique = seqer.gensym();</div><div class="line">console.log(unique);</div></pre></td></tr></table></figure></p>
<p>seqer 包含的方法没有用到this或that。因此没办法损害seqer。除非调用对应的方法， 否则没法改变prefix或seq的值。seqer对象是可变的，所以它的方法可能会被替换掉，但替换之后的方法依然不能访问私有成员。seqer就是一组函数的集合，而且那些函数被授予特权，拥有使用或修改私有状态的能力。</p>
<h3 id="套用"><a href="#套用" class="headerlink" title="套用"></a>套用</h3><p>函数也是值，套用允许我们将函数与传递给它的参数相结合产生新的函数。（函数柯里化）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Function.method(&apos;curry&apos;, function()&#123;</div><div class="line">	var args = arguments, that = this;</div><div class="line">	return function () &#123;</div><div class="line">		return this.apply(null, args.concat(arguments));</div><div class="line">	&#125;;</div><div class="line">&#125;);</div><div class="line">var add1 = add.curry(1);</div></pre></td></tr></table></figure></p>
<p>但是arguments并非一个真正的数组，所以没有concat方法，我们必须在两个arguments数组上都应用数组的slice方法才能产生拥有concat方法的常规数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Function.method(&apos;curry&apos;, function()&#123;</div><div class="line">	var slice = Array.prototype.slice,</div><div class="line">		args = slice.apply(argumnets),</div><div class="line">		that = this;</div><div class="line">	return function()&#123;</div><div class="line">		return that.apply(null, args.concat(slice.apply(arguments)))</div><div class="line">	&#125;;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">### 记忆</div><div class="line"></div><div class="line">函数可以用对象去记住先前操作的结果。</div></pre></td></tr></table></figure>
<p>var  fibonacci = function(n) {<br>    return n &lt; 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);<br>};</p>
<p>for(var i = 0; i &lt;= 10; i+=1) {<br>    console.log(fibonacci(i));<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">这样是可以工作的，但fibonacci函数被调用了453次。我们调用了11次，而它自身调用了442次去计算可能已经被计算过的值。</div><div class="line"></div><div class="line">可以让函数具备记忆功能，减少运算量。</div></pre></td></tr></table></figure></p>
<p>var fibonacci = function(){<br>    var memo = [0,1];<br>    var fib = function(n) {<br>        var result = memo[n];<br>        if(typeof result !== ‘number’){<br>            result = fib(n-1) + fib(n-2);<br>            memo[n] = result;<br>        }<br>        return result;<br>    };<br>    return fib;<br>}();<br>//这种方式呗调用了29次，我们调用它11次。它自身调用18次去取得之前存储的结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div><div class="line">我们还可以编写一个函数来帮助我们构造带记忆功能的函数。memoizer函数取得一个初始的memo数组好fundamental函数。它返回并管理一个memo函数和在需要时调用fundamental函数的shell函数。</div></pre></td></tr></table></figure></p>
<p>var memoizer = function (memo, fundamental) {<br>    var shell = function (n) {<br>        var result = memo[n];<br>        if (typeof result !== ‘number’) {<br>            result = fundamental(shell, n);<br>            memo[n] = result;<br>        }<br>        return result;<br>    };<br>    return shell;<br>};</p>
<p>var factorial = memoizer([0, 1], function(shell, n) {<br>    return n * shell(n - 1);<br>});</p>
<p>console.log(factorial(5));<br>```</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[闭包]]></title>
      <url>https://zaynex.github.io/2016/08/09/%E9%97%AD%E5%8C%85/</url>
      <content type="html"><![CDATA[<p>前面提到的上下文环境和作用域的知识，除了了解这些知识之外，还是理解闭包的基础。</p>
<p>至于“闭包”这个词的概念的文字描述，确实不好解释，我看过很多遍，但是现在还是记不住。<br><a id="more"></a><br><strong>但是你只需要知道应用的两种情况即可————函数作为返回值，函数作为参数传递。</strong></p>
<h3 id="函数作为返回值"><a href="#函数作为返回值" class="headerlink" title="函数作为返回值"></a>函数作为返回值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function fn()&#123;</div><div class="line">	var max = 10;</div><div class="line"></div><div class="line">	return function bar(x) &#123;</div><div class="line">		if (x &gt; max) &#123;</div><div class="line">			console.log(x);//15</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var f1 = fn();</div><div class="line">f1(15);</div></pre></td></tr></table></figure>
<p>如上代码，bar函数作为返回值，赋值给f1变量。执行f1(15)时，用到了fn作用域下的max变量的值。至于如何跨作用域取值，可以参考上一节。</p>
<h3 id="函数作为参数被传递"><a href="#函数作为参数被传递" class="headerlink" title="函数作为参数被传递"></a>函数作为参数被传递</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var max = 10,</div><div class="line">	fn = function(x) &#123;</div><div class="line">		if (x &gt; max) &#123;</div><div class="line">			console.log(x);</div><div class="line">		&#125;</div><div class="line">	&#125;;</div><div class="line"></div><div class="line">(function f()&#123;</div><div class="line">	var max = 100;</div><div class="line">	f(15);</div><div class="line">&#125;)(fn);</div></pre></td></tr></table></figure>
<p>如上代码中，fn函数作为一个参数被传递进入另一个函数，赋值给f参数。执行f(15)时，max变量的取值是10，而不是100。</p>
<p>上一节讲到自由变量跨作用域取值时，曾经强调过：<strong>要去创建这个函数的作用域取值，而不是“父作用域”。</strong>理解了这一点，以上两端代码中，自由变量如何取值应该比较简单。（不明白的朋友一定要去上一节看看，这个很重要！）</p>
<p>另外，讲到闭包，除了结合着作用域之外，还需要结合着执行上下文栈来说一下。</p>
<p>在前面讲执行上下文栈时，我们提到当一个函数被调用完成之后，其执行上下文环境将被销毁，其中的变量也会被同时销毁。</p>
<p>但是在当时那篇文章中留了一个问号——有些情况下，函数调用完成之后，其执行上下文环境不会接着被销毁。这就是需要理解闭包的核心内容。</p>
<p>咱们可以拿本文的第一段代码（稍作修改）来分析一下。<br><img src="http://images.cnitblog.com/blog/138012/201409/260749156077205.png" alt="image"></p>
<p>第一步，代码执行前生成全局上下文环境，并在执行时对其中的变量进行赋值。此时全局上下文环境是活动状态。<br><img src="http://images.cnitblog.com/blog/138012/201409/260749349988764.png" alt="image"></p>
<p>第二步，执行第17行代码时，调用fn()，产生fn()执行上下文环境，压栈，并设置为活动状态。<br><img src="http://images.cnitblog.com/blog/138012/201409/260750319351092.png" alt="image"></p>
<p>第三步，执行完第17行，fn()调用完成。按理说应该销毁掉fn()的执行上下文环境，但是这里不能这么做。<strong>注意，重点来了：因为执行fn()时，返回的是一个函数。函数的特别之处在于可以创建一个独立的作用域。</strong>而正巧合的是，返回的这个函数体中，还有一个自由变量max要引用fn作用域下的fn()上下文环境中的max。因此，这个max不能被销毁，销毁了之后bar函数中的max就找不到值了。</p>
<p>因此，执行到第18行时，全局上下文环境将变为活动状态，但是fn()上下文环境依然会在执行上下文栈中。另外，执行完第18行，全局上下文环境中的max被赋值为100。如下图：<br><img src="http://images.cnitblog.com/blog/138012/201409/260957500455644.png" alt="iamge"></p>
<p>第四步，执行到第20行，执行f1(15)，即执行bar(15)，创建bar(15)上下文环境，并将其设置为活动状态。<br><img src="http://images.cnitblog.com/blog/138012/201409/260958057327369.png" alt="image"><br>执行bar(15)时，max是自由变量，需要向创建bar函数的作用域中查找，找到了max的值为10。这个过程在作用域链一节已经讲过。</p>
<p><strong>这里的重点就在于，创建bar函数是在执行fn()时创建的。fn()早就执行结束了，但是fn()执行上下文环境还存在与栈中，因此bar(15)时，max可以查找到。如果fn()上下文环境销毁了，那么max就找不到了。</strong></p>
<p>使用闭包会增加内容开销，现在很明显了吧！</p>
<p>第五步，执行完20行就是上下文环境的销毁过程，这里就不再赘述了。</p>
<p>闭包和作用域、上下文环境有着密不可分的关系，真的是“想说爱你不容易”！</p>
<p>另外，闭包在jQuery中的应用非常多，在这里就不一一举例子了。所以，无论你是想了解一个经典的框架/类库，还是想自己开发一个插件或者类库，像闭包、原型这些基本的理论，是一定要知道的。否则，到时候出了BUG你都不知道为什么，因为这些BUG可能完全在你的知识范围之外。</p>
<p> 补充：由于作用域链的这种配置引出了一个值得注意的副作用，即闭包只能取得包含函数中任何变量的最后一个值。<br> 我们看一个例子：<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;ul id=&quot;list&quot;&gt;</div><div class="line">	&lt;li&gt;0&lt;/li&gt;</div><div class="line">	&lt;li&gt;1&lt;/li&gt;</div><div class="line">	&lt;li&gt;2&lt;/li&gt;</div><div class="line">	&lt;li&gt;3&lt;/li&gt;</div><div class="line">	&lt;li&gt;4&lt;/li&gt;</div><div class="line">&lt;/ul&gt;</div><div class="line">&lt;script&gt;</div><div class="line">	var list = document.getElementById(&apos;list&apos;);</div><div class="line">	var e = list.getElementsByTagName(&apos;li&apos;);</div><div class="line">	var i = 0;</div><div class="line">	for(; i &lt; e.length; i++)&#123;</div><div class="line">		e[i].onclick = function()&#123;</div><div class="line">			console.log(i);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p>我们给每个li标签加一个点击事件，返回该标签的位置。<br>结果，我们不论点哪个标签都显示 为 5。而不是按照预期的显示 0,1,2,3,4。<br>这是因为 e[i].onclick是为每个节点赋值一个onclick事件。（只是赋值，只有对应的事件发生后才会执行对应的事件函数）。在执行时function(){…}时，for循环已经结束，i的值被赋值成了5。所以每次点击i时，弹出的值都是5。</p>
<p>那如何让这段代码实现预期的效果呢？</p>
<p>我们可以借助匿名函数让闭包的行为符合预期。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var i = 0;</div><div class="line">for(; i &lt; e.length; i++)&#123;</div><div class="line">	e[i].onclick = function(num)&#123;</div><div class="line">		return function()&#123;</div><div class="line">			console.log(num);</div><div class="line">		&#125;</div><div class="line">	&#125;(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们将立即执行的匿名函数结果赋值给了e[i].onclick。这里的匿名函数有一个参数num就是要返回的值。在调用每个匿名函数时，我们都传入了变量i。变量i的当前值复制给了参数num。在这个匿名函数内部又创建并返回一个num的闭包。这样一来，e[i].click数组中每个函数都有自己num变量的一个副本。因此就返回不同的数值了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">for(; i &lt; e.length; i++)&#123;	</div><div class="line">	(function(a)&#123;</div><div class="line">		e[i].onclick = function()&#123;</div><div class="line">			console.log(a)</div><div class="line">		&#125;</div><div class="line">	&#125;)(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>[参考资料]（<a href="http://www.cnblogs.com/wangfupeng1988/p/3994065.html）" target="_blank" rel="external">http://www.cnblogs.com/wangfupeng1988/p/3994065.html）</a><br>《JavaScript高级程序设计三》</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[从自由变量到作用域栈]]></title>
      <url>https://zaynex.github.io/2016/08/09/%E4%BB%8E%E8%87%AA%E7%94%B1%E5%8F%98%E9%87%8F%E5%88%B0%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%A0%88/</url>
      <content type="html"><![CDATA[<p>先解释下什么是”自由变量”。<br><a id="more"></a><br>在A作用域中使用的变量x，却没有在A作用域中声明（即在其他作用域中声明的），对于A作用域来说，x就是一个自由变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var x = 10;</div><div class="line">function fn()&#123;</div><div class="line">	var b =20;</div><div class="line">	console.log(x + b);</div><div class="line">&#125;</div><div class="line">fn();</div></pre></td></tr></table></figure></p>
<p>如上程序中，在调用fn()函数时，函数体中第6行。取b的值就直接可以在fn作用域中取，因为b就是在这里定义的。而取x的值时，就需要到另一个作用域中取。到哪个作用域中取呢？</p>
<p>有人说过要到父作用域中取，其实有时候这种解释会产生歧义。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var x = 10;</div><div class="line">function fn()&#123;</div><div class="line">	console.log(x);</div><div class="line">&#125;</div><div class="line">function show(f) &#123;</div><div class="line">	var x =20;</div><div class="line">	(function()&#123;</div><div class="line">		f(); // 10;</div><div class="line">	&#125;)();</div><div class="line">&#125;</div><div class="line"></div><div class="line">show(fn);</div></pre></td></tr></table></figure></p>
<p>所以，不要在用以上说法了。相比而言，用这句话描述会更加贴切——<br><strong>要到创建这个函数的那个作用域中取值——是“创建”，而不是“调用”，切记切记——其实这就是所谓的“静态作用域”。</strong></p>
<p>对于本文第一段代码，在fn函数中，取自由变量x的值时，要到哪个作用域中取？——要到创建fn函数的那个作用域中取——无论fn函数将在哪里调用。</p>
<p>上面描述的只是跨一步作用域去寻找。</p>
<p>如果跨了一步，还没找到呢？——接着跨！——一直跨到全局作用域为止。要是在全局作用域中都没有找到，那就是真的没有了。</p>
<p>这个一步一步“跨”的路线，我们称之为——作用域链。<br>(在网易前端微专业里，指的是每个环境都有一个outer指针，指向外层作用域，全局作用域的outer执行为null)</p>
<p>我们拿文字总结一下取自由变量时的这个“作用域链”过程：（假设a是自由量）</p>
<ul>
<li><p>第一步，现在当前作用域查找a，如果有则获取并结束。如果没有则继续；</p>
</li>
<li><p>第二步，如果当前作用域是全局作用域，则证明a未定义，结束；否则继续；</p>
</li>
<li><p>第三步，（不是全局作用域，那就是函数作用域）将创建该函数的作用域作为当前作用域；</p>
</li>
<li><p>第四步，跳转到第一步。<br><img src="http://images.cnitblog.com/blog/138012/201409/251448515607115.png" alt="image"><br>以上代码中：第13行，fn()返回的是bar函数，赋值给x。执行x()，即执行bar函数代码。取b的值时，直接在fn作用域取出。取a的值时，试图在fn作用域取，但是取不到，只能转向创建fn的那个作用域中去查找，结果找到了。</p>
</li>
</ul>
<p><a href="http://www.cnblogs.com/wangfupeng1988/p/3992795.html" target="_blank" rel="external">参考资料：深入理解javascript原型和闭包（14）——从【自由变量】到【作用域链】</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JS作用域和上下文环境]]></title>
      <url>https://zaynex.github.io/2016/08/09/JS%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E7%8E%AF%E5%A2%83/</url>
      <content type="html"><![CDATA[<p>上文简单介绍了作用域，本文把作用域和上下文环境结合起来说一下，会理解的更深一些。<br><a id="more"></a><br><img src="http://images.cnitblog.com/blog/138012/201409/250813253577626.png" alt="image"><br>如上图，我们在上文中已经介绍了，除了全局作用域之外，每个函数都会创建自己的作用域，作用域在函数定义时就已经确定了。而不是在函数调用时确定。</p>
<p>下面我们将按照程序执行的顺序，一步一步把各个上下文环境加上。</p>
<p>第一步，在加载程序时，已经确定了全局上下文环境，并随着程序的执行而对变量就行赋值。<br><img src="http://images.cnitblog.com/blog/138012/201409/250814158269779.png" alt="image"></p>
<p>第二步，程序执行到第27行，调用fn(10)，此时生成此次调用fn函数时的上下文环境，压栈，并将此上下文环境设置为活动状态。<br><img src="http://images.cnitblog.com/blog/138012/201409/250814386853995.png" alt="image"><br>第三步，执行到第23行时，调用bar(100)，生成此次调用的上下文环境，压栈，并设置为活动状态。<br><img src="http://images.cnitblog.com/blog/138012/201409/250815006238997.png" alt="image"><br>第四步，执行完第23行，bar(100)调用完成。则bar(100)上下文环境被销毁。接着执行第24行，调用bar(200)，则又生成bar(200)的上下文环境，压栈，设置为活动状态。<br><img src="http://images.cnitblog.com/blog/138012/201409/250815248579200.png" alt="image"><br>第五步，执行完第24行，则bar(200)调用结束，其上下文环境被销毁。此时会回到fn(10)上下文环境，变为活动状态。<br><img src="http://images.cnitblog.com/blog/138012/201409/250815435609914.png" alt="image"><br>第六步，执行完第27行代码，fn(10)执行完成之后，fn(10)上下文环境被销毁，全局上下文环境又回到活动状态。<br><img src="http://images.cnitblog.com/blog/138012/201409/250816112012394.png" alt="image"><br>最后我们可以把以上这几个图片连接起来看看。<br><img src="http://images.cnitblog.com/blog/138012/201409/250816269984619.png" alt="image"><br>连接起来看，还是挺有意思的。<strong>作用域只是一个“地盘”，一个抽象的概念，其中没有变量。要通过作用域对应的执行上下文环境来获取变量的值。</strong>同一个作用域下，不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值。<strong>所以，作用域中变量的值是在执行过程中产生的确定的，而作用域却是在函数创建时就确定了。</strong></p>
<p>所以，<strong>如果要查找一个作用域下某个变量的值，就需要找到这个作用域对应的执行上下文环境，再在其中寻找变量的值。</strong></p>
<p><a href="http://www.cnblogs.com/wangfupeng1988/p/3991995.html" target="_blank" rel="external">参考资料:深入理解javascript原型和闭包（13）-【作用域】和【上下文环境】</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JS作用域]]></title>
      <url>https://zaynex.github.io/2016/08/09/JS%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
      <content type="html"><![CDATA[<p>提到作用域，我们最熟悉的一句话就是”JS中没有块级作用域”。块级作用域就是{…}里面的语句。<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var i = 10;</div><div class="line">if (i &gt; 1) &#123;</div><div class="line">	var name = &quot;Zaynex&quot;;</div><div class="line">&#125;</div><div class="line">console.log(name); // Zaynex</div></pre></td></tr></table></figure></p>
<p>再比如for语句：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for(var i=0; i&lt;10; i++) &#123;</div><div class="line">	//....</div><div class="line">&#125;</div><div class="line">console.log(i); // 10</div></pre></td></tr></table></figure></p>
<p>所以，我们在编写代码的时候，不要在“块”里面声明变量，要在代码的一开始就声明好了。以避免发生歧义。如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var i;</div><div class="line">for(i=0; i&lt;10; i++) &#123;</div><div class="line">	//....</div><div class="line">&#125;</div><div class="line">console.log(i); // 10</div></pre></td></tr></table></figure></p>
<p>其实，你光知道“javascript没有块级作用域”是完全不够的，你需要知道的是——<br><strong>javascript除了全局作用域之外，只有函数可以创建的作用域。</strong><br>所以，我们在声明变量时，全局代码要在代码前端声明，函数中要在函数体一开始就声明好。除了这两个地方，其他地方都不要出现变量声明。而且建议用“单var”形式。</p>
<p>jQuery就是一个很好的示例：<br><img src="http://images.cnitblog.com/blog/138012/201409/241708128263977.png" alt="image"><br>下面继续说作用域。作用域是一个很抽象的概念，类似于一个“地盘”。<br><img src="http://images.cnitblog.com/blog/138012/201409/241708372951952.png" alt="iamge"><br>如上图，全局代码和fn、bar两个函数都会形成一个作用域。而且，<strong>作用域有上下级的关系，上下级关系的确定就看函数是在哪个作用域下创建的。</strong>例如，fn作用域下创建了bar函数，那么“fn作用域”就是“bar作用域”的上级。</p>
<p><strong>作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。</strong><br>例如以上代码中，三个作用域下都声明了“a”这个变量，但是他们不会有冲突。各自的作用域下，用各自的“a”。<br>说到这里，咱们又可以拿出jquery源码来讲讲了。<br>jQuery源码的最外层是一个自动执行的匿名函数：<br><img src="http://images.cnitblog.com/blog/138012/201409/241709349512366.png" alt="iamge"><br>为什么要这样做呢？</p>
<p>原因就是在jQuery源码中，声明了大量的变量，这些变量将通过一个函数被限制在一个独立的作用域中，而不会与全局作用域或者<br>其他函数作用域的同名变量产生冲突。</p>
<p>全世界的开发者都在用jQuery，如果不这样做，很可能导致jQuery源码中的变量与外部javascript代码中的变量重名，从而产生冲突。</p>
<p>jQuery这种方式就是用私有作用域的匿名函数语法来表示。<br>上述代码定义并立即调用一个匿名函数。将函数声明包含在一对原括号中，表示它实际上是一个函数表达式。而紧跟后面的一对圆括号会立即调用这个函数。</p>
<p>作用域这块只是很不好解释，咱们就小步快跑，一步一步慢慢展示给大家。</p>
<p>下一节将把作用域和执行上下文环境结合起来说一说。</p>
<p>可见，要理解闭包，不是一两句话能说清楚的。。。</p>
<p><a href="http://www.cnblogs.com/wangfupeng1988/p/3991151.html" target="_blank" rel="external">参考资料</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JS中的执行上下文环境（二）]]></title>
      <url>https://zaynex.github.io/2016/08/09/JS%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E7%8E%AF%E5%A2%83/</url>
      <content type="html"><![CDATA[<p>执行全局代码时，会产生一个执行上下文环境，每次调用函数都又会产生执行上下文环境。当函数调用完成时，这个上下文环境以及其中的数据都会被消除，再重新回到全局上下文环境。<strong>处于活动状态的执行上下文环境只有一个。</strong><br><a id="more"></a><br><img src="http://images.cnitblog.com/blog/138012/201409/232122300768665.png" alt="iamge"><br>可根据以下代码来详细介绍上下文栈的压栈、出栈过程。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var a = 10, // 1.进入全局上下文环境</div><div class="line">	fn,</div><div class="line">	bar = function(x) &#123;</div><div class="line">		var b = 5;</div><div class="line">		fn(x + b);  //3.进入fn函数上下文环境</div><div class="line">	&#125;;</div><div class="line">fn = function(y) &#123;</div><div class="line">	var c = 5;</div><div class="line">	console.log(y + c); </div><div class="line">&#125;;</div><div class="line"></div><div class="line">bar(10);  // 2.进入bar函数上下文环境</div></pre></td></tr></table></figure></p>
<p>在执行代码之前，首先将创建全局上下文环境。<br>按照图片标准<br><img src="http://note.youdao.com/yws/res/34054/WEBRESOURCE6bc31b440e87df96ea235a5726db4fad" alt="image">我们得到的结果就是<br>因此我们可以得到全局上下文环境<br><img src="http://images.cnitblog.com/blog/138012/201409/232123126545539.png" alt="iamge"><br>然后是代码执行。代码执行到第12行之前，上下文环境中的变量都在执行过程中被赋值。<br><img src="http://images.cnitblog.com/blog/138012/201409/232123436078861.png" alt="iamge"><br>执行到第13行，调用bar函数。<br>跳转到bar函数内部，执行函数体语句之前，会创建一个新的执行上下文环境。<br><img src="http://images.cnitblog.com/blog/138012/201409/232124103579967.png" alt="image"><br>并将这个执行上下文环境压栈，设置为活动状态。<br><img src="http://images.cnitblog.com/blog/138012/201409/232124277955196.png" alt="iamge"><br>执行到第5行，又调用了fn函数。进入fn函数，在执行函数体语句之前，会创建fn函数的执行上下文环境，并压栈，设置为活动状态。<br><img src="http://note.youdao.com/yws/res/34056/WEBRESOURCEe3547001a84e6ff1bdefee39df26b152" alt="image"><br><img src="http://images.cnitblog.com/blog/138012/201409/232124478267882.png" alt="image"><br>待第5行执行完毕，即fn函数执行完毕后，此次调用fn所生成的上下文环境出栈，并且被销毁（已经用完了，就要及时销毁，释放内存）。<br><img src="http://images.cnitblog.com/blog/138012/201409/232125095291412.png" alt="iamge"><br>同理，待第13行执行完毕，即bar函数执行完毕后，调用bar函数所生成的上下文环境出栈，并且被销毁（已经用完了，就要及时销毁，释放内存）。<br><img src="http://images.cnitblog.com/blog/138012/201409/232125295149083.png" alt="iamge"><br>好了，我很耐心的给大家介绍了一段简短代码的执行上下文环境的变化过程，一个完整的闭环。其中上下文环境的变量赋值过程我省略了许多，因为那些并不难，一看就知道。</p>
<p>讲到这里，我不得不很遗憾的跟大家说：其实以上我们所演示的是一种比较理想的情况。有一种情况，而且是很常用的一种情况，无法做到这样干净利落的说销毁就销毁。这种情况就是伟大的——闭包。</p>
<p>要说闭包，咱们还得先从自由变量和作用域说起。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript中的this到底指向谁？]]></title>
      <url>https://zaynex.github.io/2016/08/09/JS%E4%B8%AD%E7%9A%84this%E6%8C%87%E5%90%91/</url>
      <content type="html"><![CDATA[<p>接着上一节讲的话，应该轮到“执行上下文栈”了，但是这里不得不插入一节，把this说一下。因为this很重要，js的面试题如果不出几个与this有关的，那出题者都不合格。其实，this的取值，分四种情况。我们来挨个看一下。<br><a id="more"></a><br>用一句话概括this就是：this指向调用该函数的对象。</p>
<p>在此再强调一遍一个非常重要的知识点：在函数中this到底取何值，是在函数真正被调用执行的时候确定的，函数定义的时候确定不了。因为this的取值是执行上下文环境的一部分，每次调用函数，都会产生一个新的执行上下文环境。</p>
<h3 id="场景1：构造函数"><a href="#场景1：构造函数" class="headerlink" title="场景1：构造函数"></a>场景1：构造函数</h3><p>所谓构造函数就是用来new对象的函数。其实严格来说，所有的函数都可以new一个对象，但是有些函数的定义是为了new一个对象，而有些函数则不是。另外注意，构造函数的函数名第一个字母大写（规则约定）。例如：Object、Array、Function等。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function Foo()&#123;</div><div class="line">	this.name = &apos;Zaynex&apos;;</div><div class="line">	this.age = 1995;</div><div class="line">	console.log(this);</div><div class="line">&#125;</div><div class="line"></div><div class="line">var f1 = new Foo();</div><div class="line">console.log(f1.name);//Zaynex</div><div class="line">console.log(f1.age);// 1995</div></pre></td></tr></table></figure></p>
<p>以上代码中，如果函数作为构造函数用，那么其中的this就代表它即将new出来的对象。</p>
<p>注意，以上仅限new Foo()的情况，即Foo函数作为构造函数的情况。如果直接调用Foo函数，而不是new Foo()，情况就大不一样了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function Foo()&#123;</div><div class="line">	this.name = &apos;Zaynex&apos;;</div><div class="line">	this.age = 1995;</div><div class="line">	console.log(this);//window</div><div class="line">&#125;</div><div class="line"></div><div class="line">Foo();</div></pre></td></tr></table></figure>
<p>这种情况下this是window，我们后文中会说到。</p>
<h3 id="场景2：在构造函数的prototype中"><a href="#场景2：在构造函数的prototype中" class="headerlink" title="场景2：在构造函数的prototype中"></a>场景2：在构造函数的prototype中</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function Fn()&#123;</div><div class="line">	this.name = &quot;Zaynex&quot;;</div><div class="line">	this.year = 1995;</div><div class="line">&#125;</div><div class="line">Fn.prototype.getName = function()&#123;</div><div class="line">	console.log(this.name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var f1 = new Fn();</div><div class="line">f1.getName(); //Zaynex</div></pre></td></tr></table></figure>
<p>如上代码，在Fn.prototype.getName函数中，this指向的是f1对象。因此可以通过this.name获取f1.name的值。<br><strong>其实，不仅仅是构造函数的prototype，即便是在整个原型链中，this代表的也都是当前对象的值。</strong></p>
<h3 id="情景3-函数作为一个对象的属性"><a href="#情景3-函数作为一个对象的属性" class="headerlink" title="情景3:函数作为一个对象的属性"></a>情景3:函数作为一个对象的属性</h3><p>如果函数作为对象的一个属性时，并且作为对象的一个属性被调用时，函数中的this指向该对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var obj = &#123;</div><div class="line">	x : 10,</div><div class="line">	fn : function()&#123;</div><div class="line">		console.log(this);</div><div class="line">		console.log(this.x);</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">obj.fn();</div></pre></td></tr></table></figure></p>
<p><img src="http://note.youdao.com/yws/res/34035/WEBRESOURCE03dbcc59be2237fac74a6dea4f40f574" alt="image"><br>以上代码中，fn不仅作为一个对象的一个属性，而且的确是作为对象的一个属性被调用。结果this就是obj对象。</p>
<p>注意，如果fn函数不作为obj的一个属性被调用，会是什么结果呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var obj = &#123;</div><div class="line">	x : 10,</div><div class="line">	fn : function()&#123;</div><div class="line">		console.log(this);</div><div class="line">		console.log(this.x);</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var f1 = obj.fn;</div><div class="line">f1();//undefined</div></pre></td></tr></table></figure></p>
<p>fn函数被赋值给了另一个变量中，并没有作为obj的一个属性被调用，那么this值就指向window,this.x就是undefined。那么如果我们就是想让f1()函数执行预期的效果又该怎么做呢？我们可以借助bind()方法来实现。</p>
<h4 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h4><p>它是可以将函数绑定到特定环境的方法。（ES5开始支持，IE9+,Firefox4+和Chrome）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">Function.prototype.bind = Function.prototype.bind || function(context) &#123;</div><div class="line">  var that = this;</div><div class="line">  return function() &#123;</div><div class="line">    return that.apply(context, arguments);</div><div class="line"> </div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">var obj = &#123;</div><div class="line">	x : 10,</div><div class="line">	fn : function(d)&#123;</div><div class="line">		console.log(this.x);</div><div class="line">		console.log(d);</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var f1 = obj.fn.bind(obj);</div><div class="line">f1(20); //10 20</div></pre></td></tr></table></figure>
<p>bind的核心其实就是返回一个未执行的方法，如果直接使用apply或者call：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var f1 = obj.fn.call(obj,20);</div><div class="line">f1; //10 20</div></pre></td></tr></table></figure></p>
<p>无法使用简写的func函数构造，所以用bind传递this指向，再返回一个未执行的方法，实现方式相当巧妙。</p>
<h3 id="场景4：函数用call或者是apply调用"><a href="#场景4：函数用call或者是apply调用" class="headerlink" title="场景4：函数用call或者是apply调用"></a>场景4：函数用call或者是apply调用</h3><p>当一个函数被call和apply调用时，this的值就取传入的对象的值。至于call和apply如何使用，不会的朋友可以去查查其他资料，本系列教程不做讲解。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var obj = &#123;</div><div class="line">	x : 10,</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var fn = function()&#123;</div><div class="line">	console.log(this);</div><div class="line">	console.log(this.x);</div><div class="line">&#125;</div><div class="line">fn.call(obj);</div></pre></td></tr></table></figure></p>
<h3 id="场景5：全局-amp-调用普通函数"><a href="#场景5：全局-amp-调用普通函数" class="headerlink" title="场景5：全局&amp;调用普通函数"></a>场景5：全局&amp;调用普通函数</h3><p>在全局环境下，this永远是window，这个应该没有非议。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">console.log(this === window); // true</div></pre></td></tr></table></figure></p>
<p>普通函数在调用时，其中的this也都是window。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var x = 10;</div><div class="line">var fn = function()&#123;</div><div class="line">	console.log(this);</div><div class="line">	console.log(this.x);</div><div class="line">&#125;</div><div class="line">fn();</div></pre></td></tr></table></figure></p>
<p><img src="http://note.youdao.com/yws/res/34042/WEBRESOURCE26fa10420f2ef8f5bd1773a18b5c3a4c" alt="image"></p>
<p>以上代码很好理解。</p>
<p>不过下面的情况你需要注意一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var obj = &#123;</div><div class="line">	x: 10,</div><div class="line">	fn: function()&#123;</div><div class="line">		//console.log(&quot;我是fn的this: &quot; + this);</div><div class="line">		//console.log(&quot;我是fn的this.x: &quot; + this.x);</div><div class="line">		function f()&#123;</div><div class="line">			console.log(&quot;我的fn函数里面f中的this: &quot; + this);</div><div class="line">			console.log(&quot;我的fn函数里面f中的this.x: &quot;+this.x);</div><div class="line">		&#125;</div><div class="line">		f();</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line">obj.fn();</div></pre></td></tr></table></figure></p>
<p><img src="http://note.youdao.com/yws/res/34047/WEBRESOURCE9b263545e5e35b03b9588fc8358ac912" alt="image"><br>仔细看这和场景3非常像，但最后返回的是this指向了window。因为我们在fn()这个函数中调用了f，this指向真正被调用的函数。这下可以理解this指向的是f里的window对象了吧。</p>
<h4 id="保留this值"><a href="#保留this值" class="headerlink" title="保留this值"></a>保留this值</h4><p>如果你想在内部函数中访问外部作用域的this值。只要把外部作用域中的this对象保存在内部函数能访问的变量里即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var obj = &#123;</div><div class="line">	x: 10,</div><div class="line">	fn: function()&#123;</div><div class="line">		//console.log(&quot;我是fn的this: &quot; + this);</div><div class="line">		//console.log(&quot;我是fn的this.x: &quot; + this.x);</div><div class="line">		var that = this;</div><div class="line">		function f()&#123;</div><div class="line">			console.log(&quot;我保存了fn函数里面的this: &quot; + that);</div><div class="line">			console.log(&quot;我保存了fn函数里面的this.x: &quot;+that.x);</div><div class="line">		&#125;</div><div class="line">		f();</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line">obj.fn();</div></pre></td></tr></table></figure></p>
<h3 id="jQuery源码解读"><a href="#jQuery源码解读" class="headerlink" title="jQuery源码解读"></a>jQuery源码解读</h3><p>看到了吧，this有关的知识点还是挺多的，不仅多而且非常重要。</p>
<p>最后，既然提到了this，有必要把一个非常经典的案例介绍给大家，又是jQuery源码的。<br><img src="http://images.cnitblog.com/blog/138012/201409/231455536397656.png" alt="iamge"><br>以上代码是从jQuery中摘除来的部分代码。jQuery.extend和jQuery.fn.extend都指向了同一个函数，但是当执行时，函数中的this是不一样的。执行jQuery.extend(…)时，this指向jQuery；执行jQuery.fn.extend(…)时，this指向jQuery.fn。</p>
<p>这样就巧妙的将一段代码同时共享给两个功能使用，更加符合设计原则。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://www.cnblogs.com/wangfupeng1988/p/3988422.html" target="_blank" rel="external">深入理解javascript原型和闭包（10）——this</a><br><a href="http://www.cnblogs.com/zichi/p/4357023.html" target="_blank" rel="external">ECMAScript 5(ES5)中bind方法简介备忘</a><br>《JavaScript高级程序设计三》</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JS中的执行上下文环境（一）]]></title>
      <url>https://zaynex.github.io/2016/08/09/JS%E4%B8%AD%E7%9A%84%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%E7%8E%AF%E5%A2%83/</url>
      <content type="html"><![CDATA[<p>什么是“执行上下文”（也叫做“执行上下文环境”）？暂且不下定义，先看一段代码：<br><img src="http://images.cnitblog.com/blog/138012/201409/221743466231490.png" alt="image"><br><a id="more"></a><br>第一句报错，a未定义，很正常。第二句、第三句输出都是undefined，说明浏览器在执行console.log(a)时，已经知道了a是undefined，但却不知道a是10（第三句中）。</p>
<p>在一段js代码拿过来真正一句一句运行之前，浏览器已经做了一些“准备工作”，其中就包括对变量的声明，而不是赋值。变量赋值是在赋值语句执行的时候进行的。可用下图模拟：<br><img src="http://images.cnitblog.com/blog/138012/201409/221744084828533.png" alt="image"><br>这是第一种情况。</p>
<p>下面还有。先来个简单的。<br><img src="http://images.cnitblog.com/blog/138012/201409/221744319354566.png" alt="image"><br>有js开发经验的朋友应该都知道，你无论在哪个位置获取this，都是有值的。至于this的取值情况，比较复杂，会专门拿出一篇文章来讲解。</p>
<p>与第一种情况不同的是：第一种情况只是对变量进行声明（并没有赋值），而此种情况直接给this赋值。这也是“准备工作”情况要做的事情之一。</p>
<p>下面还有。。。第三种情况。<br>在第三种情况中，需要注意代码注释中的两个名词——“函数表达式”和“函数声明”。虽然两者都很常用，但是这两者在“准备工作”时，却是两种待遇。<br><img src="http://images.cnitblog.com/blog/138012/201409/221745066078791.png" alt="image"><br>看以上代码。“函数声明”时我们看到了第二种情况的影子，而“函数表达式”时我们看到了第一种情况的影子。</p>
<p>没错。在“准备工作”中，对待函数表达式就像对待“ var a = 10 ”这样的变量一样，只是声明。而对待函数声明时，却把函数整个赋值了。</p>
<p>好了，“准备工作”介绍完毕。</p>
<p>我们总结一下，在“准备工作”中完成了哪些工作：</p>
<ul>
<li>变量、函数表达式——变量声明，默认赋值为undefined；</li>
<li>this——赋值；    </li>
<li>函数声明——赋值；<br>这三种数据的准备情况我们称之为“执行上下文”或者“执行上下文环境”。</li>
</ul>
<p>细心的朋友可能会发现，我们上面所有的例子都是在全局环境下执行的。</p>
<p>其实，javascript在执行一个代码段之前，都会进行这些“准备工作”来生成执行上下文。这个“代码段”其实分三种情况——全局代码，函数体，eval代码。<br>这里解释一下为什么代码段分为这三种。</p>
<p>所谓“代码段”就是一段文本形式的代码。</p>
<p>首先，全局代码是一种，这个应该没有非议，本来就是手写文本到<script>标签里面的。<br><img src="http://images.cnitblog.com/blog/138012/201409/221746370927602.png" alt="image"><br>其次，eval代码接收的也是一段文本形式的代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">eval(&quot;console.log(&apos;123&apos;)&quot;);</div></pre></td></tr></table></figure></p>
<p>最后，函数体是代码段是因为函数在创建时，本质上是 new Function(…) 得来的，其中需要传入一个文本形式的参数作为函数体。<br><img src="http://images.cnitblog.com/blog/138012/201409/221746583578531.png" alt="image"><br>这样解释应该能理解了。</p>
<p>如果在函数中，除了以上数据之外，还会有其他数据。先看以下代码：<br><img src="http://images.cnitblog.com/blog/138012/201409/230840377174282.png" alt="image"><br>以上代码展示了在函数体的语句执行之前，arguments变量和函数的参数都已经被赋值。从这里可以看出，函数每被调用一次，都会产生一个新的执行上下文环境。因为不同的调用可能就会有不同的参数。</p>
<p>另外一点不同在于，函数在定义的时候（不是调用的时候），就已经确定了函数体内部自由变量的作用域。至于“自由变量”和“作用域”是后面要专门拿出来讲述的重点，这里就先点到为止。用一个例子说明一下：<br><img src="http://images.cnitblog.com/blog/138012/201409/230841277489133.png" alt="image"><br>好了，总结完了函数的附加内容，我们就此要全面总结一下上下文环境的数据内容。</p>
<p>全局代码的上下文环境数据内容为：<br><img src="http://note.youdao.com/yws/res/34030/WEBRESOURCE647dc9f990f8bd2d946a0a1fb192018e" alt="image"></p>
<p>给执行上下文环境下一个通俗的定义——<strong>在执行代码之前，把将要用到的所有的变量都事先拿出来，有的直接赋值了，有的先用undefined占个空。</strong></p>
<p>讲完了上下文环境，又来了新的问题——在执行js代码时，会有数不清的函数调用次数，会产生许多个上下文环境。这么多上下文环境该如何管理，以及如何销毁而释放内存呢？下一节将通过“执行上下文栈”来解释这个问题。</p>
<p>不过别着急，在解释“执行上下文栈”之前，还需要把this说一下，this还是挺重要的。</p>
<p>说完this，接着说执行上下文栈。</p>
<p>参考来源：<a href="http://www.cnblogs.com/wangfupeng1988/p/3987563.html">http://www.cnblogs.com/wangfupeng1988/p/3987563.html</a></p>
</script></p>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[致我辞职后的第一个月]]></title>
      <url>https://zaynex.github.io/2016/08/08/%E8%87%B4%E6%88%91%E8%BE%9E%E8%81%8C%E5%90%8E%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%9C%88/</url>
      <content type="html"><![CDATA[<p>身边很多朋友都不理解，甚至是惊讶：你不就是想做产品么？在网易待得不是挺好吗？这么好的机会怎么又放弃了。</p>
<p>我想跟身边的人解释些什么，但总感觉有些说辞有些冠冕堂皇，可能当你真正想明白了一件事情，无须向他人解释些什么，自己尽管做就好了。<br>还是切入正题，太多抒情的话题，要把合理的作息调整回来。</p>
<p>这一个月勉强算是掌握了JS的基础吧。<br>但是闭包还是没有理解。明天再撰写下闭包的笔记。书中关于活动对象的介绍不多，之前看了博客园的王福朋的博客，当时看懂了，看来还需要自己码一码字，搬到博客上来印象才深刻。（<a href="http://www.cnblogs.com/wangfupeng1988/p/3977987.html）" target="_blank" rel="external">http://www.cnblogs.com/wangfupeng1988/p/3977987.html）</a><br>还是得按照ife上再好好梳理一下。<a href="https://github.com/baidu-ife/ife/tree/master/2015_spring/task/task0003" target="_blank" rel="external">https://github.com/baidu-ife/ife/tree/master/2015_spring/task/task0003</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[《锋利的jQuery》第四章读书笔记]]></title>
      <url>https://zaynex.github.io/2016/08/08/%E3%80%8A%E9%94%8B%E5%88%A9%E7%9A%84jQuery%E4%BA%8C%E3%80%8B%E7%AC%AC%E5%9B%9B%E7%AB%A0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h2 id="加载DOM"><a href="#加载DOM" class="headerlink" title="加载DOM"></a>加载DOM</h2><p>window.onload是在页面所有元素包括关联元素加载完毕才执行，此时的JS可以访问网页中的任何元素。</p>
<p>$(document).ready()方法注册事件处理程序只需在DOM就绪时就可以被调用。此时JQ可以访问网页所有元素，但并不一定元素关联的文件都已经下载完毕。<br><a id="more"></a><br>当然，如果希望在所有元素加载完全后再注册事件可以采用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(window).load(function()&#123;&#125;);</div></pre></td></tr></table></figure></p>
<p>window.onload 事件值一次只能保存对一个函数的引用，会自动覆盖前面的函数。</p>
<h3 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h3><p>类似于addEventListener<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//语法</div><div class="line">bind(type, [,data], fn);</div><div class="line"></div><div class="line">$(&quot;#panel h5.head&quot;).bind(&quot;mouseover&quot;,function()&#123;</div><div class="line">     $(this).next().show();</div><div class="line"></div><div class="line">//简写</div><div class="line">$(&quot;#panel h5.head&quot;).mouseover(function()&#123;</div><div class="line">	$(this).next().show();</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>jQ中的事件类型比JS事件类型少了 “on”。</p>
<p>当发现相同的选择器在代码中出现较多时，请用变量保存起来。</p>
<h3 id="合成事件"><a href="#合成事件" class="headerlink" title="合成事件"></a>合成事件</h3><h4 id="hover-enter-leave"><a href="#hover-enter-leave" class="headerlink" title="hover(enter, leave);"></a>hover(enter, leave);</h4><p>用于模拟光标悬停事件。当光标移动到元素上时，会触发指定的第一个函数，。移出时触发第二个函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$(&quot;#panel h5.head&quot;).hover(function()&#123;</div><div class="line">    $(this).next().show();</div><div class="line">&#125;,function()&#123;</div><div class="line">    $(this).next().hide();</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<h4 id="toggle-fn1-fn2…fnN"><a href="#toggle-fn1-fn2…fnN" class="headerlink" title="toggle(fn1,fn2…fnN);"></a>toggle(fn1,fn2…fnN);</h4><p>第一次点击触发fn1函数，第二次fn2，依次类推。</p>
<p>此外，还可以<strong>切换元素可见状态</strong><br>如果是可见的，则切换为隐藏，如果不可见，则显示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">   $(&quot;#panel h5.head&quot;).toggle(function()&#123;</div><div class="line">		$(this).addClass(&quot;highlight&quot;);</div><div class="line">		$(this).next().show();</div><div class="line">&#125;,function()&#123;</div><div class="line">		$(this).removeClass(&quot;highlight&quot;);</div><div class="line">		$(this).next().hide();</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h3><p>在内部元素被触发事件时，其包括的外部元素也会被触发事件。</p>
<h4 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$(&apos;span&apos;).bind(&quot;click&quot;,function(event)&#123;</div><div class="line">	var txt = $(&apos;#msg&apos;).html() + &quot;&lt;p&gt;内层span元素被点击.&lt;p/&gt;&quot;;</div><div class="line">	$(&apos;#msg&apos;).html(txt);</div><div class="line">	event.stopPropagation();    //  阻止事件冒泡</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>function()中的event就是事件对象，只在事件处理函数执行时才能访问到，事件处理函数执行完毕后，事件对象就被销毁。<br>使用停止事件冒泡的方法<br>event.stopPropagation();</p>
<h4 id="阻止默认行为"><a href="#阻止默认行为" class="headerlink" title="阻止默认行为"></a>阻止默认行为</h4><p>a标签或者在表单提交中有自带默认的行为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$(&quot;#sub&quot;).bind(&quot;click&quot;,function(event)&#123;</div><div class="line">      var username = $(&quot;#username&quot;).val();  //获取元素的值</div><div class="line">      if(username==&quot;&quot;)&#123;     //判断值是否为空</div><div class="line">    $(&quot;#msg&quot;).html(&quot;&lt;p&gt;文本框的值不能为空.&lt;/p&gt;&quot;);  //提示信息</div><div class="line">    event.preventDefault();  //阻止默认行为 ( 表单提交 )</div><div class="line">&#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>此外还可以使用简写方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">return false;</div></pre></td></tr></table></figure></p>
<p>阻止事件冒泡也是如此。</p>
<h3 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h3><p>事件捕获从最顶端开始向内触发事件，与冒泡正好相反。</p>
<h4 id="event-pageX"><a href="#event-pageX" class="headerlink" title="event.pageX"></a>event.pageX</h4><p>该方法是获取光标相对于页面的X坐标。IE中event.X，Firefox中event.pageX。如果页面上有滚动条， 还要加上滚动条的宽度或高度</p>
<h3 id="移除事件"><a href="#移除事件" class="headerlink" title="移除事件"></a>移除事件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$(&apos;#btn&apos;).bind(&quot;click&quot;, function()&#123;</div><div class="line">			 $(&apos;#test&apos;).append(&quot;&lt;p&gt;我的绑定函数1&lt;/p&gt;&quot;);</div><div class="line">	  &#125;).bind(&quot;click&quot;, function()&#123;</div><div class="line">			 $(&apos;#test&apos;).append(&quot;&lt;p&gt;我的绑定函数2&lt;/p&gt;&quot;);</div><div class="line">	  &#125;).bind(&quot;click&quot;, myFun1 = function()&#123;</div><div class="line">		  	 $(&apos;#test&apos;).append(&quot;&lt;p&gt;我的绑定函数3&lt;/p&gt;&quot;);</div><div class="line">      &#125;);</div><div class="line">$(&apos;#delAll&apos;).click(function()&#123;</div><div class="line">	  $(&apos;#btn&apos;).unbind(&quot;click&quot;, myFun1);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>unbind()的第二个参数可选。</p>
<h4 id="one"><a href="#one" class="headerlink" title="one()"></a>one()</h4><p>one(type, [data], fn);<br>只需要触发一次，随后就立即解除绑定。</p>
<h3 id="模拟操作"><a href="#模拟操作" class="headerlink" title="模拟操作"></a>模拟操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(&quot;#btn&quot;).trigger(&quot;click&quot;);</div></pre></td></tr></table></figure>
<p>有时候需要模拟用户操作来达到点击效果。<br>这样就可以在页面装载完毕后，立即输出想要的效果。</p>
<h4 id="触发自定义事件"><a href="#触发自定义事件" class="headerlink" title="触发自定义事件"></a>触发自定义事件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$(&quot;#btn&quot;).bind(&quot;myClick&quot;, function()&#123;</div><div class="line">	$(&quot;#test&quot;).append(&quot;&lt;p&gt;我的自定义事件&lt;/p&gt;&quot;);</div><div class="line">&#125;);</div><div class="line">$(&quot;#btn&quot;).trigger(&quot;myClick&quot;);</div></pre></td></tr></table></figure>
<h4 id="传递数据"><a href="#传递数据" class="headerlink" title="传递数据"></a>传递数据</h4><p>triggle(type,[data])方法有两个参数，第二个是事件处理函数的附加数据，以数组形式传递<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$(&quot;#btn&quot;).bind(&quot;myClick&quot;, function(event, message1, message2)&#123;</div><div class="line">	$(&quot;#test&quot;).append(&quot;&lt;p&gt;&quot;+ message1 + message2 + &quot;&lt;/p&gt;&quot;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">$(&quot;#btn&quot;).trigger(&quot;myClick&quot;, [&quot;我的自定义&quot;,&quot;事件&quot;]);</div></pre></td></tr></table></figure></p>
<h4 id="默认操作"><a href="#默认操作" class="headerlink" title="默认操作"></a>默认操作</h4><p>$(“input”).trigger(“focus”);<br>触发input元素绑定的focus事件，使input元素本身获得焦点（浏览器默认操作）。</p>
<p>如果只想触发绑定的focus事件，而不想执行浏览器默认操作，可以使用JQ中的<br>triggerHandler() 方法。</p>
<h3 id="其他方法应用"><a href="#其他方法应用" class="headerlink" title="其他方法应用"></a>其他方法应用</h3><p>bind()绑定多个事件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$(&quot;div&quot;).bind(&quot;mouseover mouseout&quot;, function()&#123;</div><div class="line">   $(this).toggleClass(&quot;over&quot;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h3><p>show() === css(“display”,”block”);<br>hide() === css(“display”,”none”);</p>
<p>$(“element”).show(“slow”);<br>除了slow（600ms）外，还有fast(200ms),normal(400ms)。<br>或者指定数值<br>$(“element”).show(600);</p>
<p>fadaIn()和fadeOut()<br>改变透明度至0，然后再设为hide()或者是show()</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">   $(&quot;#panel h5.head&quot;).toggle(function()&#123;</div><div class="line">     $(this).next().slideUp();</div><div class="line">&#125;,function()&#123;</div><div class="line">     $(this).next().slideDown();</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>改变高度显示内容，效果较好。</p>
<h3 id="链式运动"><a href="#链式运动" class="headerlink" title="链式运动"></a>链式运动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$(&quot;#panel&quot;).css(&quot;opacity&quot;, &quot;0.5&quot;);//设置不透明度</div><div class="line">$(&quot;#panel&quot;).click(function()&#123;</div><div class="line">      $(this).animate(&#123;left: &quot;400px&quot;, height:&quot;200px&quot; ,opacity: &quot;1&quot;&#125;, 3000)</div><div class="line">			 .animate(&#123;top: &quot;200px&quot; , width :&quot;200px&quot;&#125;, 3000 )</div><div class="line">			 .css(&quot;border&quot;,&quot;5px solid blue&quot;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这段代码中css是立即执行，没有遵从链式运动。我们需要利用回调函数对非动画方法实现排队。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$(&quot;#panel&quot;).css(&quot;opacity&quot;, &quot;0.5&quot;);//设置不透明度</div><div class="line">$(&quot;#panel&quot;).click(function()&#123;</div><div class="line">      $(this).animate(&#123;left: &quot;400px&quot;, height:&quot;200px&quot; ,opacity: &quot;1&quot;&#125;, 3000)</div><div class="line">			 .animate(&#123;top: &quot;200px&quot; , width :&quot;200px&quot;&#125;, 3000,</div><div class="line">			 .function()&#123;$(this).css(&quot;border&quot;,&quot;5px solid blue&quot;);&#125;)</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="停止动画的尴尬"><a href="#停止动画的尴尬" class="headerlink" title="停止动画的尴尬"></a>停止动画的尴尬</h3><p>在为一个元素绑定hover事件后，用户把光标移入会触发一个事件，而这个动画还没结束，用户又把光标移出，又触发另一个动画事件，等到光标移入的动画结束后再执行。如果光标移入移出过快就会导致动画效果与光标动作不一致。在光标移入前，我们需要先加一个stop（）方法，解决这个问题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$(&quot;#panel&quot;).hover(function() &#123;</div><div class="line">  $(this).stop().animate(&#123;height : &quot;150&quot;,width : &quot;300&quot;&#125; , 200 );</div><div class="line">&#125;,function() &#123;</div><div class="line">  $(this).stop().animate(&#123;height : &quot;22&quot;,width : &quot;60&quot; &#125; , 300 );</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>完善下stop()停止函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"> $(&quot;#panel&quot;).hover(function() &#123;</div><div class="line">			$(this).stop(true)</div><div class="line">				.animate(&#123;height : &quot;150&quot; &#125; , 200 )</div><div class="line">				.animate(&#123;width : &quot;300&quot; &#125; , 300 )</div><div class="line">&#125;,function() &#123;</div><div class="line">			$(this).stop(true)</div><div class="line">				.animate(&#123;height : &quot;22&quot; &#125; , 200 )</div><div class="line">				.animate(&#123;width : &quot;60&quot; &#125; , 300 )</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>传递一个参数就可以避免在组合运动时防止其他运动还在继续。<br>它的作用就是清除所有运动事件。</p>
<h4 id="dalay-延迟动画"><a href="#dalay-延迟动画" class="headerlink" title="dalay()延迟动画"></a>dalay()延迟动画</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$(&quot;#panel&quot;).css(&quot;opacity&quot;, &quot;0.5&quot;);//设置不透明度</div><div class="line">$(&quot;#panel&quot;).click(function()&#123;</div><div class="line">      $(this).animate(&#123;left: &quot;400px&quot;, height:&quot;200px&quot; ,opacity: &quot;1&quot;&#125;, 3000)</div><div class="line">			 .delay(1000)</div><div class="line">			 .animate(&#123;top: &quot;200px&quot; , width :&quot;200px&quot;&#125;, 3000 )</div><div class="line">			 .delay(2000)</div><div class="line">			 .fadeOut(&quot;slow&quot;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="比slideDown更简洁的方法"><a href="#比slideDown更简洁的方法" class="headerlink" title="比slideDown更简洁的方法"></a>比slideDown更简洁的方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">   $(&quot;#panel h5.head&quot;).click(function()&#123;</div><div class="line">     $(this).next().slideToggle();</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h4 id="比fadeOut更简洁的方法"><a href="#比fadeOut更简洁的方法" class="headerlink" title="比fadeOut更简洁的方法"></a>比fadeOut更简洁的方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">   $(&quot;#panel h5.head&quot;).click(function()&#123;</div><div class="line">     $(this).next().fadeToggle();</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h3 id="方法汇总"><a href="#方法汇总" class="headerlink" title="方法汇总"></a>方法汇总</h3><p><img src="http://note.youdao.com/yws/res/34018/WEBRESOURCE6e670a93a54b40d6a01fd132de5e9c79" alt="image"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[《锋利的jQuery二》第三章读书笔记]]></title>
      <url>https://zaynex.github.io/2016/08/08/%E3%80%8A%E9%94%8B%E5%88%A9%E7%9A%84jQuery%E4%BA%8C%E3%80%8B%E7%AC%AC%E4%B8%89%E7%AB%A0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h2 id="节点操作"><a href="#节点操作" class="headerlink" title="节点操作"></a>节点操作</h2><h3 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var $li_1 = $(&quot;&lt;li title=&apos;我是title啊&apos;&gt;香蕉&lt;/li&gt;&quot;);</div><div class="line">var $li_2 = $(&quot;&lt;li&gt;&lt;/li&gt;&quot;);</div><div class="line">$(&quot;ul&quot;).append($li_1);</div><div class="line">$(&quot;ul&quot;).append($li_2);</div><div class="line">//也可以是下面这样</div><div class="line">$(&quot;ul&quot;).append(&apos;&lt;li title=&quot;我是title啊&quot;&gt;柠檬&lt;/li&gt;&apos;)</div></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"> $(function()&#123;</div><div class="line"> /*</div><div class="line"> 	var $li = $(&quot;ul li:eq(2)&quot;);</div><div class="line"> 	var li_txt = $li.text();</div><div class="line"> 	alert(li_txt);</div><div class="line"> 	var $para = $(&quot;p&quot;);</div><div class="line"> 	var p_txt = $para.attr(&quot;title&quot;);</div><div class="line"> 	alert(p_txt);</div><div class="line"> */</div><div class="line">var $li_1 = $(&quot;&lt;li title=&apos;我是title啊&apos;&gt;香蕉&lt;/li&gt;&quot;);</div><div class="line">var $li_2 = $(&quot;&lt;li title=&apos;titile&apos;&gt;柠檬&lt;/li&gt;&quot;);</div><div class="line">var $li_3 = $(&quot;&lt;li title=&apos;title&apos;&gt;其他&lt;/li&gt;&quot;)</div><div class="line"></div><div class="line">var $parent = $(&quot;ul&quot;);</div><div class="line">var $two_li = $(&quot;ul li:eq(1)&quot;); //(index从0开始)</div><div class="line">$parent.append($li_1);</div><div class="line">$parent.prepend($li_2);</div><div class="line">$li_3.insertAfter($two_li); //执行这段代码的时候保存最初的状态，不会因为后来的插入而影响</div><div class="line"></div><div class="line"> &#125;)</div><div class="line"> &lt;/script&gt;</div><div class="line">	&lt;p title=&quot;选择你最喜欢的水果.&quot; &gt;你最喜欢的水果是?&lt;/p&gt;</div><div class="line">	&lt;ul&gt;</div><div class="line">	  &lt;li title=&apos;苹果&apos;&gt;苹果&lt;/li&gt;</div><div class="line">	  &lt;li title=&apos;橘子&apos;&gt;橘子&lt;/li&gt;</div><div class="line">	  &lt;li title=&apos;菠萝&apos;&gt;菠萝&lt;/li&gt;</div><div class="line">	&lt;/ul&gt;</div></pre></td></tr></table></figure>
<p><img src="http://note.youdao.com/yws/res/33463/WEBRESOURCEc1c3fd684a05f91cf15b4ca2814d51df" alt="image"></p>
<h4 id="节点交换"><a href="#节点交换" class="headerlink" title="节点交换"></a>节点交换</h4><p><img src="http://note.youdao.com/yws/res/33466/WEBRESOURCE5bb9146b4a6650ccbc6f3a309101ff9f" alt="image"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var $one_li = $(&quot;ul li:eq(1)&quot;);</div><div class="line">var $two_li = $(&quot;ul li:eq(2)&quot;);</div><div class="line">$two_li.insertBefore($one_li);</div></pre></td></tr></table></figure></p>
<p><img src="http://note.youdao.com/yws/res/33470/WEBRESOURCEdb394827528ec1f285280618e2ceea8d" alt="image"></p>
<h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var $li = $(&quot;ul li:eq(1)&quot;).remove();</div><div class="line">$li.appendTo(&apos;ul&apos;);//与append()的使用相反</div><div class="line">，结果相同;</div></pre></td></tr></table></figure>
<h4 id="detach-与remove-差异"><a href="#detach-与remove-差异" class="headerlink" title="detach()与remove()差异"></a>detach()与remove()差异</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">$(&quot;ul li&quot;).click(function() &#123;</div><div class="line">	alert($(this).html());</div><div class="line">&#125;);</div><div class="line">var $li = $(&quot;ul li:eq(1)&quot;).detach();</div><div class="line">$li.appendTo(&apos;ul&apos;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>remove()后再重新插入节点后的事件将失效，但是detach()会保留</p>
<h4 id="empty"><a href="#empty" class="headerlink" title="empty()"></a>empty()</h4><p>清空节点内容。</p>
<h3 id="复制节点"><a href="#复制节点" class="headerlink" title="复制节点"></a>复制节点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$(&quot;ul li&quot;).click(function() &#123;</div><div class="line">	$(this).clone().appendTo(&apos;ul&apos;);</div><div class="line">	//如果是clone(true)则复制事件</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="替换节点"><a href="#替换节点" class="headerlink" title="替换节点"></a>替换节点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(&quot;p&quot;).replaceWith(&apos;&lt;strong&gt;你最不喜欢的水果是&lt;/strong&gt;&apos;);</div></pre></td></tr></table></figure>
<p>替换前的事件都将取消，需要重新绑定事件。</p>
<h3 id="包裹节点"><a href="#包裹节点" class="headerlink" title="包裹节点"></a>包裹节点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$(&quot;strong&quot;).wrap(&quot;&lt;b&gt;&lt;/b&gt;&quot;);//用p标签把strong包括起来</div><div class="line"></div><div class="line"></div><div class="line">$(&quot;strong&quot;).wrapInner(&apos;&lt;b&gt;&lt;/b&gt;&apos;);</div><div class="line">&#125;);</div><div class="line">//将匹配的元素的innerTHML加b标签</div></pre></td></tr></table></figure>
<h3 id="属性操作"><a href="#属性操作" class="headerlink" title="属性操作"></a>属性操作</h3><p>JQ中有很多方法都实现了同一个函数实现getter和setter属性。比如<br>attr()、html()、text()、height()、width()方法等<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">$(&quot;input:eq(1)&quot;).click(function()&#123;</div><div class="line">		alert( $(&quot;p&quot;).attr(&quot;title&quot;) );</div><div class="line">  &#125;);</div><div class="line">     //删除&lt;p&gt;元素的属性&apos;title&apos;</div><div class="line">  $(&quot;input:eq(2)&quot;).click(function()&#123;</div><div class="line">		$(&quot;p&quot;).removeAttr(&quot;title&quot;);</div><div class="line">  &#125;);</div></pre></td></tr></table></figure></p>
<h3 id="样式操作"><a href="#样式操作" class="headerlink" title="样式操作"></a>样式操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$(&quot;input:eq(1)&quot;).click(function()&#123;</div><div class="line">			$(&quot;p&quot;).attr(&quot;class&quot;,&quot;high&quot;);</div><div class="line">	  &#125;);</div></pre></td></tr></table></figure>
<p>会将原来的class属性覆盖，设置成新的</p>
<h4 id="追加样式"><a href="#追加样式" class="headerlink" title="追加样式"></a>追加样式</h4><p>addClass()会保留原有class</p>
<p><img src="http://note.youdao.com/yws/res/33513/WEBRESOURCE7ff72928f06398352dbcdc71eef691a6" alt="image"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">//重复切换样式</div><div class="line">$(&quot;input:eq(5)&quot;).click(function()&#123;</div><div class="line">	$(&quot;p&quot;).toggleClass(&quot;another&quot;);</div><div class="line">&#125;);</div><div class="line">//判断是否含有该样式</div><div class="line">$(&quot;input:eq(6)&quot;).click(function()&#123;</div><div class="line">	alert( $(&quot;p&quot;).hasClass(&quot;another&quot;) )</div><div class="line">	alert( $(&quot;p&quot;).is(&quot;.another&quot;) )</div><div class="line">	//hasClass()增强代码可读性。</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h4 id="读取内容"><a href="#读取内容" class="headerlink" title="读取内容"></a>读取内容</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">$(&quot;input:eq(0)&quot;).click(function()&#123;</div><div class="line">	alert(  $(&quot;p&quot;).html() );</div><div class="line">&#125;);</div><div class="line">//获取&lt;p&gt;元素的文本</div><div class="line">$(&quot;input:eq(1)&quot;).click(function()&#123;</div><div class="line">	alert(  $(&quot;p&quot;).text() );</div><div class="line">&#125;);</div><div class="line">//设置&lt;p&gt;元素的HTML代码</div><div class="line">$(&quot;input:eq(2)&quot;).click(function()&#123;</div><div class="line">	 $(&quot;p&quot;).html(&quot;&lt;strong&gt;你最喜欢的水果是?&lt;/strong&gt;&quot;);</div><div class="line">&#125;); </div><div class="line">//设置&lt;p&gt;元素的文本</div><div class="line">$(&quot;input:eq(3)&quot;).click(function()&#123;</div><div class="line">	 $(&quot;p&quot;).text(&quot;你最喜欢的水果是?&quot;);</div><div class="line">&#125;);</div><div class="line">//设置&lt;p&gt;元素的文本</div><div class="line">$(&quot;input:eq(4)&quot;).click(function()&#123;</div><div class="line">	 $(&quot;p&quot;).text(&quot;&lt;strong&gt;你最喜欢的水果是?&lt;/strong&gt;&quot;);</div><div class="line">&#125;);</div><div class="line">//获取按钮的value值</div><div class="line">$(&quot;input:eq(5)&quot;).click(function()&#123;</div><div class="line">	 alert( $(this).val() );</div><div class="line">&#125;);</div><div class="line">//设置按钮的value值</div><div class="line">$(&quot;input:eq(6)&quot;).click(function()&#123;</div><div class="line">    $(this).val(&quot;我被点击了!&quot;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>表单元素defalutValue属性表示表单的初始值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$(&quot;#password&quot;).blur(function()&#123;</div><div class="line">      var txt_value =  $(this).val();</div><div class="line">	if(txt_value==&quot;&quot;)&#123;</div><div class="line">        $(this).val(this.defaultValue);</div><div class="line">	&#125; </div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
<p>使用val()可以设置表单元素选中情况<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">$(&quot;input:eq(0)&quot;).click(function()&#123;</div><div class="line">	$(&quot;#single&quot;).val(&quot;选择2号&quot;);</div><div class="line">&#125;);</div><div class="line">//设置多选下拉框选中</div><div class="line">$(&quot;input:eq(1)&quot;).click(function()&#123;</div><div class="line">    $(&quot;#multiple&quot;).val([&quot;选择2号&quot;, &quot;选择3号&quot;]);</div><div class="line">&#125;);</div><div class="line">//设置单选框和多选框选中</div><div class="line">$(&quot;input:eq(2)&quot;).click(function()&#123;</div><div class="line"> 	$(&quot;:checkbox&quot;).val([&quot;check2&quot;,&quot;check3&quot;]);</div><div class="line">	$(&quot;:radio&quot;).val([&quot;radio2&quot;]);</div><div class="line">&#125;);  </div><div class="line">$(&quot;input:eq(0)&quot;).click(function()&#123;</div><div class="line">    $(&quot;#single option&quot;).removeAttr(&quot;selected&quot;);  //移除属性selected</div><div class="line">	$(&quot;#single option:eq(1)&quot;).attr(&quot;selected&quot;,true); //设置属性selected</div><div class="line">&#125;);</div><div class="line">//设置多选下拉框选中</div><div class="line">$(&quot;input:eq(1)&quot;).click(function()&#123;</div><div class="line">    $(&quot;#multiple option&quot;).removeAttr(&quot;selected&quot;);  //移除属性selected</div><div class="line">	$(&quot;#multiple option:eq(2)&quot;).attr(&quot;selected&quot;,true);//设置属性selected</div><div class="line">	$(&quot;#multiple option:eq(3)&quot;).attr(&quot;selected&quot;,true);//设置属性selected</div><div class="line">&#125;);</div><div class="line">//设置单选框和多选框选中</div><div class="line">$(&quot;input:eq(2)&quot;).click(function()&#123;</div><div class="line">	$(&quot;:checkbox&quot;).removeAttr(&quot;checked&quot;); //移除属性checked</div><div class="line">	$(&quot;:radio&quot;).removeAttr(&quot;checked&quot;); //移除属性checked</div><div class="line">	$(&quot;[value=check2]:checkbox&quot;).attr(&quot;checked&quot;,true);//设置属性checked</div><div class="line">	$(&quot;[value=check3]:checkbox&quot;).attr(&quot;checked&quot;,true);//设置属性checked</div><div class="line">	$(&quot;[value=radio2]:radio&quot;).attr(&quot;checked&quot;,true);//设置属性checked</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="遍历节点"><a href="#遍历节点" class="headerlink" title="遍历节点"></a>遍历节点</h3><p>children()只获取子元素的个数，不包括后代元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">var $body = $(&quot;body&quot;).children();</div><div class="line"> var $p = $(&quot;p&quot;).children();</div><div class="line"> var $ul = $(&quot;ul&quot;).children();</div><div class="line"> alert( $body.length );  // &lt;body&gt;元素下有2个子元素</div><div class="line"> alert( $p.length );     // &lt;p&gt;元素下有0个子元素</div><div class="line"> alert( $ul.length );    // &lt;p&gt;元素下有3个子元素</div><div class="line"> for(var i=0;i&lt; $ul.length;i++)&#123;</div><div class="line">     alert( $ul[i].innerHTML );</div><div class="line"> &#125;</div><div class="line">&lt;p title=&quot;选择你最喜欢的水果.&quot; &gt;你最喜欢的水果是?&lt;/p&gt;</div><div class="line">&lt;ul&gt;</div><div class="line">  &lt;li title=&apos;苹果&apos;&gt;苹果&lt;/li&gt;</div><div class="line">  &lt;li title=&apos;橘子&apos;&gt;橘子&lt;/li&gt;</div><div class="line">  &lt;li title=&apos;菠萝&apos;&gt;菠萝&lt;/li&gt;</div><div class="line">&lt;/ul&gt;</div></pre></td></tr></table></figure></p>
<h3 id="获取邻近节点"><a href="#获取邻近节点" class="headerlink" title="获取邻近节点"></a>获取邻近节点</h3> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var $p1 = $(&quot;p&quot;).next();</div><div class="line">alert( $p1.html() );  //  紧邻&lt;p&gt;元素后的同辈元素</div><div class="line">var $ul = $(&quot;ul&quot;).prev();</div><div class="line">alert( $ul.html() );  //  紧邻&lt;ul&gt;元素前的同辈元素</div><div class="line">var $p2 = $(&quot;p&quot;).siblings();</div><div class="line">alert( $p2.html() );  //  紧邻&lt;p&gt;元素的唯一同辈元素</div><div class="line">&lt;p title=&quot;选择你最喜欢的水果.&quot; &gt;你最喜欢的水果是?&lt;/p&gt;</div><div class="line">&lt;ul&gt;</div><div class="line">  &lt;li title=&apos;苹果&apos;&gt;苹果&lt;/li&gt;</div><div class="line">  &lt;li title=&apos;橘子&apos;&gt;橘子&lt;/li&gt;</div><div class="line">  &lt;li title=&apos;菠萝&apos;&gt;菠萝&lt;/li&gt;</div><div class="line">&lt;/ul&gt;</div></pre></td></tr></table></figure>
<p>注意:Siblings()方法会优先获取前面的元素，如果没有前面的元素，则获取后面相邻的元素（包括该元素的后代元素）。</p>
<h3 id="closest"><a href="#closest" class="headerlink" title="closest()"></a>closest()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$(document).bind(&quot;click&quot;, function (e) &#123;</div><div class="line">	$(e.target).closest(&quot;li&quot;).css(&quot;color&quot;,&quot;red&quot;);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>JQ的bind() 方法为被选元素添加一个或多个事件处理程序，并规定事件发生时运行的函数。</p>
<p>closest()方法用于取得最近的匹配元素，包括自身。</p>
<h4 id="closest-于其他方法"><a href="#closest-于其他方法" class="headerlink" title="closest()于其他方法"></a>closest()于其他方法</h4><p><img src="http://note.youdao.com/yws/res/33561/WEBRESOURCEa6889b3faea43f6066a42a29a245af85" alt="image"></p>
<h3 id="CSS-DOM"><a href="#CSS-DOM" class="headerlink" title="CSS-DOM"></a>CSS-DOM</h3><p><img src="http://note.youdao.com/yws/res/33564/WEBRESOURCEbd8c0e5a02db7233ec80303bd24bf19a" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$(&quot;input:eq(3)&quot;).click(function()&#123;</div><div class="line">	  alert( $(&quot;p&quot;).height() );//带px</div><div class="line">&#125;);</div><div class="line">alert(  $(&quot;p&quot;).css(&quot;height&quot;) );//不带px</div></pre></td></tr></table></figure>
<h3 id="视窗"><a href="#视窗" class="headerlink" title="视窗"></a>视窗</h3><p>offset()——获取元素在当前视窗的相对偏移。</p>
<p>scrollTop()——获取元素的滚动条距离顶端的距离。</p>
<p>解决mouseover时出现自带的title属性，这里在移出时再给它加上title是因为防止下次移入时title为空。<br>增加10px和20px距离，不会遮挡文字。<br>增加mousemove鼠标在移动时依然显示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">$(function()&#123;</div><div class="line">    var x = 10;</div><div class="line">	var y = 20;</div><div class="line">	$(&quot;a.tooltip&quot;).mouseover(function(e)&#123;</div><div class="line">       	this.myTitle = this.title;</div><div class="line">		this.title = &quot;&quot;;	</div><div class="line">	    var tooltip = &quot;&lt;div id=&apos;tooltip&apos;&gt;&quot;+ this.myTitle +&quot;&lt;\/div&gt;&quot;; //创建 div 元素</div><div class="line">		$(&quot;body&quot;).append(tooltip);	//把它追加到文档中</div><div class="line">		$(&quot;#tooltip&quot;)</div><div class="line">			.css(&#123;</div><div class="line">				&quot;top&quot;: (e.pageY+y) + &quot;px&quot;,</div><div class="line">				&quot;left&quot;: (e.pageX+x)  + &quot;px&quot;</div><div class="line">			&#125;).show(&quot;fast&quot;);	  //设置x坐标和y坐标，并且显示</div><div class="line">    &#125;).mouseout(function()&#123;		</div><div class="line">		this.title = this.myTitle;</div><div class="line">		$(&quot;#tooltip&quot;).remove();   //移除 </div><div class="line">    &#125;).mousemove(function(e)&#123;</div><div class="line">		$(&quot;#tooltip&quot;)</div><div class="line">			.css(&#123;</div><div class="line">				&quot;top&quot;: (e.pageY+y) + &quot;px&quot;,</div><div class="line">				&quot;left&quot;: (e.pageX+x)  + &quot;px&quot;</div><div class="line">			&#125;);</div><div class="line">	&#125;);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>从一个title显示可以改进为</p>
<h4 id="图片提示效果"><a href="#图片提示效果" class="headerlink" title="图片提示效果"></a>图片提示效果</h4><p>要点：给放大的图片容器设定样式<br>display:none;<br>position:absolute;<br>left和right为鼠标点击的位置。<br>利用show()来做动画播放<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">$(function()&#123;</div><div class="line">	var x = 10;</div><div class="line">	var y = 20;</div><div class="line">	$(&quot;a.tooltip&quot;).mouseover(function(e)&#123;</div><div class="line">		this.myTitle = this.title;</div><div class="line">		this.title = &quot;&quot;;	</div><div class="line">		var imgTitle = this.myTitle? &quot;&lt;br/&gt;&quot; + this.myTitle : &quot;&quot;;</div><div class="line">		var tooltip = &quot;&lt;div id=&apos;tooltip&apos;&gt;&lt;img src=&apos;&quot;+ this.href +&quot;&apos; alt=&apos;产品预览图&apos;/&gt;&quot;+imgTitle+&quot;&lt;\/div&gt;&quot;; //创建 div 元素</div><div class="line">		$(&quot;body&quot;).append(tooltip);	//把它追加到文档中						 </div><div class="line">		$(&quot;#tooltip&quot;)</div><div class="line">			.css(&#123;</div><div class="line">				&quot;top&quot;: (e.pageY+y) + &quot;px&quot;,</div><div class="line">				&quot;left&quot;:  (e.pageX+x)  + &quot;px&quot;</div><div class="line">			&#125;).show(&quot;fast&quot;);	  //设置x坐标和y坐标，并且显示</div><div class="line">    &#125;).mouseout(function()&#123;</div><div class="line">		this.title = this.myTitle;	</div><div class="line">		$(&quot;#tooltip&quot;).remove();	 //移除 </div><div class="line">    &#125;).mousemove(function(e)&#123;</div><div class="line">		$(&quot;#tooltip&quot;)</div><div class="line">			.css(&#123;</div><div class="line">				&quot;top&quot;: (e.pageY+y) + &quot;px&quot;,</div><div class="line">				&quot;left&quot;:  (e.pageX+x)  + &quot;px&quot;</div><div class="line">			&#125;);</div><div class="line">	&#125;);</div><div class="line">&#125;)</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[《锋利的jQuery二》第二章读书笔记]]></title>
      <url>https://zaynex.github.io/2016/08/08/%E3%80%8A%E9%94%8B%E5%88%A9%E7%9A%84jQuery%E4%BA%8C%E3%80%8B%E7%AC%AC%E4%BA%8C%E7%AB%A0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h2 id="JQ处理预留机制"><a href="#JQ处理预留机制" class="headerlink" title="JQ处理预留机制"></a>JQ处理预留机制</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">document.getElementById(&quot;tt&quot;).style.color=&quot;red&quot;;</div></pre></td></tr></table></figure>
<p>如果没有id为tt的元素，那么浏览器会报错。<br>在DOM中需要加一个判断：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if(document.getElementById(&quot;tt&quot;))&#123;</div><div class="line">    document.getElementById(&quot;tt&quot;).style.color=&quot;red&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>在JQ中有更简单的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(&apos;#tt&apos;).css(&quot;color&quot;,&quot;red&quot;);</div></pre></td></tr></table></figure></p>
<p>这样就可以避免浏览器报错。<br>有了这个防御措施，即使以前的id为tt的元素用过后被删除了，也不会报错。</p>
<p>但要主要的是，$(“#tt”)获取的是对象，即使页面上没有这个元素。因此在判断页面中是否存在该元素时，不能直接用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">if($(&quot;#tt&quot;))&#123;//&#125;</div></pre></td></tr></table></figure></p>
<p>而应该根据获取元素的长度来判断<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if($(&quot;#tt&quot;).length &gt; 0) &#123;</div><div class="line">    //</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>或者转化成DOM对象来判断<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">if($(&quot;#tt&quot;)[0])&#123;</div><div class="line">//&#125;</div></pre></td></tr></table></figure></p>
<h2 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h2><h3 id="层级选择器"><a href="#层级选择器" class="headerlink" title="层级选择器"></a>层级选择器</h3><h4 id="next方法"><a href="#next方法" class="headerlink" title="next方法"></a>next方法</h4><p>$(“prev + next”).css(“”);<br>$(“prev”).next(“next”).css(“”);<br>取得prev元素的下一个next同辈元素</p>
<h4 id="nextAll方法"><a href="#nextAll方法" class="headerlink" title="nextAll方法"></a>nextAll方法</h4><p>$(“prev ~ sibilings”).css(“”);<br>$(“prev”).nextAll(“sibiling”);<br>取得prev元素之后的所有next同辈元素</p>
<h4 id="siblings方法"><a href="#siblings方法" class="headerlink" title="siblings方法"></a>siblings方法</h4><p>$(“prev”).siblings(“sibiling”);</p>
<h3 id="基本过滤选择器"><a href="#基本过滤选择器" class="headerlink" title="基本过滤选择器"></a>基本过滤选择器</h3><p><img src="http://note.youdao.com/yws/res/33390/WEBRESOURCE37a2b0ed0e79c62307bb36eeb1c3e630" alt="image"></p>
<h3 id="内容过滤选择器"><a href="#内容过滤选择器" class="headerlink" title="内容过滤选择器"></a>内容过滤选择器</h3><p><img src="http://note.youdao.com/yws/res/33395/WEBRESOURCE2dec19e7d8a9469464c78d97c4c6ad49" alt="image"></p>
<h3 id="可见性过滤选择器"><a href="#可见性过滤选择器" class="headerlink" title="可见性过滤选择器"></a>可见性过滤选择器</h3><p><img src="http://note.youdao.com/yws/res/33400/WEBRESOURCE931f54588fcdb43685759afca4fd4982" alt="image"></p>
<h3 id="属性过滤选择器"><a href="#属性过滤选择器" class="headerlink" title="属性过滤选择器"></a>属性过滤选择器</h3><p><img src="http://note.youdao.com/yws/res/33402/WEBRESOURCEaec33a45fdf43fbd76a59b52a69b7179" alt="image"></p>
<h3 id="子元素过滤器"><a href="#子元素过滤器" class="headerlink" title="子元素过滤器"></a>子元素过滤器</h3><p><img src="http://note.youdao.com/yws/res/33406/WEBRESOURCEf991564efc90239ea028d4b1e2aedb11" alt="image"><br><img src="http://note.youdao.com/yws/res/33408/WEBRESOURCE8c7f65b8064926fa34f3dee6cd48fe64" alt="image"></p>
<p>eq(index)中的index是从0开始，nth:child(index)是从1开始。</p>
<h3 id="表单选择器"><a href="#表单选择器" class="headerlink" title="表单选择器"></a>表单选择器</h3><p><img src="http://note.youdao.com/yws/res/33418/WEBRESOURCEa55fe47aa55ab637faa5499301834dc0" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;select name=&quot;test2&quot; multiple=&quot;multiple&quot;&gt;</div><div class="line">    &lt;option&gt;浙江&lt;/option&gt;</div><div class="line">    &lt;option&gt;湖南&lt;/option&gt;</div><div class="line">    &lt;option selected=&quot;selected&quot;&gt;北京&lt;/option&gt;</div><div class="line">    &lt;option&gt;天津&lt;/option&gt;</div><div class="line">    &lt;option&gt;广州&lt;/option&gt;</div><div class="line">    &lt;option&gt;湖北&lt;/option&gt;</div><div class="line">    &lt;/select&gt;</div><div class="line">/*</div><div class="line">mulitple = &quot;meltiple&quot; 可以让下拉列表显示多个选项</div><div class="line">*/</div></pre></td></tr></table></figure>
<h3 id="选择器注意事项"><a href="#选择器注意事项" class="headerlink" title="选择器注意事项"></a>选择器注意事项</h3><h4 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">$(function()&#123;</div><div class="line">	var $id_a  = $(&apos;#id.a&apos;);//jQuery对象</div><div class="line">	var $id_b  = $(&apos;#id#b&apos;);//jQuery对象</div><div class="line">	var $id_c =  $(&apos;#id[1]&apos;); 	//jQuery对象</div><div class="line"></div><div class="line">	var $id_right_a  = $(&apos;#id\\.a&apos;);//jQuery对象,对特殊字符,我们转义一下</div><div class="line">	var $id_right_b  = $(&apos;#id\\#b&apos;);//jQuery对象,对特殊字符,我们转义一下</div><div class="line">	var $id_right_c  = $(&apos;#id\\[1\\]&apos;); 			//对特殊字符，我们转义一下</div><div class="line"></div><div class="line">	$(&quot;&lt;div&gt;结果输出：&lt;br/&gt;值1:&quot;+$id_a.html()+&quot;&lt;br/&gt;值2:&quot;+$id_b.html()+&quot;&lt;br/&gt;值3:&quot;+$id_c.html()+</div><div class="line"></div><div class="line">	&quot;&lt;br/&gt;值4:&quot;+$id_right_a.html()+&quot;&lt;br/&gt;值5:&quot;+$id_right_b.html()+&quot;&lt;br/&gt;值6:&quot;+$id_right_c.html()+&quot;&lt;br/&gt;&lt;/div&gt;&quot;).appendTo(&quot;body&quot;);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p><img src="http://note.youdao.com/yws/res/33430/WEBRESOURCEed517bd1b46c94b8f766d5cf8aa4f6a6" alt="image"></p>
<h4 id="选择器内空格"><a href="#选择器内空格" class="headerlink" title="选择器内空格"></a>选择器内空格</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;test&quot;&gt;</div><div class="line">	   &lt;div style=&quot;display:none;&quot;&gt;aa&lt;/div&gt;</div><div class="line">	   &lt;div style=&quot;display:none;&quot;&gt;bb&lt;/div&gt;</div><div class="line">	   &lt;div style=&quot;display:none;&quot;&gt;cc&lt;/div&gt;</div><div class="line">	   &lt;div class=&quot;test&quot; style=&quot;display:none;&quot;&gt;dd&lt;/div&gt;</div><div class="line">	   &lt;div class=&quot;test&quot; style=&quot;display:none;&quot;&gt;dd&lt;/div&gt;</div><div class="line">	&lt;/div&gt;</div><div class="line">	&lt;div class=&quot;test&quot; style=&quot;display:none;&quot;&gt;ee&lt;/div&gt;</div><div class="line">	&lt;div class=&quot;test&quot; style=&quot;display:none;&quot;&gt;ff&lt;/div&gt;</div><div class="line">	</div><div class="line">$(function()&#123;</div><div class="line">  //注意区分类似这样的选择器</div><div class="line">  //虽然一个空格，却截然不同的效果.</div><div class="line">   var $t_a = $(&apos;.test :hidden&apos;);</div><div class="line">   var $t_b = $(&apos;.test:hidden&apos;);</div><div class="line">   var len_a = $t_a.length;</div><div class="line">   var len_b = $t_b.length;</div><div class="line">   $(&quot;&lt;p&gt;$(&apos;.test :hidden&apos;)的长度为&quot;+len_a+&quot;&lt;/p&gt;&quot;).appendTo(&quot;body&quot;);</div><div class="line">   $(&quot;&lt;p&gt;$(&apos;.test:hidden&apos;)的长度为&quot;+len_b+&quot;&lt;/p&gt;&quot;).appendTo(&quot;body&quot;);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p><img src="http://note.youdao.com/yws/res/33439/WEBRESOURCE51c4ef7467be99f31a3d04ff2ed7c03b" alt="image"></p>
<p>两者虽然差了一个空格，但原因是一个是后代选择器，还有一个是普通的过滤器。</p>
<h4 id="取消a标签的超链接"><a href="#取消a标签的超链接" class="headerlink" title="取消a标签的超链接"></a>取消a标签的超链接</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$toggleBtn.click(function()&#123;</div><div class="line">	$category.show();                   		 //  显示$category</div><div class="line">	</div><div class="line">	return false;					      	//超链接不跳转</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[《锋利的jQuery二》第一章读书笔记]]></title>
      <url>https://zaynex.github.io/2016/08/08/%E3%80%8A%E9%94%8B%E5%88%A9%E7%9A%84jQuery%E4%BA%8C%E3%80%8B%E7%AC%AC%E4%B8%80%E7%AB%A0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p><img src="http://note.youdao.com/yws/res/33300/WEBRESOURCEb10ebb06f73ecff138036011c409145c" alt="image"><br><a id="more"></a><br>JQuery获取的对象不能使用任何DOM的对象方法，DOM也不能使用jQuery里的任何方法。</p>
<p>JQuery对象转化成DOM对象</p>
<ol>
<li><p>因为JQ是一个类数组对象，可以通过index来获取</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var $cr = $(&quot;#cr&quot;);</div><div class="line">var cr = $cr[0];</div></pre></td></tr></table></figure>
</li>
<li><p>使用jQ的get方法 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var $cr = $(&quot;#cr&quot;);</div><div class="line">var cr = $cr.get(0);</div></pre></td></tr></table></figure>
</li>
</ol>
<p>DOM转化成jQuery<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var cr = document.getElementById(&quot;cr&quot;);</div><div class="line">var $cr = $(cr);</div></pre></td></tr></table></figure></p>
<p>解决JQ与其他的库的冲突</p>
<p>如果JQ在后加载，避免$()函数冲突可以使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">JQuery.noConflict();</div><div class="line">jQuery(function()&#123;</div><div class="line">	jQuery(&quot;p&quot;).click(function() &#123;</div><div class="line">		alert(jQuery(this).text());</div><div class="line">	&#125;);</div><div class="line">&#125;)</div><div class="line">$(&quot;pp&quot;).style.display = &apos;none&apos;; //使用prototype.js隐藏元素</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JS变量作用域解析方式]]></title>
      <url>https://zaynex.github.io/2016/08/06/JS%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F%E8%A7%A3%E6%9E%90%E6%96%B9%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h2 id="变量作用域解析方式"><a href="#变量作用域解析方式" class="headerlink" title="变量作用域解析方式"></a>变量作用域解析方式</h2><ol>
<li>静态作用域</li>
<li>动态作用域<h3 id="静态作用域"><a href="#静态作用域" class="headerlink" title="静态作用域"></a>静态作用域</h3></li>
</ol>
<ul>
<li>又称词法作用域</li>
<li>由程序定义的位置决定<a id="more"></a>
<img src="http://note.youdao.com/yws/res/33194/WEBRESOURCEebc4c4a7ef4355303cacdcb4298108f0" alt="image"><h3 id="JS变量作用域"><a href="#JS变量作用域" class="headerlink" title="JS变量作用域"></a>JS变量作用域</h3></li>
<li>使用静态作用域</li>
<li>JS没有块级作用域，分全局作用域和函数作用域</li>
<li>ES5中使用<strong>词法环境</strong>管理静态作用域<h3 id="词法环境"><a href="#词法环境" class="headerlink" title="词法环境"></a>词法环境</h3>词法环境是描述环境的一个对象包括两部分：<br>1.环境记录<br>2.对外部词法环境的引用<h4 id="环境记录"><a href="#环境记录" class="headerlink" title="环境记录"></a>环境记录</h4></li>
<li>形参</li>
<li>函数声明</li>
<li>变量<h4 id="对外部词法环境的引用"><a href="#对外部词法环境的引用" class="headerlink" title="对外部词法环境的引用"></a>对外部词法环境的引用</h4><img src="http://note.youdao.com/yws/res/33214/WEBRESOURCE43bd68bbf6509904a305bb071c135853" alt="image"><br>全局环境的outer引用为null。<br>从内开始向外引用。所以为什么外部定义的函数能被内部访问到，而内部定义的函数外部却无法访问的原因就是如此。<h3 id="环境记录初始化——声明提前"><a href="#环境记录初始化——声明提前" class="headerlink" title="环境记录初始化——声明提前"></a>环境记录初始化——声明提前</h3><h4 id="声明提前"><a href="#声明提前" class="headerlink" title="声明提前"></a>声明提前</h4>指当局代码或函数代码执行前，它要先扫描函数里面的内容，将函数里面的<strong> 形参、函数声明、变量 </strong> 先定义到环境记录里。<br><img src="http://note.youdao.com/yws/res/33216/WEBRESOURCEbaf62cb95a1a95faa1bc02997411b6dc" alt="image"><br>在代码执行前，值都为undefined。<h4 id="词法环境例子"><a href="#词法环境例子" class="headerlink" title="词法环境例子"></a>词法环境例子</h4>1.全局环境初始化<br><img src="http://note.youdao.com/yws/res/33220/WEBRESOURCE3de3ca152ef5670e31b193779adfc1f3" alt="image"><br>代码执行前都是undefined。<br>2.执行var x = 10<br><img src="http://note.youdao.com/yws/res/33222/WEBRESOURCEb5e9765e45acf58407ca0fca1a84e622" alt="image"><br>3.执行到var bar = foo(20) 局部环境初始化<br><img src="http://note.youdao.com/yws/res/33226/WEBRESOURCE22997c871a2f99f85674fb8ef2c0be02" alt="image"><br>4.执行局部环境 var z = 10<br><img src="http://note.youdao.com/yws/res/33228/WEBRESOURCE8265afd728a3137423021f4bb7a258e5" alt="image"><br>5.执行到bar(40) 局部环境初始化<br><img src="http://note.youdao.com/yws/res/33230/WEBRESOURCE9d674d9e965050cad827e020f5032d68" alt="image"><br>q是形参，已被读取。<br>6.获得所有参数执行函数<br><img src="http://note.youdao.com/yws/res/33233/WEBRESOURCE44884a75573f46f24298f4e92c437dfd" alt="image"></li>
</ul>
<h3 id="词法环境-with"><a href="#词法环境-with" class="headerlink" title="词法环境-with"></a>词法环境-with</h3><p>1.<br><img src="http://note.youdao.com/yws/res/33237/WEBRESOURCE74b30c197fb891f37e40968d121d1c6d" alt="image"><br>2.<br><img src="http://note.youdao.com/yws/res/33239/WEBRESOURCEbf5117571bb64904df101326f4c59a9a" alt="image"><br>3.<br><img src="http://note.youdao.com/yws/res/33242/WEBRESOURCEfb4dd41010959e9be8ae4d65c5e30993" alt="image"><br>f()函数定义在全局环境，所以就在全局环境，函数表达式是在执行才知道结果</p>
<h3 id="try-catch"><a href="#try-catch" class="headerlink" title="try-catch"></a>try-catch</h3><p><img src="http://note.youdao.com/yws/res/33248/WEBRESOURCE4e79d8ba3ce2dca7dd90ce6566b0586f" alt="image"></p>
<h3 id="JS作用域-带名称的函数表达式"><a href="#JS作用域-带名称的函数表达式" class="headerlink" title="JS作用域-带名称的函数表达式"></a>JS作用域-带名称的函数表达式</h3><p><img src="http://note.youdao.com/yws/res/33250/WEBRESOURCE9e6f5e772d308f770f8b6ca35d40bab5" alt="image"></p>
<h3 id="函数表达式和函数声明区别"><a href="#函数表达式和函数声明区别" class="headerlink" title="函数表达式和函数声明区别"></a>函数表达式和函数声明区别</h3><p>主要区别在于是否提前初始化<br>函数声明</p>
<ul>
<li>函数在执行前被初始化，和调用顺序无关</li>
</ul>
<p>函数表达式</p>
<ul>
<li>只有执行到该定义时，函数才被初始化，和调用顺序无关，在with 和 try catch 语句内，作用域可能被改变。</li>
</ul>
<h3 id="函数声明特点"><a href="#函数声明特点" class="headerlink" title="函数声明特点"></a>函数声明特点</h3><ol>
<li>hoisting特性：函数声明本身会被在其outer词法环境中声明提前，也就是说在outer词法环境中可以先调用，后声明</li>
<li>在js引擎“预编译”时，就将创建，其变量作用域只和函数声明的位置有关，而和运行时的状态无关，也就是说在with/catch结构中，其作用域也是外层作用域，而不是with/catch临时创建的作用域</li>
</ol>
<h3 id="函数表达式特点"><a href="#函数表达式特点" class="headerlink" title="函数表达式特点"></a>函数表达式特点</h3><ol>
<li>函数表达式在预编译阶段并不会被创建，只有在运行到这个函数表达式所在语句时才会被创建</li>
<li>作用域和运行时状态有关，比如with,try/catch的结构中定义的函数表达式，其运行时由于with/catch中临时生成了一个词法环境，所以函数表达式产生的函数的词法作用域的outer就是指向了with/catch</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JavaSript高级程序设计三第六章学习笔记二]]></title>
      <url>https://zaynex.github.io/2016/08/04/JavaSript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%89%E7%AC%AC%E5%85%AD%E7%AB%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E7%BB%A7%E6%89%BF/</url>
      <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>大部分OO语言都有接口继承和实现继承。 接口继承指继承函数方法签名，实现继承指继承实际的方法，由于JS中函数没有签名，因此ECMAScript中无法实现接口继承。ECMAScript只支持实现继承，并且实现继承主要依靠原型链来实现。<br><a id="more"></a></p>
<h3 id="构造函数原型实例关系"><a href="#构造函数原型实例关系" class="headerlink" title="构造函数原型实例关系"></a>构造函数原型实例关系</h3><p>每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例包含指向一个原型对象的内部指针。<br>如果让原型对象等于另一个类型的实例，那么此时原型对象将包含一个指向另一个原型的指针，另一个原型对象中也包含一个指向另一个构造函数的指针。<br>如果让另一个原型对象又等于另一个类型的实例，那么上述关系依然成立。</p>
<h3 id="实现原型链基本模式"><a href="#实现原型链基本模式" class="headerlink" title="实现原型链基本模式"></a>实现原型链基本模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">function SuperType()&#123;</div><div class="line">  this.prototype = true;</div><div class="line">&#125;</div><div class="line"></div><div class="line">SuperType.prototype.getSuperValue = function()&#123;</div><div class="line">  return this.prototype;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function SubType() &#123;</div><div class="line">  this.subproperty = false;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">SubType.prototype = new SuperType(); //subType 继承了 SuperType</div><div class="line"></div><div class="line">SubType.prototype.getSuperValue = function() &#123;</div><div class="line">  return this.subproperty;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var instance = new SubType();</div><div class="line">alert(instance.getSuperValue());//false;</div></pre></td></tr></table></figure>
<p>本质是重写原型对象，代之以一个新类型的实例。<br>原来存在于SuperType的实例的所有属性和方法， 现在也存在于 SubType.prototype中<br>注意的是 property 现在位于 SubType.prototype 中了。因为 property 是一个实例属性，而 getSuperValue()则是一个原型方法，<br>既然 SubType.prototype 现在是 SuperType.prototype 的实例， 那么property 当然就位于该实例中。<br>此外要注意的是 instance.constructor 现在指向的是 SuperType ,这是因为原来 SubType.prototype 中的 constructor 被重写的缘故。（实际上，不是被重写，而是 SubType 的原型指向了另一个对象 SuperType 的原型，所以原型对象的 constructor指向了 SuperType）</p>
<h3 id="当读取模式访问一个实例属性"><a href="#当读取模式访问一个实例属性" class="headerlink" title="当读取模式访问一个实例属性"></a>当读取模式访问一个实例属性</h3><p>搜索过程为<br>   1.搜索实例<br>   2.搜索SubType.prototype;<br>   3.搜索 SuperType.prototype</p>
<h3 id="默认原型"><a href="#默认原型" class="headerlink" title="默认原型"></a>默认原型</h3><p>所有原型都是Object的实例。</p>
<h3 id="原型和实例的关系"><a href="#原型和实例的关系" class="headerlink" title="原型和实例的关系"></a>原型和实例的关系</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">instance instanceof Object; // true</div><div class="line">instance instanceof SuperType;// true</div><div class="line">instance instanceof SubType; // true</div></pre></td></tr></table></figure>
<p>因为原型链的关系，instance 可以说是这3个任何一个类型的实例。<br>第二种方法是使用 isPrototypeOf();</p>
<h3 id="谨慎定义方法"><a href="#谨慎定义方法" class="headerlink" title="谨慎定义方法"></a>谨慎定义方法</h3><p>给原型添加方法的代码一定要放在替换原型的语句之后。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">function SuperType()&#123;</div><div class="line">  this.prototype = true;</div><div class="line">&#125;</div><div class="line"></div><div class="line">SuperType.prototype.getSuperValue = function()&#123;</div><div class="line">  return this.prototype;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function SubType() &#123;</div><div class="line">  this.subproperty = false;</div><div class="line">&#125;</div><div class="line"></div><div class="line">SubType.prototype = new SuperType(); //subType 继承了 SuperType</div><div class="line"></div><div class="line">SubType.prototype.getSuperValue = function() &#123;</div><div class="line">  return false;</div><div class="line">&#125;;</div><div class="line">SubType.prototype.getSubValue = function() &#123;</div><div class="line">  return this.subproperty;</div><div class="line">&#125;; </div><div class="line"></div><div class="line">var instance = new SubType();</div><div class="line">var instance2 = new SuperType();</div><div class="line">alert(instance.getSuperValue()); // fasle</div><div class="line">alert(instance2.getSuperValue()); // true</div></pre></td></tr></table></figure></p>
<p>在通过原型链实现继承时，不能使用对象字面量创建原型方法。否则会重写原型链。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">function SuperType()&#123;</div><div class="line">  this.prototype = true;</div><div class="line">&#125;</div><div class="line"></div><div class="line">SuperType.prototype.getSuperValue = function()&#123;</div><div class="line">  return this.prototype;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function SubType() &#123;</div><div class="line">  this.subproperty = false;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">SubType.prototype = new SuperType(); //subType 继承了 SuperType</div><div class="line"></div><div class="line">SubType.prototype = &#123;</div><div class="line">  getSubValue : function()&#123;</div><div class="line">    return this.subproperty;</div><div class="line">&#125;,</div><div class="line"></div><div class="line">  someOtherMethod : function()&#123;</div><div class="line">    return false;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var instance = new SubType();</div><div class="line">alert(instance.getSuperValue());  // Error</div></pre></td></tr></table></figure></p>
<p>现在的原型新创建了一个对象，包含的是Object的原型，而非SuperType 的实例。</p>
<h3 id="原型链的问题"><a href="#原型链的问题" class="headerlink" title="原型链的问题"></a>原型链的问题</h3><p>原型链的问题是引用类型值的原型属性会被所有实例所共享，这也是为什么要在构造函数中，而不是在原型对象中定义属性的原因。<br>第二个问题，在创建子类型的实例时，不能向超类型的构造函数中传递参数。</p>
<h2 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function SuperType()&#123;</div><div class="line">  this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">function SubType () &#123;</div><div class="line">  SuperType.call(this);</div><div class="line">&#125;</div><div class="line"></div><div class="line">var instance1 = new SubType();</div><div class="line">instance1.colors.push(&quot;yellow&quot;);  // red,blue,green,yellow</div><div class="line">alert(instance1.colors);</div><div class="line"></div><div class="line">var instance2  = new SuperType();  // red,blue,green</div><div class="line">alert(instance2.colors);</div></pre></td></tr></table></figure>
<p>通过call()方法，实际上是在（未来将要）新创建的SubType实例的环境下调用SuperType构造函数。这样一来，就会在新SubType对象上执行SuperType()函数中定义的所有对象初始化代码。</p>
<h3 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">function SuperType(name) &#123;</div><div class="line">  this.name = name;</div><div class="line">  this.age = &quot;26&quot;;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function SubType() &#123;</div><div class="line">  SuperType.call(this, &quot;Nicholas&quot;);</div><div class="line">  this.age = 29;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">var instance = new SubType();</div><div class="line">var instance2 = new SuperType();</div><div class="line">alert(instance.name); // Nicholas</div><div class="line">alert(instance.age); // 29</div><div class="line">alert(instance2.age);  // 26</div></pre></td></tr></table></figure>
<h3 id="借用构造函数的问题"><a href="#借用构造函数的问题" class="headerlink" title="借用构造函数的问题"></a>借用构造函数的问题</h3><p>如果仅仅是借用构造函数，那么将无法避免构造函数模式的问题——方法都在构造函数中定义，因此函数复用将无从谈起。而且在超类型的原型中定义的方法，对子类型而言依然是不可见的。结果所有类型都只能用构造函数模式。</p>
<h2 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">function SuperType(name) &#123;</div><div class="line">  this.name = name;</div><div class="line">  this.colors = [&quot;red&quot;,&apos;blue&apos;, &quot;green&quot;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">SuperType.prototype.sayName = function()&#123;</div><div class="line">  alert(this.name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">function SubType(name, age)  &#123;</div><div class="line">  SuperType.call(this, name);  //第二次调用</div><div class="line">  this.age = age;</div><div class="line">&#125;</div><div class="line"></div><div class="line">SubType.prototype = new SuperType();  //第一次调用</div><div class="line">SubType.prototype.constructor = SubType;</div><div class="line">SubType.prototype.sayAge = function  () &#123;</div><div class="line">  alert(this.age);</div><div class="line">&#125;</div><div class="line">var instance1 = new SubType(&quot;Nicholas&quot;, 29);</div><div class="line">instance1.colors.push(&quot;black&quot;);</div><div class="line">alert(instance1.colors);// red,blue,green,black</div><div class="line">instance1.sayName(); // Nicholas;</div><div class="line">instance1.sayAge(); //29</div><div class="line"></div><div class="line">var instance2 = new SubType(&quot;Greg&quot;, 28);</div><div class="line">alert(instance2.colors); // red,blue, green</div><div class="line">instance2.sayName();  // Greg</div><div class="line">instance2.sayAge(); // 28;</div></pre></td></tr></table></figure>
<p>第一次SuperType()构造函数调用时，SubType.prototype 会得到两个属性：name  和 colors;当调用SubType 构造函数时，又一次调用 SuperType构造函数，这一次又在新对象上创建了实例属性：name 和  colors，这两个属性屏蔽原型中两个同名属性。</p>
<h2 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h2><p>借助原型基于已有对象创建新对象，还不必创建自定义类型。<br>在object()内部，建立临时构造函数将传入的对象作为构造函数的原型。返回这个临时类型的新实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">function object(o) &#123;</div><div class="line">  function F()&#123;&#125;</div><div class="line">  F.prototype = o;</div><div class="line">  return new F();</div><div class="line">&#125;</div><div class="line">var person = &#123;</div><div class="line">  name : &quot;Nicholas&quot;,</div><div class="line">  friends : [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var anotherPerson = object(person);</div><div class="line">anotherPerson.name = &quot;Greg&quot;;</div><div class="line">anotherPerson.friends.push(&quot;Rob&quot;);</div><div class="line"></div><div class="line">var yetAnotherPerson = object(person);</div><div class="line">yetAnotherPerson.name = &quot;Linda&quot;;</div><div class="line">yetAnotherPerson.friends.push(&quot;Barbie&quot;);</div><div class="line"></div><div class="line">console.log(person.friends); // [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;, &quot;Rob&quot;, &quot;Barbie&quot;]</div><div class="line">console.log(yetAnotherPerson.friends); //[&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;, &quot;Rob&quot;, &quot;Barbie&quot;]</div></pre></td></tr></table></figure></p>
<p>实际上，这相当于创建了person对象的两个副本。</p>
<h3 id="原型继承Obejct-create"><a href="#原型继承Obejct-create" class="headerlink" title="原型继承Obejct.create()"></a>原型继承Obejct.create()</h3><p>ES5中新增 Object.create()方法规范化原型式继承<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">var person = &#123;</div><div class="line">  name : &quot;Nicholas&quot;,</div><div class="line">  friends : [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]</div><div class="line">&#125;;</div><div class="line">var anotherPerson = Object.create(person);</div><div class="line">anotherPerson.name = &quot;Greg&quot;;</div><div class="line">anotherPerson.friends.push(&quot;Rob&quot;);</div><div class="line"></div><div class="line">var yetAnotherPerson = Object.create(person);</div><div class="line">yetAnotherPerson.name = &quot;Linda&quot;;</div><div class="line">yetAnotherPerson.friends.push(&quot;Barbie&quot;); //Shelby,Court, Van, Linda</div></pre></td></tr></table></figure></p>
<p>传递两个参数时，为新对象定义额外的属性或者覆盖原有的属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">var person = &#123;</div><div class="line">  name : &quot;Nicholas&quot;,</div><div class="line">  friends : [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]</div><div class="line">&#125;;</div><div class="line">var anotherPerson = Object.create(person, &#123;</div><div class="line">  name: &#123;</div><div class="line">    value: &quot;Greg&quot;</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line">console.log(anotherPerson.name); //Greg</div></pre></td></tr></table></figure></p>
<p>在没必要创建构造函数的情况，而只想让一个对象与另一个对象保持类似的情况下， 原型式继承是完全可以胜任的。</p>
<h4 id="使用环境"><a href="#使用环境" class="headerlink" title="使用环境"></a>使用环境</h4><p> IE9+ ，Firbox4+ ,Safrai5+,Opera12+ chrome;</p>
<h2 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h2><p>创建一个仅用于封装继承过程的函数，该函数在内部以某种方式增强对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">function object(o) &#123;</div><div class="line">  function F()&#123;&#125;</div><div class="line">  F.prototype = o;</div><div class="line">  return new F();</div><div class="line">&#125;</div><div class="line"></div><div class="line">function createAnother (original) &#123;</div><div class="line">  var clone = object(original);  //通过调用函数创建一个对象</div><div class="line">  clone.sayHi = function()&#123; //以某种方式增强这个对象</div><div class="line">    alert(&quot;Hi&quot;);</div><div class="line">  &#125;;</div><div class="line">  return clone;  //返回这个对象</div><div class="line">&#125;</div><div class="line"></div><div class="line"> var person = &#123;</div><div class="line">  name : &quot;Nicholas&quot;;</div><div class="line">  friends : [&quot;Shelby&quot;, &quot;Greg&quot;, &quot;Van&quot;];</div><div class="line">&#125;;</div><div class="line">var anotherPerson = createAnother(person);</div><div class="line">anotherPerson.sayHi();</div></pre></td></tr></table></figure>
<ul>
<li>使用寄生式继承来为对象添加函数，会由于不能做到函数复用而减低效率。</li>
</ul>
<h2 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h2><p>组合继承最大的问题就是无论在什么情况下，都会调用两次超类型构造函数，一次是在创建子类型原型的时候，一次是在子类型构造函数内部。子类型最终都会包含超类型的全部实例属性。</p>
<p>寄生组合式继承，借用构造函数来继承属性，通过原型链的混成形式来继承方法。</p>
<ul>
<li>不必为了指定子类型的原型而调用超类型的构造函数，我们所需要的无非就是超类型的一个副本而已。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function object(o) &#123;</div><div class="line">  function F()&#123;&#125;</div><div class="line">  F.prototype = o;</div><div class="line">  return new F();</div><div class="line">&#125;</div><div class="line">function inheritPrototype (subType, SuperType) &#123;   // (子类型，超类型)</div><div class="line">  var prototype = object(SuperType.prototype);</div><div class="line">  prototype.constructor = subType;</div><div class="line">  subType.prototype = prototype;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<ol>
<li>创建超类型的一个副本</li>
<li>为创建的副本添加constructor属性，从而弥补因此重写原型而失去的默认的 constructor 属性</li>
<li>为新创建的对象赋予子类型的原型</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">function SuperType(name) &#123;</div><div class="line">  this.name = name;</div><div class="line">  this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">SuperType.prototype.sayName = function()&#123;</div><div class="line">  alert(this.name);</div><div class="line">&#125;</div><div class="line">function SubType (name, age) &#123;</div><div class="line">  SuperType.call(this, name);</div><div class="line">  this.age = age;</div><div class="line">&#125;</div><div class="line"></div><div class="line">inheritPrototype(SubType, SuperType);</div><div class="line"></div><div class="line">SubType.prototype.sayAge = function()&#123;</div><div class="line">  alert(this.age);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>只调用一次SuperType函数，避免在SubType.prototype 上创建不必要的多余的属性，保持原型链不变。效率更高。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[淘宝双飞翼圣杯布局详解]]></title>
      <url>https://zaynex.github.io/2016/08/01/%E6%B7%98%E5%AE%9D%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>因为中间部分内容对用户来说是最要紧的，我们把中间的部分放到DOM结构前最先解析。<br><a id="more"></a></p>
<h2 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">&lt;style&gt;</div><div class="line">		*&#123;</div><div class="line">			padding: 0;margin: 0;</div><div class="line">		&#125;</div><div class="line">		#hd,#foot&#123;</div><div class="line">			width: 100%;background: #666;clear: both;height: 30px;</div><div class="line">		&#125;</div><div class="line">		.main,.sub,.extra&#123;</div><div class="line">			height: 300px;</div><div class="line">			float: left;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		.main&#123;</div><div class="line">			width: 100%;</div><div class="line">			background: red;</div><div class="line">		&#125;</div><div class="line">		.sub&#123;</div><div class="line">			width: 190px;</div><div class="line">			background: yellow;</div><div class="line">		&#125;</div><div class="line">		.extra&#123;</div><div class="line">			width: 190px;</div><div class="line">			background: pink;</div><div class="line">		&#125;</div><div class="line">&lt;/style&gt;</div><div class="line">&lt;body&gt;</div><div class="line">	&lt;div id=&quot;page&quot;&gt;</div><div class="line">		&lt;div id=&quot;hd&quot;&gt;我是头部&lt;/div&gt;</div><div class="line">		&lt;div id=&quot;bd&quot;&gt;</div><div class="line">			&lt;div class=&quot;main&quot;&gt;我是中间&lt;/div&gt;</div><div class="line">			&lt;div class=&quot;sub&quot;&gt;我是左边&lt;/div&gt;</div><div class="line">			&lt;div class=&quot;extra&quot;&gt;我是右边&lt;/div&gt;</div><div class="line">		&lt;/div&gt;</div><div class="line">		&lt;div id=&quot;foot&quot;&gt;我是底部&lt;/div&gt;</div><div class="line">	&lt;/div&gt;</div><div class="line">&lt;/body&gt;</div></pre></td></tr></table></figure>
<p><img src="http://note.youdao.com/yws/res/32095/WEBRESOURCEaf26b1d50d40bc30d6fe39ec8ea22b4d" alt="image"></p>
<p>然后利用margin负边距对浮动元素的影响。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">	&lt;style&gt;</div><div class="line">		*&#123;</div><div class="line">			padding: 0;margin: 0;</div><div class="line">		&#125;</div><div class="line">		#hd,#foot&#123;</div><div class="line">			width: 100%;background: #666;clear: both;height: 30px;</div><div class="line">		&#125;</div><div class="line">		.main,.sub,.extra&#123;</div><div class="line">			height: 300px;</div><div class="line">			float: left;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		.main&#123;</div><div class="line">			width: 100%;</div><div class="line">			background: red;</div><div class="line">		&#125;</div><div class="line">		.sub&#123;</div><div class="line">			width: 190px;</div><div class="line">			background: yellow;</div><div class="line">			margin-left: -100%;</div><div class="line">		&#125;</div><div class="line">		.extra&#123;</div><div class="line">			width: 190px;</div><div class="line">			background: pink;</div><div class="line">			margin-left: -190px;</div><div class="line">		&#125;</div><div class="line">	&lt;/style&gt;</div><div class="line">&lt;body&gt;</div><div class="line">	&lt;div id=&quot;page&quot;&gt;</div><div class="line">		&lt;div id=&quot;hd&quot;&gt;我是头部&lt;/div&gt;</div><div class="line">		&lt;div id=&quot;bd&quot;&gt;</div><div class="line">			&lt;div class=&quot;main&quot;&gt;我是中间&lt;/div&gt;</div><div class="line">			&lt;div class=&quot;sub&quot;&gt;我是左边&lt;/div&gt;</div><div class="line">			&lt;div class=&quot;extra&quot;&gt;我是右边&lt;/div&gt;</div><div class="line">		&lt;/div&gt;</div><div class="line">		&lt;div id=&quot;foot&quot;&gt;我是底部&lt;/div&gt;</div><div class="line">	&lt;/div&gt;</div><div class="line">&lt;/body&gt;</div></pre></td></tr></table></figure>
<p><img src="http://note.youdao.com/yws/res/32100/WEBRESOURCEfa0fced82caa2ec88cad30c38f8b986d" alt="image"><br>但是中间内容被挡住了，中间的文字没了。<br>我们尝试加padding。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#bd&#123;</div><div class="line">			padding-left: 190px;</div><div class="line">			padding-right: 190px;</div><div class="line">		&#125;</div></pre></td></tr></table></figure>
<p><img src="http://note.youdao.com/yws/res/32106/WEBRESOURCE02bcec8010cd81758f71945e5758a82e" alt="image"><br>再把左边和右边的用相对定位把它移到两侧。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">.sub&#123;</div><div class="line">	position: relative;</div><div class="line">	left: -190px;	</div><div class="line">&#125;</div><div class="line">.extra&#123;</div><div class="line">	position: relative;</div><div class="line">	right: -190px;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://note.youdao.com/yws/res/32114/WEBRESOURCE9507ab72ba285b94c196f7b2fe53df29" alt="image"></p>
<p>我们就实现了圣杯布局<br>好处：</p>
<ul>
<li>main部分是自适应宽度的，很容易在定宽布局和流体布局中切换。</li>
<li>任何一栏都可以是最高栏，不会出问题。（为演示方便我给他们加了同一的高度）</li>
</ul>
<p>缺点：</p>
<ul>
<li>相对定位布局，对后续元素可能会有一定的影响。</li>
</ul>
<h2 id="双飞翼布局"><a href="#双飞翼布局" class="headerlink" title="双飞翼布局"></a>双飞翼布局</h2><p>针对圣杯布局的相对定位，双飞翼布局设定了子元素用margin值完美解决问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">&lt;style&gt;</div><div class="line">		*&#123;</div><div class="line">			padding: 0;margin: 0;</div><div class="line">		&#125;</div><div class="line">		.main,.sub,.extra&#123;</div><div class="line">			height: 300px;</div><div class="line">		&#125;</div><div class="line">		.main&#123;</div><div class="line">			float: left;</div><div class="line">			width: 100%;</div><div class="line">			background: red;</div><div class="line">		&#125;</div><div class="line">		.sub&#123;</div><div class="line">			float: left;</div><div class="line">			width: 120px;</div><div class="line">			padding: 20px;</div><div class="line">			margin-left: -100%;</div><div class="line">			background: yellow;</div><div class="line">		&#125;</div><div class="line">		.extra&#123;</div><div class="line">			width: 190px;</div><div class="line">			float: left;</div><div class="line">			margin-left: -190px</div><div class="line">			background: pink;</div><div class="line">		&#125;</div><div class="line">	&lt;/style&gt;</div><div class="line">	&lt;div id=&quot;page&quot;&gt;</div><div class="line">		&lt;div id=&quot;hd&quot;&gt;&lt;/div&gt;</div><div class="line">		&lt;div class=&quot;main&quot;&gt;我是中间的&lt;/div&gt;</div><div class="line">		&lt;div class=&quot;sub&quot;&gt;我是左边&lt;/div&gt;</div><div class="line">		&lt;div class=&quot;extra&quot;&gt;我是右边&lt;/div&gt;</div><div class="line">		&lt;div id=&quot;foot&quot;&gt;&lt;/div&gt;</div><div class="line">	&lt;/div&gt;</div></pre></td></tr></table></figure>
<p><img src="http://note.youdao.com/yws/res/32072/WEBRESOURCEb76a25a634afd48cc067b7870e445e4c" alt="image"><br>表面上看起来，我们完成了。<br>中间的宽度是100%的。两边的DIV只是叠在中间这个DIV的上面，所以图片中无法显示中间的文字。</p>
<p>以下是淘宝的做法</p>
<ol>
<li>给.main元素加一个子元素</li>
<li>利用子元素的margin值来调整</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">&lt;style&gt;</div><div class="line">		*&#123;</div><div class="line">			padding: 0;margin: 0;</div><div class="line">		&#125;</div><div class="line">		.main,.sub,.extra&#123;</div><div class="line">			height: 300px;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		.main&#123;</div><div class="line">			float: left;</div><div class="line">			width: 100%;</div><div class="line">			background: red;</div><div class="line">		&#125;</div><div class="line">		.sub&#123;</div><div class="line">			float: left;</div><div class="line">			width: 190px;</div><div class="line">			margin-left: -100%;</div><div class="line">			background: yellow;</div><div class="line">		&#125;</div><div class="line">		.extra&#123;</div><div class="line">			width: 190px;</div><div class="line">			float: left;</div><div class="line">			margin-left: -190px;</div><div class="line">			background: pink;</div><div class="line">		&#125;</div><div class="line">		.main-wrap&#123;</div><div class="line">			margin-left: 200px;</div><div class="line">			margin-right: 200px;</div><div class="line">			background: red;</div><div class="line">		&#125;</div><div class="line">	&lt;/style&gt;</div><div class="line">&lt;body&gt;</div><div class="line">	&lt;div id=&quot;page&quot;&gt;</div><div class="line">		&lt;div id=&quot;hd&quot;&gt;&lt;/div&gt;</div><div class="line">		&lt;div class=&quot;main&quot;&gt;</div><div class="line">			&lt;div class=&quot;main-wrap&quot;&gt;我是中间的&lt;/div&gt;</div><div class="line">		&lt;/div&gt;</div><div class="line">		&lt;div class=&quot;sub&quot;&gt;我是左边&lt;/div&gt;</div><div class="line">		&lt;div class=&quot;extra&quot;&gt;我是右边&lt;/div&gt;</div><div class="line">		&lt;div id=&quot;foot&quot;&gt;&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">&lt;/body&gt;</div></pre></td></tr></table></figure>
<p><img src="http://note.youdao.com/yws/res/32080/WEBRESOURCE092dc75c9ac2b36fd2e453b259289702" alt="image"></p>
<p>同时，我们也可以注意到<br><img src="http://note.youdao.com/yws/res/32082/WEBRESOURCE1b12e3ccff498696713c1bdbecffc94b" alt="image"></p>
<p>margin-left: 200px;<br>margin-right:200px;<br>针对左右两边多设定了10PX的margin。</p>
<p>** 最终，我们实现的就是左右190px，中间自动收缩并且相距10px的三行布局。</p>
<p>好处：</p>
<ul>
<li>重要的内容先加载</li>
<li>兼容IE6</li>
<li>只需调整CSS属性。</li>
</ul>
<p>需要注意的地方：</p>
<ul>
<li>中间的元素设置100%，然后子元素设定margin。</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Flex布局2]]></title>
      <url>https://zaynex.github.io/2016/08/01/flex%E5%B8%83%E5%B1%802/</url>
      <content type="html"><![CDATA[<p>一张麻将牌筒子最多有9个点。<br><img src="https://davidwalsh.name/demo/flexbox-dice.png" alt="image"><br><a id="more"></a><br>图为1,2,3,4筒</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;div class=&quot;first-face&quot;&gt;</div><div class="line">	&lt;span class=&quot;pip&quot;&gt;&lt;/span&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<p>上面代码中，div元素（代表筒子的一个面）是Flex容器，span元素（代表一个点）是Flex项目。如果有多个项目，就要添加多个span元素，以此类推。</p>
<h3 id="单项目"><a href="#单项目" class="headerlink" title="单项目"></a>单项目</h3><p>首先，只有左上角1个点的情况。Flex布局默认就是首行左对齐，所以一行代码就够了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.first-face&#123;</div><div class="line">  display: flex;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://note.youdao.com/yws/res/32995/WEBRESOURCE9456e7808c8c1dfa53c86d12a9b097e3" alt="image"><br><img src="https://davidwalsh.name/demo/dicey-flexbox-images/face-1-1-axes.png" alt="image"></p>
<p>设置项目的对齐方式，就能实现居中对齐和右对齐。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">.first-face&#123;</div><div class="line">  display: flex;</div><div class="line">  justify-content: center;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://note.youdao.com/yws/res/32999/WEBRESOURCE3eb87f15a18ba5b03039aead0aecab28" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">.first-face&#123;</div><div class="line">  display: flex;</div><div class="line">  justify-content: flex-end;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://note.youdao.com/yws/res/33003/WEBRESOURCEc1f038b075c3cb2436be1d4cc4a7b93d" alt="image"></p>
<p>设置交叉轴对齐方式，可以垂直移动主轴。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">.first-face&#123;</div><div class="line">  display: flex;</div><div class="line">  align-items: center;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://note.youdao.com/yws/res/33011/WEBRESOURCE079d49f8ff30a53db531cc28eca8393c" alt="image"></p>
<p>把两者结合在一起</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">.first-face&#123;</div><div class="line">  display: flex;</div><div class="line">  align-items: center;</div><div class="line">  justify-content: center;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://note.youdao.com/yws/res/33014/WEBRESOURCE685d6181c2bbb7e68c97aaa264b57749" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">.first-face&#123;</div><div class="line">  display: flex;</div><div class="line">  align-items: center;</div><div class="line">  justify-content: flex-end;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://note.youdao.com/yws/res/33019/WEBRESOURCE61b29677bc2e0b6f76227a4e21837183" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">.first-face&#123;</div><div class="line">  display: flex;</div><div class="line">  align-items: flex-end;</div><div class="line">  justify-content: center;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://note.youdao.com/yws/res/33021/WEBRESOURCE7060583391a431902b02f12dabd0d927" alt="image"></p>
<h3 id="双项目"><a href="#双项目" class="headerlink" title="双项目"></a>双项目</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">.first-face&#123;</div><div class="line">  display: flex;</div><div class="line">  justify-content: space-between;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://note.youdao.com/yws/res/33027/WEBRESOURCEb29946583d5a9a35775b14e045f942e3" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">.first-face&#123;</div><div class="line">  display: flex;</div><div class="line">  flex-direction: column;</div><div class="line">  justify-content: space-between;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://note.youdao.com/yws/res/33031/WEBRESOURCE6406666ceb308032197adf50e16e3e3e" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">.first-face&#123;</div><div class="line">  display: flex;</div><div class="line">  flex-direction: column;</div><div class="line">  justify-content: space-between;</div><div class="line">  align-items: center;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://note.youdao.com/yws/res/33037/WEBRESOURCEae56a7302cfee483d86d2e83ef82d03e" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">.first-face&#123;</div><div class="line">  display: flex;</div><div class="line">  flex-direction: column;</div><div class="line">  justify-content: space-between;</div><div class="line">  align-items: flex-end;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://note.youdao.com/yws/res/33040/WEBRESOURCE55f12297726fd16df76e149192e83481" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">.first-face&#123;</div><div class="line">  display: flex;</div><div class="line">&#125;</div><div class="line">.first-face .pip:nth-child(2)&#123;</div><div class="line">  align-self: center;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://note.youdao.com/yws/res/33045/WEBRESOURCEe99bf7dbcbe6589a48c354d772c1b6e5" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">.first-face&#123;</div><div class="line">  display: flex;</div><div class="line">  justify-content: space-between;</div><div class="line">&#125;</div><div class="line">.first-face .pip:nth-child(2)&#123;</div><div class="line">  align-self: flex-end;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://note.youdao.com/yws/res/33049/WEBRESOURCE9396f7b9c13273eb829c88a0ffe82365" alt="image"></p>
<h3 id="三项目"><a href="#三项目" class="headerlink" title="三项目"></a>三项目</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">.first-face&#123;</div><div class="line">  display: flex;</div><div class="line">&#125;</div><div class="line">.first-face .pip:nth-child(2)&#123;</div><div class="line">  align-self: center;</div><div class="line">&#125;</div><div class="line">.pip:nth-child(3)&#123;</div><div class="line">  align-self: flex-end;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://note.youdao.com/yws/res/33052/WEBRESOURCE9a974ece047d3171964315837e83f7cf" alt="image"></p>
<h3 id="四项目"><a href="#四项目" class="headerlink" title="四项目"></a>四项目</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">.first-face&#123;</div><div class="line">  display: flex;</div><div class="line">  flex-wrap: wrap;</div><div class="line">  justify-content: flex-end;</div><div class="line">  align-content: space-between;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://note.youdao.com/yws/res/33065/WEBRESOURCE3310d9683f9825c2dca660d573aae233" alt="image"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">.first-face&#123;</div><div class="line">  display: flex;</div><div class="line">  flex-wrap: wrap;</div><div class="line">  align-content: space-between;</div><div class="line">&#125;</div><div class="line">.column&#123;</div><div class="line">  flex-basis: 100%;</div><div class="line">  display: flex;</div><div class="line">  justify-content: space-between;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://note.youdao.com/yws/res/33059/WEBRESOURCE71053a2fc48e92ff8b01a8bca780ba44" alt="image"></p>
<h3 id="六项目"><a href="#六项目" class="headerlink" title="六项目"></a>六项目</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">.first-face&#123;</div><div class="line">  display: flex;</div><div class="line">  flex-wrap: wrap;</div><div class="line">  align-content: space-between;</div><div class="line">&#125;</div><div class="line">.column&#123;</div><div class="line">  flex-basis: 100%;</div><div class="line">  display: flex;</div><div class="line">  justify-content: space-between;</div><div class="line">&#125;</div><div class="line">	&lt;div class=&quot;first-face&quot;&gt;</div><div class="line">		&lt;div class=&quot;column&quot;&gt;</div><div class="line">			&lt;span class=&quot;pip&quot;&gt;&lt;/span&gt;</div><div class="line">			&lt;span class=&quot;pip&quot;&gt;&lt;/span&gt;			</div><div class="line">			&lt;span class=&quot;pip&quot;&gt;&lt;/span&gt;</div><div class="line">		&lt;/div&gt;</div><div class="line">		&lt;div class=&quot;column&quot;&gt;</div><div class="line">			&lt;span class=&quot;pip&quot;&gt;&lt;/span&gt;</div><div class="line">			&lt;span class=&quot;pip&quot;&gt;&lt;/span&gt;			</div><div class="line">			&lt;span class=&quot;pip&quot;&gt;&lt;/span&gt;</div><div class="line">		&lt;/div&gt;	</div><div class="line">    &lt;/div&gt;</div></pre></td></tr></table></figure>
<p>当然，其实也不需要那么复杂。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">.first-face&#123;</div><div class="line">  display: flex;</div><div class="line">  flex-wrap: wrap;</div><div class="line">  align-content: space-between;</div><div class="line">&#125;</div><div class="line">&lt;div class=&quot;first-face&quot;&gt;</div><div class="line">	&lt;span class=&quot;pip&quot;&gt;&lt;/span&gt;</div><div class="line">	&lt;span class=&quot;pip&quot;&gt;&lt;/span&gt;</div><div class="line">	&lt;span class=&quot;pip&quot;&gt;&lt;/span&gt;</div><div class="line">	&lt;span class=&quot;pip&quot;&gt;&lt;/span&gt;</div><div class="line">	&lt;span class=&quot;pip&quot;&gt;&lt;/span&gt;</div><div class="line">	&lt;span class=&quot;pip&quot;&gt;&lt;/span&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<p>我们再试试竖的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">.first-face&#123;</div><div class="line">  display: flex;</div><div class="line">  flex-wrap: wrap;</div><div class="line">  flex-direction: column;</div><div class="line">  align-content: space-between;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://note.youdao.com/yws/res/33075/WEBRESOURCEf35b7a27dd4b8c4eab2351774824f1b0" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">.first-face&#123;</div><div class="line">  display: flex;</div><div class="line">  flex-wrap: wrap;</div><div class="line">&#125;</div><div class="line">.row&#123;</div><div class="line">  display: flex;</div><div class="line">  flex-basis: 100%;</div><div class="line">&#125;</div><div class="line">.row:nth-child(2)&#123;</div><div class="line">  justify-center: center;</div><div class="line">&#125;</div><div class="line">.row:nth-child(3)&#123;</div><div class="line">  justify-center: space-between;</div><div class="line">&#125;</div><div class="line">&lt;div class=&quot;first-face&quot;&gt;</div><div class="line">	&lt;div class=&quot;row&quot;&gt;</div><div class="line">		&lt;span class=&quot;pip&quot;&gt;&lt;/span&gt;</div><div class="line">		&lt;span class=&quot;pip&quot;&gt;&lt;/span&gt;</div><div class="line">		&lt;span class=&quot;pip&quot;&gt;&lt;/span&gt;</div><div class="line">	&lt;/div&gt;</div><div class="line">	&lt;div class=&quot;row&quot;&gt;</div><div class="line">		&lt;span class=&quot;pip&quot;&gt;&lt;/span&gt;</div><div class="line">	&lt;/div&gt;</div><div class="line">	&lt;div class=&quot;row&quot;&gt;</div><div class="line">		&lt;span class=&quot;pip&quot;&gt;&lt;/span&gt;</div><div class="line">		&lt;span class=&quot;pip&quot;&gt;&lt;/span&gt;</div><div class="line">	&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<p><img src="http://note.youdao.com/yws/res/33082/WEBRESOURCE2f368b8fc05d6256fb2ed3446efe3ca7" alt="image"></p>
<h3 id="九筒"><a href="#九筒" class="headerlink" title="九筒"></a>九筒</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">.first-face&#123;</div><div class="line">  display: flex;</div><div class="line">  flex-wrap: wrap;</div><div class="line">&#125;</div><div class="line">&lt;div class=&quot;first-face&quot;&gt;</div><div class="line">	&lt;span class=&quot;pip&quot;&gt;&lt;/span&gt;</div><div class="line">	&lt;span class=&quot;pip&quot;&gt;&lt;/span&gt;</div><div class="line">	&lt;span class=&quot;pip&quot;&gt;&lt;/span&gt;</div><div class="line">	&lt;span class=&quot;pip&quot;&gt;&lt;/span&gt;</div><div class="line">	&lt;span class=&quot;pip&quot;&gt;&lt;/span&gt;</div><div class="line">	&lt;span class=&quot;pip&quot;&gt;&lt;/span&gt;</div><div class="line">	&lt;span class=&quot;pip&quot;&gt;&lt;/span&gt;</div><div class="line">	&lt;span class=&quot;pip&quot;&gt;&lt;/span&gt;</div><div class="line">	&lt;span class=&quot;pip&quot;&gt;&lt;/span&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<h3 id="基本网格布局"><a href="#基本网格布局" class="headerlink" title="基本网格布局"></a>基本网格布局</h3><p>最简单的网格布局，就是平均分布。在容器里面平均分配空间，跟上面的骰子布局很像，但是需要设置项目的自动缩放。<br><img src="http://note.youdao.com/yws/res/33092/WEBRESOURCE677e80ac3a38f0119925eeb8d989f213" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">.Grid&#123;</div><div class="line">  display: flex;</div><div class="line">&#125;</div><div class="line">.Grid-cell&#123;</div><div class="line">  flex: 1;</div><div class="line">  width: 300px;</div><div class="line">  height: 300px;</div><div class="line">  margin: 20px;</div><div class="line">  background: black;</div><div class="line">&#125;</div><div class="line">&lt;div class=&quot;Grid&quot;&gt;</div><div class="line">  &lt;div class=&quot;Grid-cell&quot;&gt;...&lt;/div&gt;</div><div class="line">  &lt;div class=&quot;Grid-cell&quot;&gt;...&lt;/div&gt;</div><div class="line">  &lt;div class=&quot;Grid-cell&quot;&gt;...&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<h3 id="百分比布局"><a href="#百分比布局" class="headerlink" title="百分比布局"></a>百分比布局</h3><p>某个网格的宽度为固定的百分比，其余网格平均分配剩余的空间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">.Grid&#123;</div><div class="line">  display: flex;</div><div class="line">&#125;</div><div class="line">.Grid-cell&#123;</div><div class="line">  flex: 1;</div><div class="line">&#125;</div><div class="line">.Grid-cell.u-full&#123;</div><div class="line">  flex: 0 0 100%;</div><div class="line">&#125;</div><div class="line">.Grid-cell.u-full2&#123;</div><div class="line">  flex: 0 0 50%;</div><div class="line">&#125;</div><div class="line">.Grid-cell.u-full3&#123;</div><div class="line">  flex: 0 0 33.333%;</div><div class="line">&#125;</div><div class="line">.Grid-cell.u-full4&#123;</div><div class="line">  flex: 0 0 25%;</div><div class="line">&#125;</div><div class="line">&lt;div class=&quot;Grid&quot;&gt;</div><div class="line">  &lt;div class=&quot;Grid-cell u-1of4&quot;&gt;...&lt;/div&gt;</div><div class="line">  &lt;div class=&quot;Grid-cell&quot;&gt;...&lt;/div&gt;</div><div class="line">  &lt;div class=&quot;Grid-cell u-1of3&quot;&gt;...&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<p><img src="http://note.youdao.com/yws/res/33103/WEBRESOURCEba353fc26f9c68b7285a0d429ca3f3bc" alt="image"></p>
<h3 id="输入框的布局"><a href="#输入框的布局" class="headerlink" title="输入框的布局"></a>输入框的布局</h3><p>我们常常需要在输入框的前方添加提示，后方添加按钮。<br><img src="http://note.youdao.com/yws/res/33107/WEBRESOURCE492920012503aa5ba466401898612421" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">.InputAddOn &#123;</div><div class="line">  display: flex;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.InputAddOn-field &#123;</div><div class="line">  flex: 1;</div><div class="line">  /* field styles */</div><div class="line">&#125;</div><div class="line">&lt;!-- both --&gt;</div><div class="line">&lt;div class=&quot;InputAddOn&quot;&gt;</div><div class="line">  &lt;span class=&quot;InputAddOn-item&quot;&gt;…&lt;/span&gt;</div><div class="line">  &lt;input class=&quot;InputAddOn-field&quot;&gt;</div><div class="line">  &lt;button class=&quot;InputAddOn-item&quot;&gt;…&lt;/button&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<h3 id="悬挂式布局"><a href="#悬挂式布局" class="headerlink" title="悬挂式布局"></a>悬挂式布局</h3><p>有时，主栏的左侧或右侧，需要添加一个图片栏。<br><img src="http://note.youdao.com/yws/res/33114/WEBRESOURCE18f83d29028e5e30b707491c0168d11d" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">.Media&#123;</div><div class="line">  display: flex;</div><div class="line">  align-items: flex-start;</div><div class="line">&#125;</div><div class="line">.Media-figure&#123;</div><div class="line">  margin-right: 1em;</div><div class="line">&#125;</div><div class="line">.Media-body&#123;</div><div class="line">  flex: 1;</div><div class="line">&#125;</div><div class="line"></div><div class="line">&lt;div class=&quot;Media&quot;&gt;</div><div class="line">  &lt;img class=&quot;Media-figure&quot; src=&quot;&quot; alt=&quot;&quot;&gt;</div><div class="line">  &lt;p class=&quot;Media-body&quot;&gt;…&lt;/p&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<h3 id="固定栏布局"><a href="#固定栏布局" class="headerlink" title="固定栏布局"></a>固定栏布局</h3><p>有时，页面内容太少，无法占满一屏的高度，底栏就会抬高到页面的中间。这时可以采用Flex布局，让底栏总是出现在页面的底部。<br><img src="http://note.youdao.com/yws/res/33123/WEBRESOURCEd098a8914d5bb5954c842b106dca1ce2" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">.Site&#123;</div><div class="line">  display: flex;</div><div class="line">  min-height: 100vh;</div><div class="line">  flex-content: column;</div><div class="line">&#125;</div><div class="line">.Site-content&#123;</div><div class="line">  flex: 1;</div><div class="line">&#125;</div><div class="line">&lt;body class=&quot;Site&quot;&gt;</div><div class="line">  &lt;header&gt;…&lt;/header&gt;</div><div class="line">  &lt;main class=&quot;Site-content&quot;&gt;…&lt;/main&gt;</div><div class="line">  &lt;footer&gt;…&lt;/footer&gt;</div><div class="line">&lt;/body&gt;</div></pre></td></tr></table></figure>
<p>相对于浏览器内部可视区的高度。视口被均分为100单位的vh。这样的话最小高度就刚好是一个浏览器视口大小了。<br><img src="http://note.youdao.com/yws/res/33133/WEBRESOURCE17f5c4bee32f7fe82d09ce73e7e1ae5d" alt="image"></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Flex布局1]]></title>
      <url>https://zaynex.github.io/2016/08/01/flex%E5%B8%83%E5%B1%80%E5%85%A5%E9%97%A8/</url>
      <content type="html"><![CDATA[<h2 id="Flex术语及模型"><a href="#Flex术语及模型" class="headerlink" title="Flex术语及模型"></a>Flex术语及模型</h2><p>flex布局模型不同于块和内联模型布局，块和内联模型的布局计算依赖于块和内联的流方向，而flex布局依赖于flex directions.简单的说：Flexbox是布局模块，而不是一个简单的属性，它包含父元素(flex container)和子元素(flex items)的属性。<br><a id="more"></a></p>
<ul>
<li>主轴、主轴方向(main axis |main dimension)：用户代理沿着一个伸缩容器的主轴配置伸缩项目，主轴是主轴方向的延伸。</li>
<li>主轴起点、主轴终点(main-start |main-end)：伸缩项目的配置从容器的主轴起点边开始，往主轴终点边结束。</li>
<li>主轴长度、主轴长度属性(main size |main size property)：伸缩项目的在主轴方向的宽度或高度就是项目的主轴长度，伸缩项目的主轴长度属性是width或height属性，由哪一个对着主轴方向决定。</li>
<li>侧轴、侧轴方向(cross axis |cross dimension)：与主轴垂直的轴称作侧轴，是侧轴方向的延伸。</li>
<li>侧轴起点、侧轴终点(cross-start |cross-end)：填满项目的伸缩行的配置从容器的侧轴起点边开始，往侧轴终点边结束。</li>
<li>侧轴长度、侧轴长度属性(cross size |cross size property)：伸缩项目的在侧轴方向的宽度或高度就是项目的侧轴长度，伸缩项目的侧轴长度属性是”width”或”height”属性，由哪一个对着侧轴方向决定。<br><img src="http://note.youdao.com/yws/res/32801/WEBRESOURCEb6a112291c6296932efb601bcdbd6af5" alt="image"><h2 id="Flexbox使用示例"><a href="#Flexbox使用示例" class="headerlink" title="Flexbox使用示例"></a>Flexbox使用示例</h2><h3 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h3></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">body&#123;</div><div class="line">	margin: 0;</div><div class="line">	padding: 0;</div><div class="line">&#125;</div><div class="line">.parent&#123;</div><div class="line">	display: flex;</div><div class="line">	height: 300px;</div><div class="line">	background: black;</div><div class="line">&#125;</div><div class="line">.child&#123;</div><div class="line">	width: 100px;</div><div class="line">	height: 100px;</div><div class="line">	margin: auto; /*水平垂直居中*/</div><div class="line">	background: white; </div><div class="line">	&#125;  </div><div class="line">&lt;div class=&quot;parent&quot;&gt;</div><div class="line">	&lt;div class=&quot;child&quot;&gt;&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure>
<p>在Flex容器中，当项目边距设置为“auto”时，设置自动的垂直边距将使该项目完全集中两个轴。</p>
<h3 id="六个子元素布局"><a href="#六个子元素布局" class="headerlink" title="六个子元素布局"></a>六个子元素布局</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">body,ul&#123;</div><div class="line">	margin: 0;padding: 0;</div><div class="line">&#125;</div><div class="line">li&#123;</div><div class="line">	list-style: none;</div><div class="line">&#125;</div><div class="line">.flex-container&#123;</div><div class="line">	display: flex;</div><div class="line">	flex-flow: row wrap;</div><div class="line">	justify-content: space-around; </div><div class="line">&#125;</div><div class="line">.flex-item&#123;</div><div class="line">	background: tomato;</div><div class="line">	padding: 5px;</div><div class="line">	width: 200px;</div><div class="line">	height: 150px;</div><div class="line">	margin-top: 10px;</div><div class="line"></div><div class="line">	line-height: 150px;</div><div class="line">	color: white;</div><div class="line">	font-weight: bold;</div><div class="line">	font-size: 3em;</div><div class="line">	text-align: center;</div><div class="line">&#125;</div><div class="line">&lt;ul class=&quot;flex-container&quot;&gt;</div><div class="line">	&lt;li class=&quot;flex-item&quot;&gt;1&lt;/li&gt;</div><div class="line">	&lt;li class=&quot;flex-item&quot;&gt;2&lt;/li&gt;</div><div class="line">	&lt;li class=&quot;flex-item&quot;&gt;3&lt;/li&gt;</div><div class="line">	&lt;li class=&quot;flex-item&quot;&gt;4&lt;/li&gt;</div><div class="line">	&lt;li class=&quot;flex-item&quot;&gt;5&lt;/li&gt;</div><div class="line">	&lt;li class=&quot;flex-item&quot;&gt;6&lt;/li&gt;</div><div class="line">&lt;/ul&gt;</div></pre></td></tr></table></figure>
<p>移动浏览器窗口大小<br><img src="http://note.youdao.com/yws/res/32867/WEBRESOURCE2a39d97123bf78c306952da68b01d71b" alt="image"></p>
<h2 id="容器属性"><a href="#容器属性" class="headerlink" title="容器属性"></a>容器属性</h2><h3 id="display（flex-container）"><a href="#display（flex-container）" class="headerlink" title="display（flex container）"></a>display（flex container）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">display: other values | flex | inline-flex;</div></pre></td></tr></table></figure>
<h3 id="flex-direction（flex-container）"><a href="#flex-direction（flex-container）" class="headerlink" title="flex-direction（flex container）"></a>flex-direction（flex container）</h3><p>这个主要用来创建主轴，从而定义了伸缩项目放置在伸缩容器的方向。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">flex-direction: row | row-reverse | column | column-reverse</div></pre></td></tr></table></figure>
<ul>
<li>row(默认值)：在“ltr”排版方式下从左向右排列；在“rtl”排版方式下从右向左排列。</li>
<li>row-reverse：与row排列方向相反，在“ltr”排版方式下从右向左排列；在“rtl”排版方式下从左向右排列.</li>
<li>column：类似 于row，不过是从上到下排列.</li>
<li>column-reverse：类似于row-reverse，不过是从下到上排列。</li>
</ul>
<h3 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h3><p>默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。<br><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071006.png" alt="image"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.box&#123;</div><div class="line">  flex-wrap: nowrap | wrap | wrap-reverse;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它可能取三个值。</p>
<ul>
<li>nowrap（默认）：不换行。<br><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071007.png" alt="image"></li>
<li>wrap：换行，第一行在上方<br><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071008.jpg" alt="image"></li>
<li>wrap-reverse 换行，第一行在下方。<br><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071009.jpg" alt="image"></li>
</ul>
<h3 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h3><p>flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.box &#123;</div><div class="line">  flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们将上面的代码改成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">flex-flow: row-reverse wrap-reverse;</div></pre></td></tr></table></figure>
<p><img src="http://note.youdao.com/yws/res/32863/WEBRESOURCE3643f60bfc36c151be680ecbc0bd42f1" alt="image"></p>
<h3 id="justify-content（flex-container）"><a href="#justify-content（flex-container）" class="headerlink" title="justify-content（flex container）"></a>justify-content（flex container）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.box &#123;</div><div class="line">  justify-content: flex-start | flex-end | center | space-between | space-around;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://note.youdao.com/yws/res/32874/WEBRESOURCEdfec9072da79513ca0559a1043342006" alt="image"></p>
<p>可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。</p>
<ul>
<li>flex-start（默认值）：左对齐</li>
<li>flex-end：右对齐</li>
<li>center： 居中</li>
<li>space-between：两端对齐，项目之间的间隔都相等。</li>
<li>space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。<h3 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h3>该属性定义项目在交叉轴上如何对齐。<br><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071011.png" alt="image"></li>
<li>flex-start：交叉轴的起点对齐。</li>
<li>flex-end：交叉轴的终点对齐。</li>
<li>center：交叉轴的中点对齐。</li>
<li>baseline: 项目的第一行文字的基线对齐。</li>
<li>stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</li>
</ul>
<h3 id="align-content（flex-container）"><a href="#align-content（flex-container）" class="headerlink" title="align-content（flex container）"></a>align-content（flex container）</h3><p>align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。<br><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071012.png" alt="image"></p>
<ul>
<li>flex-start：与交叉轴的起点对齐。</li>
<li>flex-end：与交叉轴的终点对齐。</li>
<li>center：与交叉轴的中点对齐。</li>
<li>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。</li>
<li>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li>
<li>stretch（默认值）：轴线占满整个交叉轴。</li>
</ul>
<h2 id="项目属性"><a href="#项目属性" class="headerlink" title="项目属性"></a>项目属性</h2><h3 id="order（flex-items）"><a href="#order（flex-items）" class="headerlink" title="order（flex items）"></a>order（flex items）</h3><p>默认情况下，伸缩项目是按照文档流出现先后顺序排列。然而，“order”属性可以控制伸缩项目在他们的伸缩容器出现的顺序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.flex-container .flex-item:nth-child(1)&#123;</div><div class="line">	order: 10;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://note.youdao.com/yws/res/32901/WEBRESOURCE74c2b9d44a107604e7df7a2f28373494" alt="image"></p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071013.png" alt="image"></p>
<h3 id="flex-basis（flex-items）"><a href="#flex-basis（flex-items）" class="headerlink" title="flex-basis（flex items）"></a>flex-basis（flex items）</h3><p>这个用来设置伸缩基准值，剩余的空间按比率进行伸缩。<br>它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。</p>
<h3 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h3><p>flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.flex-container1 .flex-item:nth-child(2)&#123;</div><div class="line">	flex-grow: 1;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://note.youdao.com/yws/res/32904/WEBRESOURCE343e15f8f04145233dc55295c80a38a3" alt="image"></p>
<p>如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">.flex-container1 .flex-item:nth-child(2)&#123;</div><div class="line">	flex-grow: 1;</div><div class="line">&#125;</div><div class="line">.flex-container1 .flex-item:nth-child(3)&#123;</div><div class="line">	flex-grow: 2;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://note.youdao.com/yws/res/32912/WEBRESOURCE1cfd0ecb650fb9c528bd68b08eba88ee" alt="image"></p>
<h4 id="计算方法"><a href="#计算方法" class="headerlink" title="计算方法"></a>计算方法</h4><ul>
<li>flex-basis + flow-grow/sum(flow-grow) * remain</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">.flex-container1 .flex-item:nth-child(2)&#123;</div><div class="line">	width: 500px;</div><div class="line">	flex-grow: 1;</div><div class="line">&#125;</div><div class="line">.flex-container1 .flex-item:nth-child(3)&#123;</div><div class="line">	flex-grow: 2;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>flex-item2的宽度就是 当前宽度500+剩余宽度<em>1/3<br>flex-tiem2的宽度就是 当前宽度200+剩余宽度</em>2/3<br><img src="http://note.youdao.com/yws/res/32933/WEBRESOURCEd04e1b7c22528b58dcf217a2eb126446" alt="image"></p>
<h3 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h3><p>flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</p>
<p><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071015.jpg" alt="image"></p>
<h3 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h3><p>flex属性是flex-grow,flex-shrink和flex-basis的简写，默认值为0 1 auto。后两个属性可选。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.flex-item &#123;</div><div class="line">  flex: none | [ &lt;&apos;flex-grow&apos;&gt; &lt;&apos;flex-shrink&apos;&gt;? || &lt;&apos;flex-basis&apos;&gt; ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="align-self属性"><a href="#align-self属性" class="headerlink" title="align-self属性"></a>align-self属性</h3><p>align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.flex-item &#123;</div><div class="line">  align-self: auto | flex-start | flex-end | center | baseline | stretch;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">.flex-container .flex-item:nth-child(1)&#123;</div><div class="line">	order: 10;</div><div class="line">	align-self: flex-end;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://note.youdao.com/yws/res/32957/WEBRESOURCEe3990cd758cf6162e4ed9b8fca7175c4" alt="image"></p>
<h3 id="demo地址"><a href="#demo地址" class="headerlink" title="demo地址"></a>demo地址</h3><ul>
<li><a href="https://zaynex.github.io/baidu-ife-practice/2016/flex/demo1.html">https://zaynex.github.io/baidu-ife-practice/2016/flex/demo1.html</a></li>
<li><a href="https://zaynex.github.io/baidu-ife-practice/2016/flex/demo2.html">https://zaynex.github.io/baidu-ife-practice/2016/flex/demo2.html</a><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3></li>
<li><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="external">Flex 布局教程：语法篇</a></li>
<li><a href="https://segmentfault.com/a/1190000002910324" target="_blank" rel="external">Flexbox详解</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript高级程序设计第六章学习笔记对象]]></title>
      <url>https://zaynex.github.io/2016/07/31/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%AC%E5%85%AD%E7%AB%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%AF%B9%E8%B1%A1/</url>
      <content type="html"><![CDATA[<h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><p>使用对象字面量的形式一个接口会创建很多对象， 会产生大量的重复代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">peroson1 = &#123;</div><div class="line">	name: &quot;Nicholas&quot;,</div><div class="line">	age: 29,</div><div class="line">	job: &quot;software Engineer&quot;,</div><div class="line"></div><div class="line">	sayName: function()&#123;</div><div class="line">		alert(this.name);</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line">peroson2 = &#123;</div><div class="line">	name: &quot;Zaynex&quot;,</div><div class="line">	age: 22,</div><div class="line">	job: &quot;Doctor&quot;,</div><div class="line"></div><div class="line">	sayName: function()&#123;</div><div class="line">		alert(this.name);</div><div class="line">	&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>如果要创建一个name叫”Zaynex”的person，又要重新定义一段大量重复的代码，于是有了工厂模式。<br><a id="more"></a></p>
<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><ul>
<li><p>用函数来封装以特定接口创建对象的细节，依靠返回内部的构造函数来保存对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function createPerson (name,age,job)</div><div class="line">&#123;</div><div class="line">	var o = new Object();</div><div class="line">	o.name = name;</div><div class="line">	o.age = age;</div><div class="line">	o.job = job;</div><div class="line">	o.sayName =function()</div><div class="line">	&#123;</div><div class="line">		alert(this.name);</div><div class="line">	&#125;</div><div class="line">	return o;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var person1 = createPerson(&quot;Simon&quot;, 29, &quot;software Engineer&quot;);</div><div class="line">var person2 = createPerson(&quot;Zaynex&quot;,22, &quot;Doctor&quot;);</div></pre></td></tr></table></figure>
</li>
<li><p>这种模式解决了创建多个相似对象的问题，但却没办法知道这个对象是什么类型的。（啥意思？）</p>
</li>
</ul>
<h3 id="构造函数模式："><a href="#构造函数模式：" class="headerlink" title="构造函数模式："></a>构造函数模式：</h3><ul>
<li>可用于创建特定模式的对象，像Object、Array等原生构造函数，在运行时会自动出现在执行环境中。<br>我们利用构造函数重写下刚才的函数<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function createPerson(name, age, job)</div><div class="line">	&#123;</div><div class="line">		this.name = name;</div><div class="line">		this.age = age;</div><div class="line">		this.job = job;</div><div class="line">		this.sayName = function()</div><div class="line">		&#123;</div><div class="line">			alert(this.name);</div><div class="line">		&#125;;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	var person1 = new Person(&quot;Simon&quot;,29, &quot;software Engineer&quot;);</div><div class="line">	var person2 = new Person(&quot;Simon&quot;,29, &quot;software Engineer&quot;);</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="构造函数与工厂模式的差异"><a href="#构造函数与工厂模式的差异" class="headerlink" title="构造函数与工厂模式的差异"></a>构造函数与工厂模式的差异</h3><ol>
<li>没有显示地创建对象；</li>
<li>直接将属性和方法赋给this对象；</li>
<li>没有 return 语句；</li>
</ol>
<p>我们注意到Person开头是大写，按照惯例来讲，构造函数开头字母是大写，非构造函数以小写字母开头。</p>
<h3 id="要创建Person的实例，必须使用new-操作符。所以调用构造函数会经历以下4个步骤"><a href="#要创建Person的实例，必须使用new-操作符。所以调用构造函数会经历以下4个步骤" class="headerlink" title="要创建Person的实例，必须使用new 操作符。所以调用构造函数会经历以下4个步骤"></a>要创建Person的实例，必须使用new 操作符。所以调用构造函数会经历以下4个步骤</h3><ol>
<li>创建一个新对象</li>
<li>将构造函数的作用域赋给新对象（因此this就指向了这个新对象）</li>
<li>执行构造函数中的代码（为构造函数新对象添加属性）</li>
<li>返回新对象</li>
</ol>
<p>person1和person2都保存着Person的一个不同的实例。这两个对象都有一个constructor(构造函数)属性，该属性指向Person。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">alert(person1.constructor == Person) //true;</div><div class="line">alert(person2.constructor == Person) //true;</div></pre></td></tr></table></figure></p>
<p>对象的constructor属性最初是用来标识对象类型的。但是提到检测对象类型，还是instanceof操作符更可靠一些。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">alert(person1 instanceof Object);</div><div class="line">alert(person1 instanceof Person);</div><div class="line">alert(person2 instanceof Object);</div><div class="line">alert(person2 instanceof Person);</div><div class="line">//都为true.</div></pre></td></tr></table></figure></p>
<p>我们所创建的所有对象都是Object的实例，同时也是Person的实例。<br>创建自定义的构造函数意味着将来可以作为实例标识为一种特定的类型：（person1和perosn2都被转化成了特定的对象类型），构造函数模式胜过工厂模式的地方。这就是答案。</p>
<h3 id="把构造函数当函数"><a href="#把构造函数当函数" class="headerlink" title="把构造函数当函数"></a>把构造函数当函数</h3><p>任何函数，只要通过  new 操作符来调用，那它就可以作为构造函数；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//当做构造函数使用</div><div class="line">var person = new Person(&quot;Simon&quot;, 29, &quot;software Engineer&quot;);</div><div class="line">person.sayName(); //Simon</div><div class="line"></div><div class="line">//普通函数调用</div><div class="line">Person(&quot;Genf&quot;, 23, &quot;DOCTOR&quot;);  //添加到window</div><div class="line">window.sayName();  // Genf</div></pre></td></tr></table></figure></p>
<p>以刚才的那种方式定义的构造函数定义在Global对象中（在浏览器中是window对象），在全局作用域中调用函数时，this指向的是window对象。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// 在另外一个对象的作用域中调用</div><div class="line">var o = new Object();</div><div class="line">Person.call(o, &quot;Kristen&quot;, 25, &apos;nusd&apos;);</div><div class="line">o.sayName(); // Kristen</div></pre></td></tr></table></figure></p>
<h3 id="构造函数的缺陷"><a href="#构造函数的缺陷" class="headerlink" title="构造函数的缺陷"></a>构造函数的缺陷</h3><p>每个方法都要在每个实例上重新创建一遍。<br>person1 和 person2 都有一个名为 sayName() 的方法；但那两个方法都不是同一个 Function 的实例，因此会有不同的作用域链和标识符解析；<br>不同实例上的同名函数是不同的。</p>
<p>不要忘了，每个函数都是一个对象！所以sayName方法也可以这样写，因此每个Person实例都包含着不同的Function实例。以这种方式创建函数，会导致不同饿作用域和标识符加息。<br>this.sayName = new Function(“alert(this.name)”);  //与声明函数在逻辑上是等价的<br>我们可以检验下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alert(person1.sayName() == person2.sayName); //false</div></pre></td></tr></table></figure></p>
<p>创建两个完成相同任务的Function 实例没有必要，况且有this对象在，根本不用在执行代码前就把函数绑定到特定对象上面。</p>
<ul>
<li>我们可以通过函数定义转移构造函数外部来解决这个问题。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function Person(name, age ,job)</div><div class="line">&#123;</div><div class="line">	this.name = name;</div><div class="line">	this.age = age;</div><div class="line">	this.sayName = sayName;</div><div class="line">&#125;</div><div class="line"></div><div class="line">function sayName()</div><div class="line">&#123;</div><div class="line">	alert(this.name);</div><div class="line">&#125;</div><div class="line"></div><div class="line">var person1 = new Person(&quot;Simon&quot;, 29, &quot;software Engineer&quot;);</div><div class="line">var person2 = new Person(&quot;Zaynex&quot;, 29, &quot;DOCTOR&quot;);</div></pre></td></tr></table></figure>
</li>
</ul>
<p>把sayName()函数的定义转移到了构造函数外部。<br>在构造函数内部，将sayName属性设置成等于全局的 sayName 函数。<br>这样sayName 包含的是一个指向函数的指针。 person1和person2共享同一个sayName()函数<br>但问题是：<br><strong><br>但在全局作用域中定义的函数实际上只能被某个对象调用，这不就让全局函数显得很鸡肋么！如果对象需要定义很多方法，那么就要定义多个全局函数。
</strong></p>
<p>因此我们需要用原型模式来解决这个问题。</p>
<h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>我们创建的每个函数都有一个  prototype（原型） 属性，这个属性属于指针，它指向一个对象，而这个对象的用途是包含可以<br>由特定类型的所有实例的共享的属性和方法。（这样我们就能共享sayName()方法咯）</p>
<p>即通过构造函数而创建的那个对象实例的原型对象。我们不必将构造函数定义对象实例的信息中，而是可以将这些信息直接添加到对象原型中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function Person()&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype.name =&quot;Simon&quot;;</div><div class="line">Person.prototype.age = 29;</div><div class="line">Person.prototype.job = &quot;software Engineer&quot;;</div><div class="line">Person.prototype.sayName = function()&#123;</div><div class="line">	alert(this.name);</div><div class="line">&#125;;</div><div class="line">var person1 = new Person();</div><div class="line">person1.sayName();  // Simon</div><div class="line">var person2 = new Person();</div><div class="line">person2.sayName(); // Simon</div><div class="line">	alert(person1.sayName == person2.sayName); // true</div></pre></td></tr></table></figure></p>
<p>实际上，person1和person2都不包含属性和方法，因为Perosn这个构造函数是空函数。但可以调用person1.sayName()。</p>
<h3 id="理解原型对象"><a href="#理解原型对象" class="headerlink" title="理解原型对象"></a>理解原型对象</h3><p>无论何时，只要创建了新函数，就会根据一组特定的规则为该函数创建一个 prototype 属性，这个属性指向函数的原型对象。在默认情况下，所有原型都会自动获得一个constructor（构造函数）属性，<br>这个属性包含在一个指向 prototype属性所在的函数的指针。<br>举例说明： Person.prototype.constructor 指向Person.</p>
<p>创建了自定义构造函数之后，其原型对象默认只会取得 constructor 属性。其他方法都是从Object继承来的。</p>
<p>调用构造函数的一个实例后，该实例内部将包含一个指针（ES5中称为[[Prototype]]，指向构造函数的原型对象。在脚本中没有标准形式访问[[Prototype]]，但在FF,SF,Chrome中的每个对象都支持属性<em>proto</em>;在其他实现中，该属性对脚本不可见。<br>要明确的是，<strong> 这个链接存在于实例与构造函数的原型对象之间，而非实例与构造函数之间。 </strong></p>
<p>虽然在现实中无法访问到[[Prototype]],但可以通过 isPrototypeOf()来确定是否存在这种关系。</p>
<p>在ES5中新增一个方法，使用 Object.getPrototypeOf()可以方便的获取一个对象的原型</p>
<ul>
<li>alert(Object.getPrototypeOf(person1).name); // Simon</li>
</ul>
<p>每当代码读取某个对象的某个属性时，都会执行一次搜索，</p>
<ol>
<li>先从实例本身开始搜索属性，存在，搜索结束。若不存在，执行2</li>
<li>从实例的原型开始搜索属性。</li>
</ol>
<p>继续刚才的代码。如果我们继续给实例添加相同的属性，会怎样？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">function Person()&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype.name =&quot;Simon&quot;;</div><div class="line">Person.prototype.age = 29;</div><div class="line">Person.prototype.job = &quot;software Engineer&quot;;</div><div class="line">Person.prototype.sayName = function()&#123;</div><div class="line">	alert(this.name);</div><div class="line">&#125;;</div><div class="line">var person1 = new Person();</div><div class="line">var person2 = new Person();</div><div class="line">person1.name = &quot;xiwenzheng&quot;;</div><div class="line"></div><div class="line">alert(person1.name) //xiwenzheng  ——来自实例</div><div class="line">alert(person2.name) // Simon  ——来自原型</div></pre></td></tr></table></figure></p>
<p>在person1这个实例中重写属性，那么解释器搜索到了实例本身的属性直接返回，<br>对于person2而言，实例中没有属性，那么再往实例的原型开始搜素属性；<br>给对象添加一个属性时，这个属性就会屏蔽原型对象中保存的同名属性，就是阻止我们访问原型对象，但并不会修改原型对象中的同名属性。即使将person1.name 设置为 null  也不会影响原型对象中的同步属性。        </p>
<ul>
<li>不过delete 实例属性，就可以访问原型对象中的属性了。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">function Person()&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype.name =&quot;Simon&quot;;</div><div class="line">Person.prototype.age = 29;</div><div class="line">Person.prototype.job = &quot;software Engineer&quot;;</div><div class="line">Person.prototype.sayName = function()&#123;</div><div class="line">	alert(this.name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var person1 = new Person();</div><div class="line">var person2 = new Person();</div><div class="line">person1.name = &quot;Zaynex&quot;;</div><div class="line">alert(person1.name); //Zaynex  ——来自实例</div><div class="line">alert(person2.name); // Simon  ——来自原型</div><div class="line">delete person1.name;</div><div class="line">alert(person1.name); // Simon 来自原型</div></pre></td></tr></table></figure>
<p>使用hasOwnProperty()可以检测一个属性是否存在实例中还是存在原型中，这个方法只在给定属性存在于对象实例中才会返回 true;<br>我们继续采用刚才删除部分的整段代码。<br>alert(person1.hasOwnProperty(“name”)); // 返回false<br>原先person1.name是存在对象实例中的（被我们设为了”Zaynex”）,但是被我们delete了。<br>如果我们不delete的话，那就是true了。</p>
<p>要想获得原型属性的描述符，必须要在原型对象上调用 Object.hasOwnPropertydDsecriptor();</p>
<p>原型与 in 操作符</p>
<p>in 操作符会在通过对象能够访问给定属性时返回 true ，不论该实例存在于实例中还是原型中。</p>
<p>利用in:判断是否有该属性<br>利用hasOwnProperty()判断是否存在对象实例中;<br>结合以后就可以判断该属性是在原型中还是在实例中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function hasPrototypeProperty(object, name )&#123;</div><div class="line">	return !object.hasOwnProperty(name) &amp;&amp; (name in object);</div><div class="line">&#125;</div><div class="line">person1.name = &quot;Zaynex&quot;;</div><div class="line">alert(hasPrototypeProperty(person1, &quot;name&quot;)); //false；存在实例中</div></pre></td></tr></table></figure></p>
<p>for-in 循环时，返回的都是通过对象访问的、可枚举的属性（即将[[Enumberable]]标记为true的属性）,在ES5中constructor 和 prototype属性的 [[Enumberable]]<br>设为false，但并不是所有浏览器都照此实现。<br>想取得对象上所有可枚举的实例属性，可以使用Object.Keys()方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">function Person()&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype.name =&quot;Simon&quot;;</div><div class="line">Person.prototype.age = 29;</div><div class="line">Person.prototype.job = &quot;software Engineer&quot;;</div><div class="line">Person.prototype.sayName = function()&#123;</div><div class="line">	alert(this.name);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">var keys = Object.keys(Person.prototype);</div><div class="line">alert(keys);//  name ,age, job, sayName</div><div class="line"></div><div class="line">var p1 = new Person();</div><div class="line">p1.name = &quot;Rob&quot;;</div><div class="line">p1.age = 29;</div><div class="line"></div><div class="line">var p1keys = Object.keys(p1);</div><div class="line">alert(p1keys);  // name ,age</div></pre></td></tr></table></figure></p>
<p>Object.getOwnPropertyNames()可以获得所有实例属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var keys = Object.keys(Person.prototype);</div><div class="line">alert(keys);//  constructor, name ,age, job, sayName</div></pre></td></tr></table></figure></p>
<h3 id="更简单的原型语法"><a href="#更简单的原型语法" class="headerlink" title="更简单的原型语法"></a>更简单的原型语法</h3><pre><code>之前的例子中每添加一个属性和方法都要 Person.prototype，我们进行适当的封装。
</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function Person()&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype = &#123;</div><div class="line">	name : &quot;Simon&quot;,</div><div class="line">	age : 29;</div><div class="line">	job : &quot;software Engineer&quot;,</div><div class="line">	sayName : function  () &#123;</div><div class="line">		alert(this.name);</div><div class="line">	&#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这种对象字面量形式的写法会创建新的对象，每创建一个函数还会自动创建prototype对象并且会指定获得constructor属性。这里的语法本质上是重写了默认的 prototype 对象。<br>所以 constructor属性也成了了新对象的属性。（指向Object构造函数），不再指向Person。</p>
<p>instanceof 测试 Object 和 Person 都返回 true，但constructor 属性则等于Object而不等于Person。<br>如果 constructor 的值很重要，则可以特意设置回适当的值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function Person()&#123;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype = &#123;</div><div class="line">	constructor:Person,</div><div class="line">	name : &quot;Simon&quot;,</div><div class="line">	job : &quot;software Engineer&quot;,</div><div class="line">	sayName : function () &#123;</div><div class="line">		alert(this.name);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<ul>
<li>注意，以这种方式重设constructor属性会导致 [[Enumberable]]特性设置为true，但默认我们是不可枚举constructor属性的。</li>
</ul>
<p>为了兼容ES5的JS引擎，可以用 Object.defineProperty()把它改成不可枚举。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function Person()&#123;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	Person.prototype = &#123;</div><div class="line">		name : &quot;Simon&quot;,</div><div class="line">		job : &quot;software Engineer&quot;,</div><div class="line">		sayName : function () &#123;</div><div class="line">			alert(this.name);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">Object.defineProperty(Person.prototype, &quot;constructor&quot;, &#123;</div><div class="line">	enumerable: false,</div><div class="line">	value: Person</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="原型的动态性"><a href="#原型的动态性" class="headerlink" title="原型的动态性"></a>原型的动态性</h3><p>在原型中找值的过程是一次搜索，因此我们对原型对象所做的任何修改都能立即从实例中反应出来——即使是先创建实例后修改原型。<br>不信你看：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var friend = new Person();</div><div class="line">Person.prototype.sayHi = function()&#123;</div><div class="line">	alert(&quot;hi&quot;);</div><div class="line">&#125;;</div><div class="line">friend.sayHi();  // &quot;hi&quot;</div></pre></td></tr></table></figure></p>
<p>这样是没问题的。先在实例中搜索，如果没找到继续搜索原型。</p>
<p>但是如果重写了整个原型对象，情况就会不一样(记得重写原型对象相当于创建了一个新函数)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function Person()&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line">var  friend = new Person();</div><div class="line">Person.prototype = &#123;</div><div class="line">	constructor:Person,</div><div class="line">	name : &quot;Simon&quot;,</div><div class="line">	job : &quot;software Engineer&quot;,</div><div class="line">	sayName : function () &#123;</div><div class="line">		alert(this.name);</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line">friend.sayName();  //error</div></pre></td></tr></table></figure></p>
<p>在这个例子中，我们先创建了Person的实例，然后又重写了其原型对象，然后在调用sayName()时发生错误，因此friend指向的原型不包含以该名字命名的属性。<br>friend的[[prototype]]指针指向了最初没有任何方法属性的构造函数（Person）的原型，而该原型的constructor属性指向了该构造函数（Person）,因为我们重写了构造函数的原型，所以原本person的原型指向了新的Person原型。这个新原型的constructor属性指向了原来的构造函数（person）。</p>
<p><strong> 调用构造函数时会为实例添加一个指向最初原型的 prototype 指针，而把原型修改为另外一个对象就等于切断了构造函数与最初函数之间的联系。<br>请记住：所有实例中的指针仅指向原型，而不指向构造函数。 </strong></p>
<p>不推荐在产品化的程序中修改原生对象的原型。</p>
<h3 id="原型对象的问题"><a href="#原型对象的问题" class="headerlink" title="原型对象的问题"></a>原型对象的问题</h3><ol>
<li>省略了为构造函数传递初始化参数这一环节，结果所有实例在默认情况下都取得相同的属性值。</li>
<li>共享导致的问题，对于包含引用类型值的属性来说，这个问题比较突出。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">function Person()&#123;</div><div class="line">&#125;</div><div class="line">Person.prototype = &#123;</div><div class="line">    constructor:Person,</div><div class="line">    name : &quot;Simon&quot;,</div><div class="line">    job : &quot;software Engineer&quot;,</div><div class="line">    friends : [&quot;Shelby&quot;, &quot;Court&quot;],</div><div class="line">    sayName : function () &#123;</div><div class="line">        alert(this.name);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line">var  person1 = new Person();</div><div class="line">var person2 = new Person();</div><div class="line">person1.friends.push(&quot;Van&quot;);</div><div class="line">console.log(person1.friends); //[&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]</div><div class="line">console.log(person2.friends); // [&quot;Shelby&quot;, &quot;Court&quot;, &quot;Van&quot;]</div><div class="line">alert(person1.friends === person2.friends) // true;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>修改person1.friends 引用的数组，添加字符串，由于 friends数组存在 Person.prototype 而非 person1中，所以修改也会造成person2.friends反应。</p>
<h3 id="组合使用构造函数模式和原型模式"><a href="#组合使用构造函数模式和原型模式" class="headerlink" title="组合使用构造函数模式和原型模式"></a>组合使用构造函数模式和原型模式</h3><p>利用构造函数定义实例属性，用原型模式定义方法和共享的属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">function Person (name, age, job)&#123;</div><div class="line">	this.name = name;</div><div class="line">	this.age = age;</div><div class="line">	this.job = job;</div><div class="line">	this.friends = [&quot;Shelby&quot;, &quot;Court&quot;];</div><div class="line">&#125;</div><div class="line">Person.prototype = &#123;</div><div class="line">	constructor : Person,</div><div class="line">	sayName : function ()&#123;</div><div class="line">		alert(this.name);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">var person1 = new Person(&quot;Nicholas&quot;, 29, &quot;software Engineer&quot;);</div><div class="line">var person2 = new Person(&quot;Greg&quot;, 27, &quot;DOCTOR&quot;);</div><div class="line">person1.friends.push(&quot;Van&quot;);</div><div class="line">alert(person1.friends);  // Shelby,Court,Van</div><div class="line">alert(person2.friends); // shelby,Court</div><div class="line">alert(person1.friends === person2.friends); // false</div><div class="line">alert(person1.sayName === person2.sayName); // true</div></pre></td></tr></table></figure></p>
<p>实例属性都是在构造函数中定义的，所有实例共享的属性是在 constructor 和方法sayName()是在原型中定义的。</p>
<h3 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h3><p>当其他OO语言经验开发人员看到独立的构造函数和原型时，会感到困惑。因此出现了 动态原型模式：<br>即把所有信息都封装在了构造函数中，而通过在构造函数中初始化原型（仅在必要的情况下），又保持了同事使用构造函数和原型的优点。</p>
<p>换句话说，可以通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">function Person (name, age, job)&#123;</div><div class="line">    //属性</div><div class="line">   this.name = name;</div><div class="line">   this.age = age;</div><div class="line">   this.job = job;</div><div class="line">   this.friends = [&quot;Shelby&quot;, &quot;Court&quot;];</div><div class="line"></div><div class="line">   if( typeof this.sayName != &quot;function&quot;)&#123;</div><div class="line">       Person.prototype.sayName = function() &#123;</div><div class="line">           alert(this.name);</div><div class="line">       &#125;;</div><div class="line">   &#125;</div><div class="line"> &#125;</div><div class="line">// 只有在sayName不存在的情况下才将其添加到原型中，这段代码只会在初次调用函数时执行。此后原型已经完成初始化，不需要再做修改。</div><div class="line">var  friends1 = new Person(&quot;Nicholas&quot;, 29, &quot;software Engineer&quot;);</div><div class="line">var friends2 = new Person(&quot;Zaynex&quot;,19,&quot;Engineer&quot;);</div><div class="line">friends1.sayName();</div><div class="line">friends2.sayName();</div></pre></td></tr></table></figure></p>
<p>由于第一次当friends1初始化之后，friends2就不需要再进行初始化原型。</p>
<h3 id="寄生构造函数模式"><a href="#寄生构造函数模式" class="headerlink" title="寄生构造函数模式"></a>寄生构造函数模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function Person (name, age, job)&#123;</div><div class="line">	var o = new Object();</div><div class="line">	o.name = name;</div><div class="line">	o.age = age;</div><div class="line">	o.job = job;</div><div class="line">	o.sayName = function()&#123;</div><div class="line">		alert(thi.name);</div><div class="line">	&#125;;</div><div class="line">	return o;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var friend = new Person (&quot;Nicholas&quot;, 29, &quot;software Engineer&quot;);</div><div class="line">friends.sayName(); // Nicholas</div></pre></td></tr></table></figure>
<p>除了使用new 操作符并把使用的包装函数叫做构造函数外，这个模式和工厂模式一样；构造函数在无返回值的情况下，默认返回新对象实例。<br>而在通过构造函数的末尾添加一个return，可以重写调用构造函数时返回的值。</p>
<p>这个模式可以在特殊情况下用来为对象创建构造函数。</p>
<p>假设我们想创建一个具有额外方法的特殊数组，由于不能直接修改Array构造函数，因此可以使用这个模式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function SpecialArray()&#123;</div><div class="line">   var values = new Array();</div><div class="line"></div><div class="line">	values.push.apply(values, arguments);</div><div class="line"></div><div class="line">	values.toPipedString = function()&#123;</div><div class="line">		return this.join(&quot;|&quot;);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	return values;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var colors = new SpecialArray(&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;);</div><div class="line">alert(colors.toPipedString());  // red|blue|green</div></pre></td></tr></table></figure></p>
<p>函数内部创建了一个数组，通过push()方法初始化了数组的值。<br>寄生构造函数模式：返回的对象与构造函数或者与构造函数的原型属性没有关系；不能依赖于 instanceof操作符确定对象类型。因此不建议在已使用其他模式的情况下使用该种模式。</p>
<h3 id="稳妥构造函数模式"><a href="#稳妥构造函数模式" class="headerlink" title="稳妥构造函数模式"></a>稳妥构造函数模式</h3><ul>
<li>稳妥对象，是指没有公共属性，其方法也不引用this的对象。适合在安全环境下（这些环境会禁止使用this 和 new），或者放置数据被其他应用程序改动时使用。<h4 id="稳妥构造函数模式和寄生构造函数差异"><a href="#稳妥构造函数模式和寄生构造函数差异" class="headerlink" title="稳妥构造函数模式和寄生构造函数差异"></a>稳妥构造函数模式和寄生构造函数差异</h4></li>
</ul>
<ol>
<li>新创建的对象的实例方法不引用this。</li>
<li>不使用new 操作符调用构造函数。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">function Person(name, age, job) &#123;</div><div class="line">   var o = new Object();</div><div class="line">   //可以在这里定义私有变量和函数。</div><div class="line">   //</div><div class="line">   //添加方法</div><div class="line">   o.sayName = function()&#123;</div><div class="line">       alert(name);</div><div class="line">   &#125;;</div><div class="line">   //返回对象</div><div class="line">   return o;</div><div class="line">&#125;</div><div class="line">var friend = Person(&quot;Nicholas&quot;, 29, &quot;software Engineer&quot;);</div><div class="line">friend.sayName();</div></pre></td></tr></table></figure>
</li>
</ol>
<p>以这种模式创建的对象，除了使用sayName()方法以外，没有其他办法访问name的值。<br>与计生构造函数模式类似，使用稳妥构造函数模式创建的对象与构造函数之间没有什么关系，因此instanceof操作符对这种对象没有意义。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[如果生命只剩下最后一天]]></title>
      <url>https://zaynex.github.io/2016/07/28/%E5%A6%82%E6%9E%9C%E7%94%9F%E5%91%BD%E5%8F%AA%E5%89%A9%E4%B8%8B%E6%9C%80%E5%90%8E%E4%B8%80%E5%A4%A9/</url>
      <content type="html"><![CDATA[<p>如果生命只剩下最后一天，<br>我会把床上和桌子上的杂物整理干净，好让人们知道我是个爱干净的人。<br>我会穿上整洁的衣服，洗干净头发，我想在这个世界留下更多的自信。</p>
<p>如果生命只剩下最后一天，<br>我会对每个在路上碰到的行人微笑，<br>因为我希望听到：虽不曾相识，但我依然待人友好。</p>
<p>如果生命只剩下最后一天，<br>我会耐心得看完一本书，然后用文字的力量让我的思想在这世界停留得更久远。</p>
<p>如果生命只剩下最后一天，<br>我将不再散漫，因为每一分每一秒都是我人生最后的精彩。</p>
<p>如果生命只剩下最后一天，<br>你还会坚持现在奋斗的事业么？</p>
<p>如果生命只剩下最后一天，<br>你能不带走遗憾地离开么？</p>
<p>珍惜时间。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[在家]]></title>
      <url>https://zaynex.github.io/2016/07/28/%E5%9C%A8%E5%AE%B6/</url>
      <content type="html"><![CDATA[<p>最近没有怎么看书，老是在看技术书。写不出一点东西来。但是希望自己挤点时间可以好好回顾以一下今天。<br>今天家里的网不能用了。似乎也刚好指引我该怎么学习——看书记笔记。</p>
<p>我还是第一个阶段，在量上面需要把握好，把基础的东西给学好。至少要理解这个是什么，那个是什么。<br>至于demo，继续按照百度上面的来做。多练练JS。把第七章给结束了，再去看前端微专业后面的题目。前面的布局作业还没有完成，周日找个时间解决掉。（如果空的话）</p>
<a id="more"></a>
<h2 id="关于葡萄"><a href="#关于葡萄" class="headerlink" title="关于葡萄"></a>关于葡萄</h2><p>家里院子种着几株葡萄，葡萄藤匍匐在父亲搭的几根裸露的木棍上，全靠着葡萄叶覆盖在顶板上。平时母亲就会在葡萄树荫下洗衣服。</p>
<p>傍晚，我看到母亲走向了葡萄树。我看到不少葡萄已经长长的一大串挂了下来。虽颗粒饱满，但是一片碧绿。我问母亲：这些葡萄都熟了吗？<br>母亲：还没熟呢，经常朝着太阳晒的几颗，有些变紫的才熟了。<br>我摸了摸还是绿色表皮的葡萄，感觉果肉还是有点硬实，母亲递给我几颗成熟的葡萄，拿在手里确实感觉前后不同。后者的果肉更水嫩些。<br>朝南的葡萄熟得快，太阳晒得快。<br>这个在生物里很好解释。促进光合作用，增加养分，其中就是葡萄糖。<br>看这几串颗粒饱满大模大样的挂在藤上引诱着人去摘，结果竟然还没有熟。都是葡萄，有成熟之分，先获得养分多的先成熟，这不就跟人一样吗？ 看起来都是人，但每个人的成熟度都不一样，你经历越多，你越成熟，你经历越少，只是一个平凡的肉体罢了。</p>
<p>对于葡萄而言，他们都会贪婪的吸收阳光。决定他们先成熟的可能是地理位置和时机。这些因素无法把握。<br>但对于人而言，一个人想要有所作为，真正称之为人，成为“一颗甜葡萄”，又需要什么因素呢？<br>思来想去，还是一个内在驱动力的问题。植物是没有思维的，该是怎样就是怎样，可以说，他们是被动而妥协的。但人不一样，人是可以主动出击并且乘胜追击的。我们与世界上其他生灵的区别就是思考。我们可以不断完善自己的想法并且去验证，这是我们能站在食物链顶端的缘故。<br>但绝大部分人，还是像那些没成熟的葡萄一样，没有优先的资源，不能优先获得足够的养分。我们能扭转局面的唯一办法就是让自己有更强的驱动力去做某事。<br>很多人都说，只要你想做，你就一定能做成。这句话在内在驱动力100%的人而言，确实是成立的。但大多数人，缺乏野心和动力，因为他们没有目标，连为什么要做都没搞清楚。<br>那你就只能沦为未成熟的葡萄，也许有的人会觉得挺好，听天由命嘛。但如果你也想改变自己或者想make difference，接下来的问题是，如果提高内在驱动力。</p>
<p>在我看来，首先就是目标。<br>释放自己原原本本的野心，不要有任何收敛，当你感觉你达到了这个目标那种走向人生巅峰的感觉，就是你的终极目标。</p>
<p>野心能让人卧薪尝胆，悬梁刺股。</p>
<p>短暂的精神幻想很愉快，那么过了这阵子之后，整个人的热情就会下降大半。因此需要想办法维持自己的野心和行动。<br>那就是小步快跑。<br>每当你完成一个阶段的任务后就会有相当的成就感。让自己不断获得成就，给自己自信，告诉自己目标依然是可以达成的。</p>
<p>找到艰苦的环境<br>越是艰苦的环境，越能激发人的斗志。你每天养尊处优，一定会得懒癌，至少也是学会了葛优躺。但你去其他艰苦的环境看看，原本存在内心的小宇宙又会再次爆发。那些你本该践行的又一次被唤醒。<br>天将降大任于斯人也，必先苦其心志，劳其筋骨，饿其体肤，空乏其身，行弗乱其所为，所以动心忍性，增益其所不能。</p>
<p>意志是可以磨练的，战胜意志，战胜一切。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript高级程序设计三第五章学习笔记]]></title>
      <url>https://zaynex.github.io/2016/07/27/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%89%E7%AC%AC%E4%BA%94%E7%AB%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>对象是某个特定引用类型的实例。新对象是使用new操作符后跟一个构造函数来创建的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var person = new Obejct()；</div></pre></td></tr></table></figure></p>
<p>这段代码创建了Object引用类型的实例，然后把该实例保存在变量person中。使用的构造函数是Obejct,它只为新对象定义了默认的属性和方法。<br>ECMAScript提供了很多原生引用类型(如Obejct)，供开发人员使用。<br><a id="more"></a></p>
<h2 id="Object类型"><a href="#Object类型" class="headerlink" title="Object类型"></a>Object类型</h2><p>我们看到的大多数引用类型值都是Object类型的实例。虽然Obejct的实例不具备多少功能，但对于在应用程序中存储和传输数据，是理想的选择方式。</p>
<h3 id="创建Object方式"><a href="#创建Object方式" class="headerlink" title="创建Object方式"></a>创建Object方式</h3><ol>
<li><p>使用new操作符后跟Obejct构造函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var person = new Obejct();</div><div class="line">person.name = &quot;Zaynex&quot;;</div><div class="line">person.age = 22;</div></pre></td></tr></table></figure>
</li>
<li><p>对象字面量表示法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var person = &#123;</div><div class="line">	name: &quot;Zaynex&quot;,</div><div class="line">	age: 22</div><div class="line">	//不能在age后面加,号</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>使用对象字面量表示法，属性名也可以是字符串。<br>使用数组字面量表示法时，不会调用Array构造函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var person = &#123;</div><div class="line">	&quot;name&quot;: &quot;Zaynex&quot;,</div><div class="line">	&quot;age&quot;: 22,</div><div class="line">	5: true;</div><div class="line">	//不能在5后面加,号</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>这里5的数值属性会被转换为字符串。</p>
<p>也可以使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var person = &#123;&#125;; // 与 new Object()相同</div><div class="line">person.name = &quot;Zaynex&quot;;</div><div class="line">person.age = 22;</div></pre></td></tr></table></figure></p>
<p>访问对象属性的两种方式：</p>
<ol>
<li>alert(person.name);</li>
<li>alert(person[“name”]);</li>
</ol>
<p>第2种方式的好处是可以通过变量访问属性</p>
<p>var propertyName = “name”;<br>alert(person[propertyName]);</p>
<p>如果属性名中包含会导致语法错误的字符或者是属性名使用了关键字或保留字，也可以使用方括号表示法。<br>person[“first name”]= “Zaynex”;<br>这种形式使用点表示法就无法访问了。</p>
<h2 id="Array类型"><a href="#Array类型" class="headerlink" title="Array类型"></a>Array类型</h2><p>ECMAScript数组的每一项都可以保存任何类型的数据。</p>
<h3 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h3><ol>
<li>构造函数法<br>var colors = new Array(20);<br>20这个参数表示数组的长度。<br>也可以直接在Array构造函数中传递包含的项。<br>var colors = new Array(“red”,”blue”,”green”);</li>
<li>省略new操作符<br>var colors = Array();</li>
<li>数组字面量表示法<br>var colors = [“red”,”blue”,”green”];</li>
</ol>
<p>使用数组字面量表示法时，不会调用Array构造函数。（Firebox3及更早除外）</p>
<h4 id="length妙用"><a href="#length妙用" class="headerlink" title="length妙用"></a>length妙用</h4><p>因为数组的length属性不仅仅是只读的。所以可以通过设置这个属性来从数组末尾移除项或者添加新项。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];</div><div class="line">colors.length = 2;</div><div class="line">alert(colors[2]); //undefined</div><div class="line">colors[colors.length] = &quot;green&quot;;</div><div class="line">alert(colors[2]); // green;</div></pre></td></tr></table></figure></p>
<h3 id="检测数组"><a href="#检测数组" class="headerlink" title="检测数组"></a>检测数组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">if(value instanceof Array)&#123;</div><div class="line">	</div><div class="line">&#125;</div><div class="line">if(Array.isArray(value))&#123;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>instanceof  的问题在于，它假定只有一个全局执行环境。如果网页中含有多个框架实际上就存在两个以上的全局执行环境，从而存在两个以上不同版本的Array构造函数。</p>
<p>在ECMAScript5 中新加了Array.isArray(value) 方法。<br>目前在IE9+ Firebox4 Safari5+ Chrome</p>
<h3 id="转换方法-toString"><a href="#转换方法-toString" class="headerlink" title="转换方法 toString()"></a>转换方法 toString()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var colors = [&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;];</div><div class="line">console.log(colors.toString()); // 字符串 red,blue,green</div><div class="line">console.log(colors.valueOf()); // 返回colors的数组 </div><div class="line">console.log(colors); //  数组</div><div class="line">alert(colors);// 字符串red,blue,green</div></pre></td></tr></table></figure>
<p>用alert的时候会在后台调用toString()方法，得到结果与调用 toString()方法相同。<br>toLocaleString()方法也会返回和toString()和valueOf()相同的值。但是如果在函数中定义了该方法，就按照该方法返回值。<br>这3中方法都在默认情况下以逗号分隔的字符串形式返回数组项。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">colors.join(&quot;|&quot;); //使用|分隔符来构建这个字符串, red|blue|green;</div></pre></td></tr></table></figure></p>
<p><strong> 若数组中的某一项值是 null 或者 undefined，则该三种方法返回的结果是以空字符串表示 </strong></p>
<h3 id="栈方法-push-pop"><a href="#栈方法-push-pop" class="headerlink" title="栈方法 push() pop()"></a>栈方法 push() pop()</h3><p>后进先出LIFO<br>push()</p>
<ul>
<li>接受任意参数，向数组末尾添加，数组长度对应相加。<br>pop()</li>
<li>移除数组末尾最后一项，并返回该项的值，数组对应长度-1。</li>
</ul>
<h3 id="队列方法-push-shift"><a href="#队列方法-push-shift" class="headerlink" title="队列方法 push() shift()"></a>队列方法 push() shift()</h3><p>先进先出FIFO——先来排队的先踏上诺亚方舟滚出地球<br>push()</p>
<ul>
<li>接受任意参数，向数组末尾添加，数组长度对应相加。<br>shift()</li>
<li>取得第一项并移除。</li>
</ul>
<h3 id="反向队列-unshift-pop"><a href="#反向队列-unshift-pop" class="headerlink" title="反向队列 unshift() pop()"></a>反向队列 unshift() pop()</h3><p>在数组前端插入，在数组后端移除<br>unshift()</p>
<ul>
<li>在数组前端插入任意项并增加数组长度。<br>pop()</li>
<li>移除数组末尾最后一项，并返回该项的值，数组对应长度-1。</li>
</ul>
<h3 id="重新排序-sort"><a href="#重新排序-sort" class="headerlink" title="重新排序 sort()"></a>重新排序 sort()</h3><p>sort()方法会调用每个数组项的toString()方法将数组中的值转换为字符串，然后比较字符串如何排序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var values = [0,10,5,1,15,20];</div><div class="line">console.log(values.sort());</div><div class="line">// 0,1,10,15,20,5</div></pre></td></tr></table></figure></p>
<p>我们再加一个比较函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function compare(value1, value2) &#123;</div><div class="line">	if(value1 &lt; value2) &#123;</div><div class="line">		return -1;</div><div class="line">	&#125;else if (value1 &gt; value2) &#123;</div><div class="line">		return 1;</div><div class="line">	&#125;else &#123;</div><div class="line">	return 0;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">var values = [0,1,5,10,15,20];</div><div class="line">console.log(values.sort(compare)); // 0,1,5,10,15,20</div></pre></td></tr></table></figure></p>
<p>对于数值类型或者其valueOf()方法会返回数值类型的对象类型，可以直接使用这个简单函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">function compare(value1, value2)&#123;</div><div class="line">	return value2 - value1;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h3><h4 id="contact"><a href="#contact" class="headerlink" title="contact()"></a>contact()</h4><p>用于给数组或字符串拼接，置于原数组末尾。可接受负数。</p>
<h4 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h4><p>在原数组基础上截取部分数组创建新的数组。不会影响原数组<br>如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var myNumber = [1,2,3,4,5];</div><div class="line">var myNumber2 = myNumber.slice(1,3);</div><div class="line">var myNumber3 = myNumber.slice(1);</div><div class="line">console.log(myNumber2); // 2,3</div><div class="line">console.log(myNumber3); // 2,3,4,5</div></pre></td></tr></table></figure></p>
<p>如有负数，则该负数加上数组长度来确定相应位置，如果结束位置小于起始项，则返回空数组。</p>
<h4 id="splice"><a href="#splice" class="headerlink" title="splice()"></a>splice()</h4><ul>
<li>删除    splice(0,2) 删除前2项;</li>
<li>插入    splice(起始位置，0(要删除的项数)，要插入的项);</li>
<li>替换    splice(起始位置，要删除的项数，要插入的项) ;删除的项数未必和插入的项数相同</li>
</ul>
<h3 id="位置方法"><a href="#位置方法" class="headerlink" title="位置方法"></a>位置方法</h3><h4 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf()"></a>indexOf()</h4><p>从数组开头向后查找。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var myNumber = [1,2,3,4,5];</div><div class="line">console.log(myNumber.indexOf(4,3))</div><div class="line">//寻找4，从索引值为3开始找，找到了返回4的索引值</div></pre></td></tr></table></figure></p>
<h4 id="lastIndexOf"><a href="#lastIndexOf" class="headerlink" title="lastIndexOf()"></a>lastIndexOf()</h4><p>从数组末尾开始向前查找。<br>以上两种方法若未找到均会返回 -1；</p>
<h3 id="迭代方法"><a href="#迭代方法" class="headerlink" title="迭代方法"></a>迭代方法</h3><p>在ECMAScript5为数组定义了5个迭代方法。<br>每个方法接受两个参数：</p>
<ul>
<li>要在每一项上运行的函数</li>
<li>运行该函数的作用域对象——影响this的值（可选参数）<br>运行的函数含有三个参数</li>
</ul>
<ol>
<li>数组项的值 item</li>
<li>该项在数组中的位置 index</li>
<li>数组对象本身</li>
</ol>
<h4 id="every"><a href="#every" class="headerlink" title="every()"></a>every()</h4><ul>
<li>对数组中的每一项运行给定的函数，如果该函数对每一项都返回true,则返回true;<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var numbers = [1,2,3,4,5,4,3,2,1];</div><div class="line">var everyResult = numbers.every(function(item, index, array)&#123;</div><div class="line">  return (item&gt;2);</div><div class="line">&#125;);</div><div class="line">alert(everyResult)  // false;</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="filter-常用"><a href="#filter-常用" class="headerlink" title="filter() 常用"></a>filter() 常用</h4><ul>
<li>对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数据;<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var numbers = [1,2,3,4,5,4,3,2,1];</div><div class="line">var everyResult = numbers.filter(function(item, index, array)&#123;</div><div class="line">	return (item&gt;2);</div><div class="line">&#125;);</div><div class="line">alert(everyResult)  //  [3,4,5,4,3]</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="forEach-常用"><a href="#forEach-常用" class="headerlink" title="forEach() 常用"></a>forEach() 常用</h4><ul>
<li>对数组中的每一项运行给定函数，这个方法没有返回值；<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var numbers = [1,2,3,4,5,4,3,2,1];</div><div class="line">var everyResult = numbers.forEach(function(item, index, array)&#123;</div><div class="line">	//执行某些操作</div><div class="line">&#125;);</div><div class="line">alert(everyResult)  //  [2,4,6,8,10,8,6,4,2]</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="map-常用"><a href="#map-常用" class="headerlink" title="map() 常用"></a>map() 常用</h4><ul>
<li>对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组；<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var numbers = [1,2,3,4,5,4,3,2,1];</div><div class="line">var everyResult = numbers.map(function(item, index, array)&#123;</div><div class="line">	return (item*2);</div><div class="line">&#125;);</div><div class="line">alert(everyResult)  //  [2,4,6,8,10,8,6,4,2]</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="some"><a href="#some" class="headerlink" title="some()"></a>some()</h4><ul>
<li>对数组中的每一项运行给定函数，如果该函数对任一项返回true，则返回true    <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var everyResult = numbers.some(function(item, index, array)&#123;</div><div class="line">	return (item&gt;2);</div><div class="line">&#125;);</div><div class="line">alert(everyResult)  // true;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>目前支持浏览器  ie9+,Firefox2+,Safari3+,Opera9.5+，chrome;</p>
<h3 id="归并方法"><a href="#归并方法" class="headerlink" title="归并方法"></a>归并方法</h3><h4 id="reduce-和-reduceRight"><a href="#reduce-和-reduceRight" class="headerlink" title="reduce() 和 reduceRight()"></a>reduce() 和 reduceRight()</h4><p>迭代数组的所有项，构建一个最终返回的值。<br>参数：</p>
<ul>
<li>一个在每一项上调用的函数</li>
<li>作为归并基础的初始值（可选）<br>传入reduce函数的4个参数</li>
</ul>
<ol>
<li>前一个值</li>
<li>当前值</li>
<li>项的索引</li>
<li>数组对象<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var numbers = [1,2,3,4,5,4,3,2,1];</div><div class="line">var sum = numbers.reduce(function(prve,cur,index,array)&#123;</div><div class="line">  return prve + cur;</div><div class="line">&#125;);</div><div class="line">alert(sum);</div></pre></td></tr></table></figure>
</li>
</ol>
<p>这种方法有点类似于函数柯里化。</p>
<h2 id="Date类型"><a href="#Date类型" class="headerlink" title="Date类型"></a>Date类型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var now = new Date();</div><div class="line">console.log(now);</div><div class="line">//Wed Jul 27 2016 20:50:34 GMT+0800 (中国标准时间)</div></pre></td></tr></table></figure>
<p>这显然不是我们想要的时间格式。<br>    var now = new Date();<br>console.log(now);<br>//Wed Jul 27 2016 20:50:34 GMT+0800 (中国标准时间)<br>console.log(now.getFullYear());<br>console.log(now.getMonth());<br>//返回的是当前月份数-1（计算机都是从0开始当第一个月的）<br>console.log(now.getDate());<br>//返回当前月份中的第几天<br>console.log(now.getDay());<br>//返回星期几（注意0是星期天）<br>console.log(now.getHours());<br>console.log(now.getMinutes());<br>console.log(now.getSeconds());<br>console.log(now.getTime());<br>//应该是从1970年1月1日0点到现在的毫秒<br>//返回日期的毫秒数</p>
<h3 id="date获取代码运行时间"><a href="#date获取代码运行时间" class="headerlink" title="date获取代码运行时间"></a>date获取代码运行时间</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var start = Date.now();</div><div class="line">//doSomething();</div><div class="line">var stop = Date.now(),</div><div class="line">	result = stop - start; // 返回毫秒数</div></pre></td></tr></table></figure>
<h3 id="有待补充的点"><a href="#有待补充的点" class="headerlink" title="有待补充的点"></a>有待补充的点</h3><ol>
<li>解决日期和月份以及时间少个0的问题</li>
</ol>
<h2 id="RegExp-类型"><a href="#RegExp-类型" class="headerlink" title="RegExp 类型"></a>RegExp 类型</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>var expression = / pattern / flags ;<br>flag:</p>
<ul>
<li>g:全局模式</li>
<li>i:不区分大小写</li>
<li>m:多行模式</li>
</ul>
<ol>
<li><p>字面量形式表示法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var pattern =  /[bc]at/i</div></pre></td></tr></table></figure>
</li>
<li><p>构造函数表示法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var pattern = new RegExp(&quot;[bc]at&quot;,&quot;i&quot;);</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="正则表达式字面量与构造函数表达式的差异"><a href="#正则表达式字面量与构造函数表达式的差异" class="headerlink" title="正则表达式字面量与构造函数表达式的差异"></a>正则表达式字面量与构造函数表达式的差异</h3><p>使用正则表达式字面量始终都是会共享同一个RegExp实例,而使用构造函数每次创建的新的RegExp实例都是一个新实例。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var re = null,i;</div><div class="line">  for(i=0; i &lt; 10; i++)&#123;</div><div class="line">    re = /cat/g;</div><div class="line">    re.test(&quot;catastrophe&quot;);</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<p>以上是书上提供的例子，我在循环中console.log(re.test(“catastrophe”))，但实际上每次都返回的是true。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var re = null,i;</div><div class="line">  for(i=0; i &lt; 10; i++)&#123;</div><div class="line">    re = /cat/g;</div><div class="line">    re.test(&quot;catastrophe&quot;);</div><div class="line">  &#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var re = null,i;</div><div class="line">  for(i=0; i &lt; 10; i++)&#123;</div><div class="line">    re = new RegExp(&quot;cat&quot;, &quot;g&quot;);</div><div class="line">    console.log(re.test(&quot;catastrophe&quot;));</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>返回结果是一样的的，都是返回10个true。</p>
<h3 id="正则实例方法"><a href="#正则实例方法" class="headerlink" title="正则实例方法"></a>正则实例方法</h3><h4 id="exec"><a href="#exec" class="headerlink" title="exec()"></a>exec()</h4><p>这个不常用，碰到了再补充</p>
<p>正则表达式中的valueOf()会返回正则表达式本身。<br>toString() 以及 toLocaleString() 会返回正则表达式的字面量。<br>var pattern = new RegExp(“\[bc\]at”,”gi”)<br>console.log(pattern.toString());///[bc]at/gi<br>console.log(pattern.toLocaleString()); // /[bc]at/gi</p>
<h2 id="Function类型"><a href="#Function类型" class="headerlink" title="Function类型"></a>Function类型</h2><p>补充：参考函数进阶</p>
<p>函数名仅仅是指向函数的指针，因此函数名与包含对象指针的其他变量没什么不同。即：一个函数可能有多个名字。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function sum(num1, num2)&#123;</div><div class="line">    return num1 + num2;</div><div class="line">&#125;</div><div class="line">alert(sum(10,10)); //20</div><div class="line">var anotherSum = sum;</div><div class="line">alert(anotherSum(10,10));//20</div><div class="line">sum = null;</div><div class="line">alert(anotherSum(10,10));//20</div></pre></td></tr></table></figure></p>
<p>可以理解为：在栈中有两个函数名分别是sum和anotherSum，他们指向同一个堆内存（即该运行函数），即使设置sum为null,anotherSum依然指向该运行函数。<br>把函数名理解为指针，也就明白什么没有函数重载了！</p>
<h3 id="函数声明与函数表达式"><a href="#函数声明与函数表达式" class="headerlink" title="函数声明与函数表达式"></a>函数声明与函数表达式</h3><p>解析器在执行环境中加载数据时，会率先读取函数声明，并使其在执行任何代码之前都可以用;至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真的被执行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">alert(sum(10, 10));</div><div class="line">function sum(num1, num2) &#123;</div><div class="line">	return sum1 + sum2;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>解析器通过函数声明提升的过程，读取并将函数声明添加到执行环境，因此上述代码可以正常运行。<br>对代码求值时，JavaScript引擎在第一遍会声明函数并将它们放到源代码树的顶部。</p>
<p>但是像下面的代码就会出现错误<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">alert(10, 10);</div><div class="line">var sum = function(num1, num2) &#123;</div><div class="line">	return num1 + num2;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="作为值的函数"><a href="#作为值的函数" class="headerlink" title="作为值的函数"></a>作为值的函数</h3><p>ECMAScript中函数名本身就是变量，所以函数也可以作为值来使用。<br>注意，当函数名作为参数的时候，不要加圆括号！</p>
<p>假设有一个对象数组，我们需要根据某个对象属性进行排序。而传递给数组sort()的比较函数要接受两个参数，即要比较他们的值。<br>但是我们需要一种方式来指明按照哪个属性来排序。<br>要解决这个问题，可以定义一个函数：<br><strong> 它接受一个属性名，然后根据该属性名来创建一个比较函数。 </strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">function createComparisonFunction(propertyName) &#123;</div><div class="line">	return function(object1, object2) &#123;</div><div class="line">	var value1 = object1[propertyName];</div><div class="line">	var value2 = object2[propertyName];</div><div class="line"></div><div class="line">	if (value1 &lt; value2) &#123;</div><div class="line">		return -1;</div><div class="line">	&#125; else if (value1 &gt; value2)&#123;</div><div class="line">		return 1;</div><div class="line">	&#125; else &#123;</div><div class="line">		return 0;</div><div class="line">	&#125;</div><div class="line">	&#125;;</div><div class="line">&#125;</div><div class="line">var data = [&#123;name: &quot;Zaynex&quot; ,age: 26&#125;,&#123;name: &quot;Nicholas&quot;, age:30&#125;];</div><div class="line">data.sort(createComparisonFunction(&quot;name&quot;));  // Nicholas</div><div class="line">alert(data[0].name);</div><div class="line">data.sort(createComparisonFunction(&quot;age&quot;)); // 26</div><div class="line">alert(data[0].age);</div></pre></td></tr></table></figure></p>
<p>这段代码返回的是在函数中嵌套了另一个函数，而且内部函数前面加了return 操作符。在内部函数接受到propertyName参数后，它会使用方括号表示法取得给定属性的值。</p>
<h3 id="函数内部属性"><a href="#函数内部属性" class="headerlink" title="函数内部属性"></a>函数内部属性</h3><p>函数内部有两个特殊的对象： this 和 arguments。<br>虽然arguments的主要用途是保存函数参数，但这个对象还有一个叫callee的属性，该属性是一个指针，指向arguments对象的函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function factorial(num)&#123;</div><div class="line">	if(num &lt; 1)&#123;</div><div class="line">		return 1;</div><div class="line">	&#125;else &#123;</div><div class="line">		return num * factorial(num-1);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>此时函数名和执行函数名紧紧耦合在一起，为了消除耦合现象，我们可以使用arguments.callee。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function factorial(num)&#123;</div><div class="line">	if(num &lt; 1)&#123;</div><div class="line">		return 1;</div><div class="line">	&#125;else &#123;</div><div class="line">		return num * arguments.callee(num-1);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">var trueFactorial = factorial;</div><div class="line"></div><div class="line">factorial = function() &#123;</div><div class="line">	return 0;</div><div class="line">&#125;;</div><div class="line">alert(trueFactorial(5));  //120 		使用arguments.callee后不会受到原函数名影响</div><div class="line">alert(factorial(5));    //0</div></pre></td></tr></table></figure></p>
<p>如果不这么做的话，你回头看看Function这节开头，看看刚才这段函数会发生什么。</p>
<h3 id="caller"><a href="#caller" class="headerlink" title="caller"></a>caller</h3><p>该属性保存着调用当前函数的函数的引用，返回的是整串代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function outer()&#123;</div><div class="line">  inner();</div><div class="line">&#125;</div><div class="line">function inner()&#123;</div><div class="line">  alert(inner.caller);</div><div class="line">&#125;</div><div class="line">outer();</div><div class="line">//function outer()&#123;inner();&#125;</div></pre></td></tr></table></figure></p>
<h3 id="函数属性和方法"><a href="#函数属性和方法" class="headerlink" title="函数属性和方法"></a>函数属性和方法</h3><p>属性：length\prototype<br>prototype保存了所有实例方法，不可枚举。因此for-in是无法发现的。</p>
<p><strong> 对于ECMAScript中的引用类型而言，peopertype保存的是它们所有实例方法的真正所在。toString()和valueOf()等方法都在它名下，只不过是通过各自的对象的实例访问罢了。 </strong></p>
<h4 id="apply"><a href="#apply" class="headerlink" title="apply()"></a>apply()</h4><p>每个函数内部都包含这2个方法。它们的用途是在特定的作用于中调用函数，实际上就是设置函数体内this对象的值。</p>
<p>apply()每个方法接受两个参数：</p>
<ol>
<li>在其中运行函数的作用域</li>
<li>参数数组，可以是Array的实例，也可以是arguments对象<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function  sum(num1, num2) &#123;</div><div class="line">	return num1 + num2;</div><div class="line">&#125;</div><div class="line">function callSum1(num1, num2) &#123;</div><div class="line">	return sum.apply(this, arguments);</div><div class="line">&#125;</div><div class="line">function callSum2(num1, num2) &#123;</div><div class="line">	return sum.apply(this, [num1, num2]);</div><div class="line">&#125;</div><div class="line">alert(callSum1(10, 10));</div><div class="line">alert(callSum2(10, 10));</div></pre></td></tr></table></figure>
</li>
</ol>
<p>上述代码中，callSum()在执行sum()函数时传入了this 作为 this值。（因为是在全局作用域中调用的，所以传入的是window对象）和arguments对象。</p>
<p>在严格模式下， 未指定环境对象而调用函数，则this值不会会转化为window,除非明确把函数添加到某个对象或者调用call()或apply()，否则this值将是undefined。</p>
<h4 id="call"><a href="#call" class="headerlink" title="call()"></a>call()</h4><p>call()作用和apply()相同，只是call的第二个参数要全都写出来。apply()就可以直接传数组。</p>
<h4 id="扩充函数作用域"><a href="#扩充函数作用域" class="headerlink" title="扩充函数作用域"></a>扩充函数作用域</h4><ul>
<li>apply()和call()强大的地方在于扩充作用域。<br>我们先来看这个例子<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">window.color = &quot;red&quot;;</div><div class="line">var o = &#123;color: &quot;blue&quot; &#125;;</div><div class="line"></div><div class="line">function sayColor()&#123;</div><div class="line">	alert(this.color);</div><div class="line">&#125;</div><div class="line"></div><div class="line">sayColor();    //red</div><div class="line">sayColor.call(this) ;   //red</div><div class="line">sayColor.call(window);  //red</div><div class="line">sayColor.call(o);  //blue</div></pre></td></tr></table></figure>
</li>
</ul>
<p>运行到sayColor.call(o)时函数执行环境不一样了，因此此时this指向了o，于是显示的是 o中的color属性。<br>不理解的话，咱们来还原下这段代码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">window.color = &quot;red&quot;;</div><div class="line">var o = &#123;color: &quot;blue&quot; &#125;;</div><div class="line"></div><div class="line">function sayColor()&#123;</div><div class="line">	alert(this.color); // </div><div class="line">&#125;</div><div class="line">sayColor();    //red</div><div class="line">sayColor.call(this) ;   //red 此时this指向全局变量的window</div><div class="line">sayColor.call(window);  //red 此时this指向全局变量的window</div><div class="line">o.sayColor = sayColor;</div><div class="line">o.sayColor(); // blue 此时this指向o</div></pre></td></tr></table></figure></p>
<p>使用call()和apply()的好处就是对象不需要与方法有任何耦合关系。<br>此外，我们还有bind方法</p>
<h4 id="bind-方法"><a href="#bind-方法" class="headerlink" title="bind()方法"></a>bind()方法</h4><p>该方法，会创建一个函数的实例，其this值会被绑定传到bind()函数的值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">window.color = &quot;red&quot;;</div><div class="line">var o = &#123;color: &quot;blue&quot; &#125;;</div><div class="line"></div><div class="line">function sayColor()&#123;</div><div class="line">  alert(this.color); // </div><div class="line">&#125;</div><div class="line">var objectSayColor = sayColor.bind(o);</div><div class="line">objectSayColor();</div></pre></td></tr></table></figure></p>
<h2 id="基本包装类型"><a href="#基本包装类型" class="headerlink" title="基本包装类型"></a>基本包装类型</h2><p>ECMAScript提供了特殊的引用类型： Boolean\Number\String<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var  s = &quot;some text&quot;;</div><div class="line">var s2 =s.substring(2);</div><div class="line">alert(s2); //e text</div></pre></td></tr></table></figure></p>
<p>引用类型和基本包装类型的主要区别就是<strong> 对象的生存周期。 </strong><br>使用new操作符创建的引用类型的实例，在执行刘离开当前作用域之前都一直保存在内存中。<br>而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var s1= &quot;Some text&quot;;</div><div class="line">s1.color = &quot;red&quot;;</div><div class="line">alert(s1.color);  //undefined</div></pre></td></tr></table></figure></p>
<p>第二行创建的string对象在执行第三行代码时已经被销毁了。<br><strong> 第三行代码有创建了自己的String对象，而该对象没有color属性。 </strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var str = new String(&quot;some text&quot;);</div><div class="line">var str2 = str.substing(2);</div><div class="line">str = null;</div></pre></td></tr></table></figure></p>
<ol>
<li>创建基本包装类型的一个实例  </li>
<li>在实例上调用指定的方法    </li>
<li>销毁这个实例<br>对于基本包装类型的实例调用typeof会返回”Object” ,而所有基本包装类型的对象都会被转为布尔值 true.</li>
</ol>
<h3 id="三种基本包装类型"><a href="#三种基本包装类型" class="headerlink" title="三种基本包装类型"></a>三种基本包装类型</h3><p>Boolean ,Number , String<br>基本包装类型和使用new操作符调用基本包装类型的构造函数是不同的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">var value = &quot;25&quot;;</div><div class="line">var number = Number(value); // 转型函数，Number类型</div><div class="line">alert(typeof number);  // &quot;number&quot;</div><div class="line">var obj = new Number(value); // 构造函数</div><div class="line">alert(typeof obj); // &quot;object&quot; </div><div class="line"></div><div class="line"></div><div class="line">### Boolean类型</div><div class="line">布尔表达式中所有对象都会被转化成true;</div><div class="line"></div><div class="line"></div><div class="line">### Number类型</div><div class="line">var num = 10.005;</div><div class="line">alert(num.toFixed(2));  //10.01</div><div class="line">四舍五入，但IE9之前是不行的</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">### String字符串</div><div class="line">#### 字符方法</div><div class="line">	charAt() 以单字符串形式返回给定位置的那个字符；</div></pre></td></tr></table></figure></p>
<p>var stringValue = “hello world”;<br>alert(stringValue.charAt(1)); // “e”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">charCodeAt() 以字符编码返回给定位置的那个字符；</div></pre></td></tr></table></figure></p>
<p>var stringValue = “hello world”;<br>alert(stringValue.charAt(1)); // “101”小写字母e的字符编码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#### 字符位置方法</div><div class="line">##### indexOf() 返回该字符在字符串中的位置，没找到返回-1</div><div class="line">##### lastIndexOf()  从末尾开始搜索；</div><div class="line">当存在两个参数后，indexOf(&quot;o&quot;,6);indexOf从第六个位置之后向后搜索，lastIndexOf(&quot;o&quot;,6)则在6前开始搜索</div></pre></td></tr></table></figure></p>
<p>var stringValue = “shidhskfsdfjklsjfkl sdkl;fjkdsl;jfkdsl;jf”;<br>var positions = new Array();<br>var pos = stringValue.indexOf(“e”);<br>while(pos&gt;-1){<br>    positions.push(pos);<br>    pos = stringValue.indexOf(“e”,pos+1); //每次从已经找到后的位置开始寻找<br>}<br>alert(positions);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">### 字符串方法</div><div class="line">	contact() 字符串拼接，但实际上还是用 + 比较多。</div><div class="line">slice()和substring()都可以接受两个参数：</div><div class="line">1. 表示起始位置</div><div class="line">2. 表示字符串最后一个字符后面的位置</div><div class="line">substr()接受两个参数：</div><div class="line">1. 起始起始位置</div><div class="line">2. 表示获取字符串长度</div><div class="line">如果上述方法都没有第二个参数，那就默认字符串长度为第二个参数</div><div class="line">```	</div><div class="line">var stringValue = &quot;hello world&quot;;</div><div class="line">console.log(stringValue.slice(3)); //lo world</div><div class="line">console.log(stringValue.substring(3));//lo world</div><div class="line">console.log(stringValue.substr(3));//lo world</div><div class="line">console.log(stringValue.slice(3,7)); //lo w 第二个参数表示结束范围</div><div class="line">console.log(stringValue.substring(3,7));//lo w</div><div class="line">console.log(stringValue.substr(3,7));//lo worl 第二个参数表示返回的个数</div></pre></td></tr></table></figure></p>
<p>如果参数中有负数，substring()会将所有负数转化为0；substr()会将第二个负数转换为0；slice()会加上字符串长度<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var  demo = &apos;hello world&apos;;</div><div class="line">alert(demo.substr(3,-4)); // &apos;&apos;</div><div class="line">alert(demo.substring(3,-4)); //hel 注意下 ，</div></pre></td></tr></table></figure></p>
<p>这个方法会将较小的数作为起始位置，较大的数作为结束位置；</p>
<p>IE中JS处理 substr()方法传递负值时存在问题，它会返回原始字符串，IE9修复了这个问题</p>
<h3 id="trim-方法"><a href="#trim-方法" class="headerlink" title="trim()方法"></a>trim()方法</h3><p>创建一个字符串的副本删除前置和后缀的所有空格</p>
<h3 id="字符串大小写转换"><a href="#字符串大小写转换" class="headerlink" title="字符串大小写转换"></a>字符串大小写转换</h3><p>toLocalUpperCase() 大写  特定方法<br>toUpperCase()  大写  常用方法<br>toLocalLowerCase() 小写<br>toLowerCase() 小写</p>
<h3 id="字符串的模式匹配方法"><a href="#字符串的模式匹配方法" class="headerlink" title="字符串的模式匹配方法"></a>字符串的模式匹配方法</h3><h4 id="match"><a href="#match" class="headerlink" title="match()"></a>match()</h4><p>只接受一个参数：正则表达式或RegExp对象。<br>对应返回的是与正则表达式中所捕获组相匹配的字符串或者是得到相同的数组。</p>
<h4 id="replace"><a href="#replace" class="headerlink" title="replace()"></a>replace()</h4><p>接受两个参数：</p>
<ol>
<li>RegExp的对象或者是一个字符串</li>
<li>一个字符串或者是一个函数；如果是字符串，则会替换第一个子字符串，如果是函数，则在函数中返回相应的结果<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">var text = &quot;cat,bat,sat,fat&quot;;</div><div class="line">var result = text.replace(&quot;at&quot;, &quot;ond&quot;);</div><div class="line">console.log(result); //cond,bat,sat,fat</div><div class="line"></div><div class="line">result = text.replace(/at/g, &quot;ond&quot;);</div><div class="line">console.log(result); //cond,bond,sond,fond</div></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="split"><a href="#split" class="headerlink" title="split()"></a>split()</h4><ul>
<li>基于指定分隔符将一个字符串分割成多个字符串，并将结果保存在数组中。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var colorText = &quot;red,blue,yellow,greed&quot;;</div><div class="line">var colors1 = colorText.split(&quot;,&quot;);</div><div class="line">var colors2 = colorText.split(&quot;,&quot;,2);</div><div class="line">var colors3 = colorText.split(/[^\,]+/);</div><div class="line">console.log(colors1); //[&quot;red&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;greed&quot;]</div><div class="line">console.log(colors2);//[&quot;red&quot;, &quot;blue&quot;]</div><div class="line">console.log(colors3);//[&quot;&quot;, &quot;,&quot;, &quot;,&quot;, &quot;,&quot;, &quot;&quot;]</div></pre></td></tr></table></figure>
</li>
</ul>
<p>如果需要截取长度，就在第二个参数中传入一个数值。<br>至于colors3的值出现了两个空字符串，是因为通过正则表达式指定的分隔符出现在了字符串的开头。</p>
<h2 id="单体内置对象"><a href="#单体内置对象" class="headerlink" title="单体内置对象"></a>单体内置对象</h2><p>由ECMAScript实现提供的，不依赖于宿主环境的对象，这些对象在ECMAScript程序执行之前就存在了。<br>有Object、Array、String、Global、Math.</p>
<h3 id="Global对象"><a href="#Global对象" class="headerlink" title="Global对象"></a>Global对象</h3><p>事实上，没有全局变量或全局函数，所有全局作用域中定义的属性和函数都是Global对象的属性。</p>
<h4 id="URL编码方法"><a href="#URL编码方法" class="headerlink" title="URL编码方法"></a>URL编码方法</h4><p>Uniform Resource Identifiers,通用资源标识符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var uri= &quot;http://ife.baidu.com/task/detail?taskId=19&quot;;</div><div class="line">console.log(encodeURI(uri)); //http://ife.baidu.com/task/detail?taskId=19</div><div class="line">console.log(encodeURIComponent(uri));//http%3A%2F%2Fife.baidu.com%2Ftask%2Fdetail%3FtaskId%3D19</div></pre></td></tr></table></figure></p>
<p>使用encodeURIComponent()会使用对应的编码替换所有非字母数字字符。一般我们用这个比较多，而且在实践中更常见的是对查询字符串参数而不是对基础URI进行编码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var uri = &quot;http%3A%2F%2Fife.baidu.com%2Ftask%2Fdetail%3FtaskId%3D19&quot;;</div><div class="line">console.log(decodeURI(uri));</div><div class="line">//http%3A%2F%2Fife.baidu.com%2Ftask%2Fdetail%3FtaskId%3D19</div><div class="line">console.log(decodeURIComponent(uri));//</div><div class="line">http://ife.baidu.com/task/detail?taskId=19</div></pre></td></tr></table></figure></p>
<h4 id="eval"><a href="#eval" class="headerlink" title="eval()"></a>eval()</h4><p>eval() 就像ECMAScript解析器。它只接受一个参数，即要执行的ECMAScript字符串,把要传入的参数当作语句去解析。<br>严格模式下，在外部访问不到eval()。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">eval(&quot;alert(&apos;hi!&apos;)&quot;);</div><div class="line">就等于</div><div class="line">alert(&quot;hi!&quot;);</div><div class="line"></div><div class="line">因为强大，所以要小心使用，会被代码注入。</div><div class="line"></div><div class="line">在所有代码执行前，作用域中就已经存在两个内置对象：Global 和 Math。  在大多数ECMAScript实现中都不能直接访问Global对象，不过web浏览器实现了承担该角色的window对象。全局变量和函数都是Global对象的属性。</div><div class="line">### Math 方法</div></pre></td></tr></table></figure></p>
<p>alert(Math.ceil(27.9));  //28<br>alert(Math.ceil(27.1));  //28</p>
<p>alert(Math.floor(27.1)); //27<br>alert(Math.floor(27.9)); //27</p>
<p>alert(Math.round(27.1)); //27<br>alert(Math.round(27.9)); //28<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#### random()</div><div class="line">Math.random() 生成随机数x (0 &lt;= x &lt;1)</div><div class="line">生成1到10的整数</div></pre></td></tr></table></figure></p>
<p>var num = Math.floor(Math.random() * 10 + 1); //floor向下取整<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">```</div><div class="line">//生成某区间的随机数</div><div class="line">function selectForm(lowerValue, upperValue)&#123;</div><div class="line">  var choices = upperValue - lowerValue;</div><div class="line">  return Math.floor(Math.random()*choices + lowerValue);</div><div class="line">&#125;</div><div class="line">var num = selectForm(2,10);</div></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript高级程序设计三第四章学习笔记]]></title>
      <url>https://zaynex.github.io/2016/07/27/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%89%E7%AC%AC%E5%9B%9B%E7%AB%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<p>ECMAScript 变量包含两种不同数据类型的值：基本类型值和引用类型值。<br>第三章讨论了基本5种数据类型 Undefined、Null、Boolean、Number、String。<br><a id="more"></a></p>
<h2 id="基本类型和引用类型值"><a href="#基本类型和引用类型值" class="headerlink" title="基本类型和引用类型值"></a>基本类型和引用类型值</h2><p>这5种基本数据类型是按值访问的。引用类型值是指可能由多个值构成的对象。在将一个值赋值时，解析器必须确定这个值是基本类型还是引用类型值。</p>
<p>引用类型的值是保存在内存中的对象。与其他语言不同，JavaScript不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间。</p>
<p>当复制保存着对象的某个变量时，操作的是对象的引用。但在为对象添加属性时，操作的是实际的对象。<br>在很多语言中，字符串以对象的形式来表示，因此被认为是引用类型的，但ECMAScript抛弃了这一传统。</p>
<h3 id="动态的属性"><a href="#动态的属性" class="headerlink" title="动态的属性"></a>动态的属性</h3><p>对于引用类型的值，我们可动态的添加属性和方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var person = new Object();</div><div class="line">person.name = &quot;Zaynex&quot;;</div><div class="line">alert(person.name);</div></pre></td></tr></table></figure></p>
<p>对于基本类型值，则不可以<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var name = &quot;Zaynex&quot;;</div><div class="line">name.age = &quot;29&quot;;</div><div class="line">alert(name.age);  //undefined</div></pre></td></tr></table></figure></p>
<p>在给基本类型赋值时，两个变量不会相互影响；<br>var num1 = 5;<br>var num2 = num1;<br>num1 和 num2的值相互独立，num2的值只是num1中5的一个副本。</p>
<p>当从一个变量向另一个变量复制引用类型的值时，同样也会将存储在变量对象中的值复制一份放到新变量分配的空间中。不同的是，这个值的副本实际是一个指针，而这个指针指存储在堆中的一个 对象。</p>
<h3 id="复制变量值"><a href="#复制变量值" class="headerlink" title="复制变量值"></a>复制变量值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var obj1 = new Object();</div><div class="line">var obj2 = obj1;</div><div class="line">obj1.name = &quot;Zaynex&quot;;</div><div class="line">alert(obj2.name);</div></pre></td></tr></table></figure>
<p>复制引用类型的值时，同时也会将存储在变量对象中的值也复制一份放到新变量分配的空间中。<br>不过这个值的副本实际上是一个指针，指向存储在堆中的一个对象。复制操作结束后，两个变量实际上引用同一个对象。</p>
<h3 id="函数传参"><a href="#函数传参" class="headerlink" title="函数传参"></a>函数传参</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var count = &#123;a:1,b:1&#125;;</div><div class="line">var addOne = function(obj) &#123;</div><div class="line">  obj.a += 1;</div><div class="line">  obj.b += 1;</div><div class="line">  return obj;</div><div class="line"> &#125;</div><div class="line"> var ret = addOne(count);</div><div class="line"> console.log(ret); // a:2,b:2</div><div class="line"> console.log(count); // a:2,b:2</div></pre></td></tr></table></figure>
<p>因为ret和count共享的是同一个堆内存，<strong> 所以他们是按共享传递的。（注意，不是按引用传递） </strong></p>
<p>为什么不是按引用传递?<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var count = &#123;a:1,b:1&#125;;</div><div class="line">var addOne = function(obj) &#123;</div><div class="line"> obj = &#123;a:2, b:2&#125;;</div><div class="line"> return obj;</div><div class="line">&#125;</div><div class="line">var ret = addOne(count);</div><div class="line">console.log(ret); // a:2,b:2</div><div class="line">console.log(count); // a:1,b:1</div></pre></td></tr></table></figure></p>
<p> 如果count是按引用传递的，那么count会自动被修改为obj的新对象。</p>
<p> 这说明在函数内部修改了参数的值，但原始的引用任然保持不变。<br> 实际上，在重写obj的时候，这个变量引用的就是一个局部对象了。而这个局部对象会在函数执行完毕后立即销毁。</p>
<p> <strong> 我们可以把ECMAScript函数的参数想象成局部变量。</strong></p>
<h3 id="检测类型"><a href="#检测类型" class="headerlink" title="检测类型"></a>检测类型</h3><p>这一章节在原先的笔记中有详细的记录。<br>基本类型值在内存中占据固定大小的空间，因此保存在栈内存中。<br>引用类型值是对象，保存在堆内存中。</p>
<h2 id="执行环境及作用域"><a href="#执行环境及作用域" class="headerlink" title="执行环境及作用域"></a>执行环境及作用域</h2><p>执行环境（execution context)</p>
<ul>
<li>定义了变量或函数有权访问的其他数据，决定了他们各自的行为。</li>
<li>每个执行环境都有一个与之关联的变量对象(variable object),环境中定义的所有变量和函数都保存在这个对象中，解析器在处理数据时会在后台使用它。</li>
</ul>
<p><strong> 每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入到一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。 </strong><br>（这段话太重要了！）</p>
<h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p>当代码在一个环境执行时，会创建变量对象的一个作用域链(scope chain)。<br>用途：保证对执行环境有权访问的所有变量和函数的有序访问（是有序访问，说明是有顺序的）</p>
<p>作用域链的前端，始终都是当前执行的代码所在环境的变量对象。<br>如果这个环境是函数，则将其活动对象（activation object）作为变量对象。活动对象一开始只包含一个变量，arguments对象（在全局环境中不存在）。</p>
<p>作用域链中的下一个变量对象来自包含（外部）环境，再下一个变量对象来自下一个包含环境。这样，一直延续到全局执行环境；全局执行环境的变量对象始终都是作用域链中的最后一个对象。</p>
<h3 id="标识符解析"><a href="#标识符解析" class="headerlink" title="标识符解析"></a>标识符解析</h3><p>沿着作用域链以及一级地搜索标识符的过程。搜索过程从作用域链的前端开始，然后逐级向后回溯。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var person = &#123;name:&quot;刘德华&quot;, age:50&#125;;</div><div class="line">(function()&#123;</div><div class="line">	var person = &#123;name:&quot;刘德华&quot;, age:30&#125;;</div><div class="line">	(function()&#123;</div><div class="line">		//var person = &#123;name:&quot;刘德华&quot;, age:10&#125;;</div><div class="line">		console.log(person.name + person.age + &quot;岁&quot;);</div><div class="line">	&#125;)()</div><div class="line">&#125;)();</div><div class="line">//刘德华30岁</div></pre></td></tr></table></figure></p>
<p>以上是一个匿名函数里还有匿名函数，它的好处就是可以立即执行，并且匿名函数中的作用域在函数执行完之后就销毁，不会影响到外部作用域。所以你不至于给每个函数都要取a-z各种变量名生怕重复定义了。<br>根据标识符解析，先看看内部环境是否有person，如果没有，再进行到外部，外部有一个30岁的刘德华，如果外部没有，那么就访问到全局变量刘德华。</p>
<p>有意思的是，内部环境可以通过作用域链访问外部环境，但是外部环境不能通过作用域链访问内部环境。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">var person = &#123;name:&quot;刘德华&quot;, age:50&#125;;</div><div class="line">(function()&#123;</div><div class="line">  var person = &#123;name:&quot;刘德华&quot;, age:30&#125;;</div><div class="line">  console.log(person2.name + person2.age + &quot;岁&quot;);</div><div class="line">  //Uncaught ReferenceError: person2 is not defined</div><div class="line">  (function()&#123;</div><div class="line">    var person2 = &#123;name:&quot;Zaynex&quot;,age:22&#125;;</div><div class="line">    //var person = &#123;name:&quot;刘德华&quot;, age:10&#125;;</div><div class="line">    console.log(person.name + person.age + &quot;岁&quot;);</div><div class="line">  &#125;)()</div><div class="line">&#125;)();</div><div class="line">//刘德华30岁</div></pre></td></tr></table></figure></p>
<p>我们在第一个匿名函数中调用person2，但是person2是定义在第二个匿名函数内的。根据上述原则，外部匿名函数无法访问内部匿名函数，因此person2找不到，系统自然就报错啦。</p>
<h3 id="延长作用域链"><a href="#延长作用域链" class="headerlink" title="延长作用域链"></a>延长作用域链</h3><ol>
<li>try-catch语句中的 catch语句块</li>
<li>with语句</li>
</ol>
<p>对于with来说，会将制定的对象添加到作用域链中。<br>对于catch来说，会创建一个新的变量对象，其中包含的是被抛出错误对象的声明。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">function buildUrl() &#123;</div><div class="line">	var qs = &quot;?debug=true&quot;;</div><div class="line"></div><div class="line">	with(location) &#123;</div><div class="line">		var url = href + qs;</div><div class="line">	&#125;</div><div class="line">	return url;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>with接受的是location对象，因此其变量对象就包含了location的所有属性和方法。代码就类似于：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var url = location.href + location.qs</div></pre></td></tr></table></figure></p>
<p>但在严格模式下不允许有with语句，否则视为语法错误。<br>因为with会降低性能，with中的代码块内部，每个变量被认为是局部变量，如果在局部环境中找不到该变量的定义，就会查找location对象中是否含有同名属性。也会给调试代码增加困难。</p>
<h3 id="没有块级作用域"><a href="#没有块级作用域" class="headerlink" title="没有块级作用域"></a>没有块级作用域</h3><p>块级作用域就是{…}花括号里面的作用域。<br>一般而言，我们会以为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">if(true)&#123;</div><div class="line">	var color = &quot;blue&quot;;</div><div class="line">&#125;</div><div class="line">alert(color);</div></pre></td></tr></table></figure></p>
<p>在类C语言中，if内的{}执行完毕后会被立即销毁，但JavaScript中，if语句变量声明会将变量添加到当前的执行环境（在这里是全局环境）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">for(var i=0;i&lt;10;i++)&#123;</div><div class="line">	doSomething(i);</div><div class="line">&#125;</div><div class="line">alert(i); // 10;</div></pre></td></tr></table></figure></p>
<p><strong> 对于有块级作用域的语言来说，for语句总初始化变量的表达式所定义的变量，只会存在循环中，但是对于JS，即使 i循环结束后，依然存在循环外部的执行环境. </strong></p>
<h4 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h4><p>使用var 声明的变量会自动被添加到最接近的环境中。在函数内部，最接近的就是函数环境。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function add(num1, num2)&#123;</div><div class="line">	var sum = num1 + num2;</div><div class="line">	return sum;</div><div class="line">&#125;</div><div class="line">var result = add(1,2); // 3</div><div class="line">alert(sum); // 由于sum不是有效变量，因此会导致错误</div></pre></td></tr></table></figure></p>
<p>如果你想要访问sum，那么你就需要在函数外部定义 sum,或者在函数内部不用var，把sum当作全局变量。但并不推荐设置为全局变量。<br>建议在初始化变量之前，一定要先声明。此外，在严格模式下，初始化未经声明的变量会导致错误。</p>
<h4 id="查询标识符"><a href="#查询标识符" class="headerlink" title="查询标识符"></a>查询标识符</h4><p>访问局部变量要比访问全局变量快，因为不用向上搜索作用域链。</p>
<h2 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h2><p>函数中的局部变量都有正常的生命周期。局部变量只在函数执行时存在。而这个过程，会为局部变量在栈（或堆）上分配相应的空间，以便存储他们的值。在函数执行完毕，释放它们的内存，功德圆满。</p>
<h3 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h3><p>垃圾收集器在运行时给存储在内存中的所有变量加上标记。然后去掉环境中的变量以及被环境中的变量引用的变量的标记。而在之后再被加上标记的变量被认为准备删除的变量。</p>
<h3 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h3><p>跟踪记录每个值被引用的次数。声明一个变量并将一个引用类型复制给变量时，这个值的引用次数为1。如果同一个值又被赋值给另一个变量，则该值引用次数+1。相反，<br>如果包含对这个值的引用的变量又取得了另外一个值，则这个值的引用次数-1。当引用次数为0时，没办法再访问这个值，于是清除引用次数为0的值所占用的内存。</p>
<h4 id="引用计数的坑"><a href="#引用计数的坑" class="headerlink" title="引用计数的坑"></a>引用计数的坑</h4><p>循环引用——是指对象A包含一个指向对象B的指针，对象B中也包含一个指向对象A的引用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function problem()&#123;</div><div class="line">	var objectA = new Object();</div><div class="line">	var objectB = new Object();</div><div class="line">	objectA.someOtherObject = objectB;</div><div class="line">	objectB.someOtherObject = objectA;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>他们之间相互引用，引用次数都是2，永远不会被清除内存。</p>
<p>为了避免循环引用问题，我们要手工断开他们之间的链接,解除引用。<br>objectA.someOtherObject = null;<br>objectB.someOtherObject = null;</p>
<p><strong> 解除一个值的引用并不意味着自动回收该值占用的内存，而是让值脱离执行环境，以便垃圾收集器下次运行时回收内存。
</strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript高级程序设计三第三章学习笔记]]></title>
      <url>https://zaynex.github.io/2016/07/27/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E4%B8%89%E7%AC%AC%E4%B8%89%E7%AB%A0%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h2 id="数据类型和操作符"><a href="#数据类型和操作符" class="headerlink" title="数据类型和操作符"></a>数据类型和操作符</h2><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><p>typeof是字符串。<br>调用typeof null 会返回 “object”，因为特殊值null被认为是一个空的对象引用。<br>typeof也可以检测”function”<br>Safari5及之前版本、Chrome7及之前在对正则表达式调用typeof会返回 “function”</p>
<p>对未初始化的变量执行typeof操作符会返回undefined，对已初始化但未声明的变量执行typeof也会返回undefined.因此，建议显式初始化变量。</p>
<p>undefined 是派生自 null 的，因此ECMA-262规定<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">alert(null == undefined);//true;</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>无论在什么情况下都没必要把一个变量的值显式设置为 undefined,但对一个保存对象的变量而言，就应该明确让该变量保存null值。</p>
<h3 id="Boolean类型"><a href="#Boolean类型" class="headerlink" title="Boolean类型"></a>Boolean类型</h3><p>Boolean类型的字面量true 和 false 是区分大小写的。也就是说，True 和 False（以及其他的混合大小写形式）都不是Boolean值，只是标识符。</p>
<h3 id="Number-类型"><a href="#Number-类型" class="headerlink" title="Number 类型"></a>Number 类型</h3><p>八进制字面量第一位必须是0，然后是八进制数组序列0-7.如果字面值中数值超过这一范围，那么前导0将被忽略，后面的数值将当作十进制解析。<br>八进制字面量在严格模式下是无效的。</p>
<p>浮点数值保存空间是整数内存的两倍，ECMAScript会将浮点数值转换为整数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var floatName = 1.0; // 1</div></pre></td></tr></table></figure></p>
<p>永远不要测试特定的浮点数值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">console.log(0.1+0.2);</div><div class="line">		// 不要这样做，0.1+0.2会得到0.30000000000000004的结果</div></pre></td></tr></table></figure></p>
<p>这是基于IEEE754数值的浮点计算通病，ECMAScript并非独此一家，相同数值格式的语言都有这个问题。</p>
<p>JS中最小数值Number.MIN_VALUE:是5e-324;<br>最大数值Number.MAX_VALUE:1.7976931348623157e+308<br>超过这个范围就会转换成特殊的Infinity值。（分正负）</p>
<p>NaN 任何涉及到NaN的运算都是NaN,可以使用isNaN()函数来判定是否为数值。</p>
<ol>
<li>0/0 === NaN(Not a Number)</li>
<li>1/0 === Infinity </li>
<li>-1/0 === -Infinity</li>
</ol>
<p>isNaN() 适用于对象。首先会调用对象的 valueOf() 方法，然后确定该方法返回的值是否可以转换为数值。如果不能，再基于这个返回值调用 toString() 方法。</p>
<h3 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h3><ol>
<li>Boolean 可以转为1或0；</li>
<li>如果是数字，就是简单传入和返回;</li>
<li>如果是Null,则返回0；</li>
<li>如果是undefined，返回NaN;</li>
<li>如果是字符串，数字字符串成为数字，前面有0的话也会去掉。如果是对象，则先调用valueOf()方法，如果是Null，则调用对象的toString()方法；</li>
</ol>
<h4 id="parseInt"><a href="#parseInt" class="headerlink" title="parseInt()"></a>parseInt()</h4><ul>
<li>可以本质上解析数字字符，因此如果带有小数点的数字从小数点开始不会解析，往小取整。可以解析8位，16位等，由于不同版本JS引擎解析不同，因此最好都明确指定基数，如<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">parseInt(&quot;1001002&quot;, 10);</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="parseFloat"><a href="#parseFloat" class="headerlink" title="parseFloat()"></a>parseFloat()</h4><ul>
<li>与parseInt类似，不过只是解析到第二个小数点就不再解析，且仅能解析10位。</li>
</ul>
<h3 id="字符串的特点"><a href="#字符串的特点" class="headerlink" title="字符串的特点"></a>字符串的特点</h3><p>字符串一旦创建，他们的值就不能改变。要改变原来的字符串，就要先销毁原来的字符串，然后再用另一个包含新值的字符串填充该变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var lang = &quot;Java&quot;;</div><div class="line">lang = lang + &quot;Script&quot;;</div></pre></td></tr></table></figure></p>
<p>上述过程，首先创建一个能容纳10个字符的新字符串，然后在这个字符串中填充”Java”和”Script”。在一些老版本浏览器，字符串拼接的速度很慢。</p>
<p>转换为字符串，在里面可以传递参数返回8进制或者是16进制等。</p>
<h4 id="toString-方法对于Null和undefined不能用，所以在不知道的情况下可以使用转型函数String-可以将null返回”null”-undefined也是如此；"><a href="#toString-方法对于Null和undefined不能用，所以在不知道的情况下可以使用转型函数String-可以将null返回”null”-undefined也是如此；" class="headerlink" title="toString() 方法对于Null和undefined不能用，所以在不知道的情况下可以使用转型函数String(),可以将null返回”null”,undefined也是如此；"></a>toString() 方法对于Null和undefined不能用，所以在不知道的情况下可以使用转型函数String(),可以将null返回”null”,undefined也是如此；</h4><h3 id="Object-类型"><a href="#Object-类型" class="headerlink" title="Object 类型"></a>Object 类型</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">var o = new Object();</div></pre></td></tr></table></figure>
<p>如果没有传递参数，则后面括号可以省略，但不推荐；</p>
<p>在ECMAScript中，Object类型是所有它的实例的基础。<br>Object的每个实例都有如下属性和方法：</p>
<ul>
<li>constructor：保存用于创建当前对象的函数。</li>
<li><p>hasOwnProperty(propertyName): 用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在。如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">o.hasOwnProperty(&quot;name&quot;);</div></pre></td></tr></table></figure>
</li>
<li><p>isPrototypeOf(object): 用于检查传入的对象是否是传入对象的原型。</p>
</li>
<li>propertyIsEnumberable(propertyName): 用于检查给定的属性能否使用for-in<br>toLocalString(): 返回对象的字符串表示，该字符串与执行环境的地区对应。</li>
<li>toString():返回对象的字符串表示。</li>
<li>valueOf():返回对象的字符串、数值或Boolean表示。</li>
</ul>
<p><img src="http://note.youdao.com/yws/res/32604/WEBRESOURCE7ba2feb458d212a72ff7892f889ef282" alt="image"></p>
<h3 id="位操作符"><a href="#位操作符" class="headerlink" title="位操作符"></a>位操作符</h3><p>位操作符在最底层执行操作，速度更快。</p>
<h3 id="逻辑与-amp-amp"><a href="#逻辑与-amp-amp" class="headerlink" title="逻辑与&amp;&amp;"></a>逻辑与&amp;&amp;</h3><p>如果第一个操作数可以返回结果，那第二个操作数就不执行。</p>
<h3 id="for-in"><a href="#for-in" class="headerlink" title="for in"></a>for in</h3><p>for(property in expression) statement ;<br>举例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for(var propName in window)&#123;</div><div class="line">	document.write(propName);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>将window对象存在的属性名赋值给 propName;<br>ECMAScript中对象的属性没有顺序，因此输出的属性名不可预测的。</p>
<p>如果要迭代的对象的变量值为 null 或 undefined ,for-in 为抛出错误，ECMAScript5后更正这一方法<br>建议在循环之前，先确认对象值不是null 或 undefined 。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>未指定返回值的函数返回的是一个特殊的undefined值。</p>
<p>严格模式下对函数有一些限制：</p>
<ol>
<li>不能把函数命名为eval 或者 arguments;</li>
<li>不能把参数命名为eval 或者 arguments;</li>
<li>不能出现两个命名参数同名的情况。</li>
</ol>
<h3 id="理解参数"><a href="#理解参数" class="headerlink" title="理解参数"></a>理解参数</h3><p>ECMAScript函数不介意传递多少个参数，也不在乎传进来的参数是什么数据类型，原因是其参数的内部是用一个数组表示的。函数接受到的永远都是这个数组，而不用关心数组中包含哪些参数。<br>在函数体内可以通过arguments对象来访问这个数组，从而获得传递给函数的每一个参数，arguments对象和数组类似，但不是Array的实例。<br>ECMAScript函数有一个重要特点：命名的函数只提供方便，但不是必需的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">function doAdd()&#123;</div><div class="line">	if(arguments.length == 1) &#123;</div><div class="line">		alert(arguments[0] + 10);</div><div class="line">	&#125;else if (arguments.length == 2)&#123;</div><div class="line">		alert(arguments[0] + arguments[1]);	</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line">doAdd(10);  // 20;</div><div class="line">doAdd(30 , 20) // 50;</div></pre></td></tr></table></figure></p>
<p>如果参数只有1个，那么让第一个参数加上10;如果参数有两个，就让第一个参数和第二个参数相加;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">funcion doAdd(num1, num2)&#123;</div><div class="line">	arguments[1] = 10;</div><div class="line">	alert(arguments[0] + num2);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>每次执行doAdd函数都会重写第二个参数，将其值修改为10。对象中的值会自动反映到对应的命名参数，所以修改arguments[1]等于修改了num2.但两者并不是说访问相同的内存空间，它们的内存空间是独立的，只是值会同步。</p>
<ul>
<li>最后一点：没有传递值得命名参数将自动被赋予undefined值，这跟定义了变量但没初始化一样。</li>
<li>严格模式下对使用arguments对象有一些限制。首先，之前的例子这样赋值给num2无效，num2的值依旧为undefined，其次重写arguments的值会导致语法错误，代码不会执行。</li>
</ul>
<h3 id="没有重载"><a href="#没有重载" class="headerlink" title="没有重载"></a>没有重载</h3><p>如果同一个函数被定义两次，那么执行的是最后版本的函数。但可以根据检查传入函数中的参数类型和数量做出不同的反应，模仿重载。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[函数进阶]]></title>
      <url>https://zaynex.github.io/2016/07/26/%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/</url>
      <content type="html"><![CDATA[<h2 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h2><h3 id="函数声明定义函数的特点"><a href="#函数声明定义函数的特点" class="headerlink" title="函数声明定义函数的特点"></a>函数声明定义函数的特点</h3><p>函数定义会被前置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">	add1(1);</div><div class="line">	function add1(i)&#123;</div><div class="line">		console.log(&quot;函数声明：&quot; +(i+1));</div><div class="line">	&#125;</div><div class="line">	//函数声明：2</div><div class="line">	var add2 = function(i)&#123;</div><div class="line">		console.log(&quot;函数表达式：&quot; +(i+2));</div><div class="line">	&#125;</div><div class="line">	add2(1);</div><div class="line">	//demo.html:13 Uncaught TypeError: add2 is not a function</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>重新定义函数时，最后一次定义才有效<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">	add1(1);</div><div class="line">	function add1(i)&#123;</div><div class="line">		console.log(&quot;函数声明：&quot; +(i+1));</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	function add1(i)&#123;</div><div class="line">		console.log(&quot;函数声明：&quot; +(i+10));</div><div class="line">	&#125;</div><div class="line">	add1(1);</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p>函数表达式和函数实例化多次定义依然互不影响。</p>
<p>我们再来看一个变态例子<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line"></div><div class="line">	function add1(i)&#123;</div><div class="line">		console.log(&quot;函数声明：&quot; +(i+1));</div><div class="line">	&#125;</div><div class="line">	add1(1);</div><div class="line">	var add1 = function(i)&#123;</div><div class="line">		console.log(&quot;函数表达式：&quot; +(i+10));</div><div class="line">	&#125;</div><div class="line">	add1(1);</div><div class="line"></div><div class="line">	function add1(i)&#123;</div><div class="line">		console.log(&quot;函数声明：&quot; +(i+100));</div><div class="line">	&#125;</div><div class="line">	add1(1);</div><div class="line"></div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure></p>
<p>以上代码执行的是<br><img src="http://note.youdao.com/yws/res/32436/WEBRESOURCE06380984317523c4d941f41a172fe557" alt="image"></p>
<p><strong> 事实证明：函数声明会提升到最前面执行，而函数表达式会修改函数声明 </strong></p>
<h3 id="对象实例化定义函数的特点"><a href="#对象实例化定义函数的特点" class="headerlink" title="对象实例化定义函数的特点"></a>对象实例化定义函数的特点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">var person = &#123;name:&quot;刘德华&quot;, age:50&#125;;</div><div class="line">(function()&#123;</div><div class="line">	var person = &#123;name:&quot;刘德华&quot;, age:30&#125;;</div><div class="line">	(function()&#123;</div><div class="line">		//var person = &#123;name:&quot;刘德华&quot;, age:10&#125;;</div><div class="line">		console.log(person.name + person.age + &quot;岁&quot;);</div><div class="line">	&#125;)()</div><div class="line">&#125;)();</div><div class="line">//刘德华30岁</div></pre></td></tr></table></figure>
<p>先从当前作用域中寻找，因为我们已经把10岁的给注释了，所以person会逐级向上作用域查找person，找到则返回，否则一直寻找到全局作用域。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">var person = &#123;name:&quot;刘德华&quot;, age:50&#125;;</div><div class="line"> (function()&#123;</div><div class="line">   var person = &#123;name:&quot;刘德华&quot;, age:30&#125;;</div><div class="line">   var func = new Function(&quot;console.log(person.name+person.age+&apos;岁&apos;);&quot;);</div><div class="line">   func();</div><div class="line">&#125;)();</div><div class="line">//刘德华50岁</div></pre></td></tr></table></figure>
<p>本地作用域中没有perosn，父作用域有peroson，正常情况下会逐级向上访问，但我们发现它直接访问到了全局作用域。</p>
<p><strong>当我们使用对象实例化定义函数时，定义的函数只能访问本地作用域和全局作用域，并不遵循作用域逐级回溯的原则</strong></p>
<h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><h3 id="函数调用模式-add-1"><a href="#函数调用模式-add-1" class="headerlink" title="函数调用模式 add(1)"></a>函数调用模式 add(1)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">add1(1);</div><div class="line">function add1(i)&#123;</div><div class="line">	console.log(&quot;函数声明：&quot; +(i+1));</div></pre></td></tr></table></figure>
<h3 id="构造函数调用模式"><a href="#构造函数调用模式" class="headerlink" title="构造函数调用模式"></a>构造函数调用模式</h3><p><img src="http://note.youdao.com/yws/res/32470/WEBRESOURCEe5598223c91b98a31a34f47e98c9df3d" alt="image"><br>new Function();<br>new Obejct();<br>new Array();</p>
<h3 id="方法调用模式"><a href="#方法调用模式" class="headerlink" title="方法调用模式"></a>方法调用模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var myNumber = &#123;</div><div class="line">   value: 1,</div><div class="line">   add: function(i)&#123;</div><div class="line">   	console.log(this);</div><div class="line">   	this.value += i;</div><div class="line">   &#125;</div><div class="line"> &#125;</div><div class="line">  myNumber.add(1);</div></pre></td></tr></table></figure>
<ul>
<li>本质上没有区别，普通函数也可以被当做构造函数来使用。</li>
<li>构造函数通常会有this指定实例属性，原型对象上通常有一些公共方法。</li>
<li>构造函数命名通常首字母大写。<br>构造函数代表一系列对象的属性及行为的封装，代表一系列对象的类型，通常用首字母大写的方式告诉这是一个类型。</li>
</ul>
<h3 id="apply-call-调用"><a href="#apply-call-调用" class="headerlink" title="apply(call)调用"></a>apply(call)调用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var myNumber = &#123;</div><div class="line">value: 1,</div><div class="line">add: function(i)&#123;</div><div class="line">console.log(this);</div><div class="line">this.value += i;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">myNumber.add(1);</div><div class="line"></div><div class="line">var youNumber = &#123;</div><div class="line">value: 10</div><div class="line">&#125;</div><div class="line">myNumber.add.apply(youNumber,[2]);</div><div class="line">myNumber.add.call(youNumber,2);</div></pre></td></tr></table></figure>
<p><img src="http://note.youdao.com/yws/res/32479/WEBRESOURCE9f6d409067afaaf97a947152b55d046b" alt="image"></p>
<p>我们可以将call()和apply()看作是某个对象的方法，通过调用方法的形式来间接调用函数。call()和apply()的第一个实参是要调用函数的母对象，它是调用上下文，在函数体内通过this来获得它的引用。apply是Function原型构造函数上的一个方法,所有的函数都可以调用apply方法.</p>
<h2 id="通过this体现函数调用差异"><a href="#通过this体现函数调用差异" class="headerlink" title="通过this体现函数调用差异"></a>通过this体现函数调用差异</h2><p>构成函数主体的JS代码在定义之时并不会执行，只有调用该函数时，它们才会执行。<br>函数调用时，会自动在函数内部的本地作用域上自动添加两个临时变量：this和arguments参数。</p>
<h3 id="函数调用——this指向window"><a href="#函数调用——this指向window" class="headerlink" title="函数调用——this指向window"></a>函数调用——this指向window</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function add(i,j)&#123;</div><div class="line">  console.log(this);</div><div class="line">  var sum = i+j;</div><div class="line">  console.log(sum);</div><div class="line">  return sum;</div><div class="line">&#125;</div><div class="line">add(1,2);</div></pre></td></tr></table></figure>
<p>那函数嵌套定义中的this还会指向window吗？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">function add(i,j)&#123;</div><div class="line">  console.log(this);</div><div class="line">  var sum = i+j;</div><div class="line">  console.log(sum);</div><div class="line">  return sum;</div><div class="line">&#125;</div><div class="line">add(1,2);</div></pre></td></tr></table></figure></p>
<p>我们在内部创建了匿名函数，发现居然指向window全局对象<br><img src="http://note.youdao.com/yws/res/32494/WEBRESOURCEb99d241ba6936e7630a3b1c5078a428c" alt="image"></p>
<h3 id="方法调用模式下——this"><a href="#方法调用模式下——this" class="headerlink" title="方法调用模式下——this"></a>方法调用模式下——this</h3><p>this指向方法的调用者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var myNumber = &#123;</div><div class="line">  value: 1,</div><div class="line">  add: function(i)&#123;</div><div class="line">   console.log(this);</div><div class="line">   this.value += i;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> myNumber.add(1);</div></pre></td></tr></table></figure>
<p><img src="http://note.youdao.com/yws/res/32500/WEBRESOURCEa127f39e945208983b34b1c389c86c99" alt="image"></p>
<p>打印的Obejct对象，有value也有add方法，不就是myNumber对象么？</p>
<h3 id="构造函数调用模式下——this"><a href="#构造函数调用模式下——this" class="headerlink" title="构造函数调用模式下——this"></a>构造函数调用模式下——this</h3><p>this指向被构造的这个对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">function Car(type,color)&#123;</div><div class="line">  this.type = type;</div><div class="line">  this.color = color;</div><div class="line">  this.status = &quot;stop&quot;;</div><div class="line">  this.light = &quot;off&quot;;</div><div class="line">  console.log(this);</div><div class="line">&#125;</div><div class="line">Car.prototype.start = function()&#123;</div><div class="line">   this.status = &quot;driving&quot;;</div><div class="line">   this.light = &quot;on&quot;;</div><div class="line">   console.log(this.type + &quot; is &quot; + this.status);</div><div class="line"> &#125;</div><div class="line"> Car.prototype.stop = function()&#123;</div><div class="line">   this.status = &quot;stop&quot;;</div><div class="line">   this.light = &quot;off&quot;;</div><div class="line">   console.log(this.type + &quot; is &quot; + this.status);</div><div class="line"> &#125;</div><div class="line"> var benz = new Car(&quot;benz&quot;, &quot;black&quot;);</div></pre></td></tr></table></figure>
<p><img src="http://note.youdao.com/yws/res/32512/WEBRESOURCE877f3940105b8f4aec661c28b0500fa6" alt="image"></p>
<h3 id="Apply调用模式下——this"><a href="#Apply调用模式下——this" class="headerlink" title="Apply调用模式下——this"></a>Apply调用模式下——this</h3><p>指向第一个参数。</p>
<h3 id="bind-用法"><a href="#bind-用法" class="headerlink" title="bind()用法"></a>bind()用法</h3><p>检查是否有定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">if (!Function.prototype.bind) &#123; </div><div class="line">    	Function.prototype.bind = function(thisObj) &#123; </div><div class="line">        // 获取函数本身</div><div class="line">    	var _func = this, </div><div class="line">        // 获取函数调用者（bind方法的第一个参数）</div><div class="line">         _this = thisObj, </div><div class="line">         // 获取函数绑定的参数列表</div><div class="line">         _params = Array.prototype.slice.call(arguments, 1); </div><div class="line">    </div><div class="line">     // 返回一个函数，外部变量通过持有这个函数引用保存_func,_this,_params这三个闭包变量,并随时执行函数以调用下面语句。</div><div class="line">     return function()&#123; </div><div class="line">       var _localParams = Array.prototype.slice.call(arguments);</div><div class="line">      _params = _params.concat(_localParams);</div><div class="line">       _func.apply(_this, _params); // 实现函数调用</div><div class="line">     &#125;</div><div class="line">   &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<h3 id="函数作为返回值——bind"><a href="#函数作为返回值——bind" class="headerlink" title="函数作为返回值——bind"></a>函数作为返回值——bind</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">var move = function(x,y)&#123;</div><div class="line">     this.x += x;</div><div class="line">     this.y += y;</div><div class="line"> &#125;</div><div class="line">  // 定一个点p</div><div class="line"> var p = &#123;x:1, y:1&#125;; </div><div class="line"> // bind方法收受一个参数，并返回一个接受余下参数的函数过程。此时p点并没有移动。</div><div class="line"> var pmove0 = move.bind(p); </div><div class="line"> console.log(p);</div><div class="line"> // 这时p移动到了（2,3）位置。</div><div class="line">  pmove0(1,2); </div><div class="line"> console.log(p);</div><div class="line"> </div><div class="line"> // 当然你也可以这样调用</div><div class="line"> var pmove1 = move.bind(p,1);</div><div class="line"> console.log(p);</div><div class="line"> pmove1(2);</div><div class="line"> console.log(p);</div><div class="line"></div><div class="line">// 或者这样调用</div><div class="line"> var pmove2 = move.bind(p,1,2);</div><div class="line"> console.log(p);</div><div class="line"> pmove2();</div><div class="line"> console.log(p);</div></pre></td></tr></table></figure>
<h3 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h3><p>将接受多个参数的函数，转换为接受单一参数函数并返回一个接受其他后续参数的函数的转换过程。简单来说就是：将复杂问题片段化，使之进行简化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">var sum(a,b,c)&#123;</div><div class="line">  return a + b + c;</div><div class="line">&#125;</div><div class="line">var sum_curry = function(a)&#123;</div><div class="line">  return function(b,c)&#123;</div><div class="line">    return a+b+c;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>更泛化的定义是指给函数分步传递参数，每次函数接受部分参数后应用这些参数，并返回一个函数接受剩下的参数，这中间可嵌套多层这样的接受部分参数的函数，直至返回最后结果。归纳一下就是逐步传参，逐步缩小函数的适用范围，逐步求解的过程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"> var currying = function (fn) &#123;</div><div class="line">    var _args = [];</div><div class="line">    return function () &#123;</div><div class="line">     if (arguments.length === 0) &#123;</div><div class="line">       // 实现最终的计算</div><div class="line">       return fn.apply(this, _args); </div><div class="line">    &#125;</div><div class="line">//     // 这里只是简单的将参数缓存起来（用于解释柯里化概念，并非实际应用场景）</div><div class="line">    Array.prototype.push.apply(_args, [].slice.call(arguments)); </div><div class="line">     return arguments.callee;</div><div class="line">    &#125;</div><div class="line"> &#125;;</div><div class="line">  // sum函数接受任意参数，并返回求和结果</div><div class="line"> var sum=function () &#123;</div><div class="line">    var total = 0;</div><div class="line">    for (var i = 0, c; c = arguments[i++];) &#123;</div><div class="line">        total += c;</div><div class="line">    &#125;</div><div class="line">   return total;</div><div class="line"> &#125;;</div><div class="line"> // 或得一个泛化柯里化的sum函数</div><div class="line"> var sum_curry = currying(sum); </div><div class="line"> sum_curry(1)(2,3);</div><div class="line"> sum_curry(4);</div><div class="line"> console.log(sum_curry());</div></pre></td></tr></table></figure>
<p>从更上层的角度去理解，柯里化允许和鼓励你将一个复杂过程分割成一个个更小的更容易分析的过程（这些小的逻辑单元将更容易被理解和测试），最后这样一个难于理解复杂的过程将变成一个个小的逻辑简单的过程的组合。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关于函数传参对于直接原始类型而言，是按值传递，对于引用类型，是按共享传递这部分也不理解。关于this的指向还没有掌握，以及apply、call、bind的用法。感觉视频中很多内容不连贯，比如 以上这些方法的继承都是来自Function的原型链，但是原型还没有讲。内容衔接性不高。</p>
]]></content>
    </entry>
    
  
  
</search>
